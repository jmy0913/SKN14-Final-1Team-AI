user_input,retrieved_contexts,response,reference
CSV 파일을 이용해서 S/MIME 인증서를 관리하려면 어떤 작업이 필요한가요?,"['except (OSError, IOError) as error:\n    print(f""An error occured while reading the CSV file: {error}"")\n\n\nif __name__ == ""__main__"":\n  insert_cert_from_csv(csv_filename=""xyz"")\n인증서 관리\n이 예에서는 smimeInfo API의 여러 호출을 결합하여 조직의 인증서를 관리하는 방법을 보여줍니다. 사용자의 인증서를 나열하고 기본 인증서가 만료되었거나 설정되지 않은 경우 지정된 파일에서 찾은 인증서를 업로드합니다. 그런 다음 만료일이 가장 늦은 인증서를 기본값으로 설정합니다.\n그런 다음 이전 예와 같이 CSV 파일을 처리하는 함수에서 이를 호출합니다.\n--- 탭: 자바 ---\n.filepath {\n    color: #fff;\n    margin: 6px;\n    max-width: calc(100% - 160px); /* Give at least 160px for the ""View on GitHub"" button. */\n    text-overflow: ellipsis;\n    text-shadow: rgba(0,0,0,0.1) 1px 1px;\n    overflow: hidden;\n  }\n  .github-docwidget-gitinclude-code .prettyprint {\n    margin: 0;\n  }\n  .view-on-github {\n    text-shadow: rgba(12,12,12,0.1) 1px 1px;\n  }\n\n\n\n  \n  gmail/snippets/src/main/java/UpdateSmimeCerts.java\n  \n    \n    GitHub에서 보기 [https://github.com/googleworkspace/java-samples/blob/main/gmail/snippets/src/main/java/UpdateSmimeCerts.java]'
 '--- 탭: Python ---\n이전의 create_smime_info 및 insert_smime_info 호출을 사용하여 CSV 파일에 지정된 인증서를 업로드할 수 있습니다.\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n\n\n\n\n\n\n\n\n\n\n\n  .filepath {\n    color: #fff;\n    margin: 6px;\n    max-width: calc(100% - 160px); /* Give at least 160px for the ""View on GitHub"" button. */\n    text-overflow: ellipsis;\n    text-shadow: rgba(0,0,0,0.1) 1px 1px;\n    overflow: hidden;\n  }\n  .github-docwidget-gitinclude-code .prettyprint {\n    margin: 0;\n  }\n  .view-on-github {\n    text-shadow: rgba(12,12,12,0.1) 1px 1px;\n  }\n\n\n\n  \n  gmail/snippet/smime snippets/insert_cert_from_csv.py\n  \n    \n    GitHub에서 보기 [https://github.com/googleworkspace/python-samples/blob/main/gmail/snippet/smime%20snippets/insert_cert_from_csv.py]\n  \n  \n  \n\n  \n    \n  \n  \n  import csv\n\nimport create_smime_info\nimport insert_smime_info\n\n\ndef insert_cert_from_csv(csv_filename):\n  """"""Upload S/MIME certificates based on the contents of a CSV file.\n  Each row of the CSV file should contain a user ID, path to the certificate,\n  and the certificate password.\n\n  Args:\n    csv_filename: Name of the CSV file.\n  """"""'
 ""이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGmail [https://developers.google.com/workspace/gmail?hl=ko]\n가이드 [https://developers.google.com/workspace/gmail/api/guides?hl=ko]\n의견 보내기\nS/MIME 인증서 관리\nbookmark_border\n이 페이지의 내용\nAPI 액세스 승인\nACL 범위\nAPI 사용\nS/MIME 키 업로드\n사용자의 S/MIME 키 나열\n별칭의 S/MIME 키 가져오기\nS/MIME 키 삭제\n별칭의 기본 S/MIME 키 설정\nGmail S/MIME API는 Google Workspace 도메인의 사용자를 위한 S/MIME 이메일 인증서를 관리할 수 있는 프로그래매틱 액세스를 제공합니다.\n인증서가 작동하려면 관리자가 도메인에 S/MIME을 사용 설정 [https://support.google.com/a/answer/6374496?hl=ko]해야 합니다.\nS/MIME 표준 [https://en.wikipedia.org/wiki/S/MIME]은 공개 키 암호화 및 MIME 데이터 서명에 관한 사양을 제공합니다. 사용자 계정에서 S/MIME 인증서를 구성하면 Gmail에서 다음과 같은 방식으로 해당 인증서를 사용합니다.\nGmail은 사용자의 인증서와 비공개 키를 사용하여 발신 메일에 서명합니다.\nGmail은 사용자의 비공개 키를 사용하여 수신 메일을 복호화합니다.\nGmail은 수신자의 인증서와 공개 키를 사용하여 발신 메일을 암호화합니다.\nGmail은 발신자의 인증서와 공개 키를 사용하여 수신 메일을 확인합니다.\n개별 S/MIME 인증서를 생성하고 API를 사용하여 업로드합니다. 각 S/MIME 인증서는 사용자 이메일 계정의 특정 별칭에 해당합니다. 별칭에는 기본 이메일 주소와 맞춤 '다른 주소에서 메일 보내기' 주소가 포함됩니다. 단일 S/MIME 인증서가 각 별칭의 기본값으로 표시됩니다.\nAPI 액세스 승인""
 '/* Class to demonstrate the use of Gmail Insert Certificate from CSV File */\npublic class InsertCertFromCsv {\n  /**\n   * Upload S/MIME certificates based on the contents of a CSV file.\n   *\n   * <p>Each row of the CSV file should contain a user ID, path to the certificate, and the\n   * certificate password.\n   *\n   * @param csvFilename Name of the CSV file.\n   */\n  public static void insertCertFromCsv(String csvFilename) {\n    try {\n      File csvFile = new File(csvFilename);\n      CSVParser parser =\n          CSVParser.parse(csvFile, java.nio.charset.StandardCharsets.UTF_8, CSVFormat.DEFAULT);\n      for (CSVRecord record : parser) {\n        String userId = record.get(0);\n        String certFilename = record.get(1);\n        String certPassword = record.get(2);\n        SmimeInfo smimeInfo = CreateSmimeInfo.createSmimeInfo(certFilename,\n            certPassword);\n        if (smimeInfo != null) {\n          InsertSmimeInfo.insertSmimeInfo(userId,\n              userId,\n              smimeInfo);\n        } else {\n          System.err.printf(""Unable to read certificate file for userId: %s\\n"", userId);\n        }\n      }\n    } catch (Exception e) {'
 'Args:\n    csv_filename: Name of the CSV file.\n  """"""\n\n  try:\n    with open(csv_filename, ""rb"") as cert:\n      csv_reader = csv.reader(cert, delimiter="","")\n      next(csv_reader, None)  # skip CSV file header\n      for row in csv_reader:\n        user_id = row[0]\n        cert_filename = row[1]\n        cert_password = row[2]\n        smime_info = create_smime_info.create_smime_info(\n            cert_filename=cert_filename, cert_password=cert_password\n        )\n        if smime_info:\n          insert_smime_info.insert_smime_info()\n        else:\n          print(f""Unable to read certificate file for user_id: {user_id}"")\n        return smime_info\n\n  except (OSError, IOError) as error:\n    print(f""An error occured while reading the CSV file: {error}"")'
 'if not send_as_email:\n      send_as_email = user_id\n\n    # pylint: disable=maybe-no-member\n    results = (\n        service.users()\n        .settings()\n        .sendAs()\n        .smimeInfo()\n        .insert(userId=user_id, sendAsEmail=send_as_email, body=smime_info)\n        .execute()\n    )\n    print(f\'Inserted certificate; id: {results[""id""]}\')\n\n  except HttpError as error:\n    print(f""An error occurred: {error}"")\n    results = None\n\n  return results\n\n\nif __name__ == ""__main__"":\n  insert_smime_info()\n여러 사용자의 인증서 관리 예\n조직의 여러 사용자에 대한 인증서를 한 번에 관리해야 할 수 있습니다. 다음 예에서는 일괄 호출 하나로 여러 사용자의 인증서를 관리하는 방법을 보여줍니다.\nCSV 파일에서 인증서 삽입\n사용자 ID와 각 사용자의 인증서 경로가 나열된 CSV 파일이 있다고 가정해 보겠습니다.\n$ cat certificates.csv\nuser1@example.com,/path/to/user1_cert.p12,cert_password_1\nuser2@example.com,/path/to/user2_cert.p12,cert_password_2\nuser3@example.com,/path/to/user3_cert.p12,cert_password_3\n--- 탭: 자바 ---\n이전의 createSmimeInfo 및 insertSmimeInfo 호출을 사용하여 CSV 파일에 지정된 인증서를 업로드할 수 있습니다.'
 '특정 키로 서명된 S/MIME 메일을 수신할 때 Gmail에서는 연결된 사용자에게 전송되는 메일을 암호화할 때 가장 먼 미래의 not_before 유효 기간을 기본값으로 사용하여 키를 연결합니다. 사용자가 이미 소통한 Gmail 사용자가 새 기본 키를 사용하도록 하려면 새 기본 키의 not_before 날짜가 이전 기본 키보다 늦거나 이전 기본 키를 취소해야 합니다.\n샘플 코드\n다음 코드 샘플은 API를 사용하여 사용자가 여러 명인 조직의 S/MIME 인증서를 관리하는 방법을 보여줍니다.\nS/MIME 인증서의 SmimeInfo 리소스 만들기\n다음 코드 샘플은 파일에서 인증서를 읽고, base64url 문자열로 인코딩하고, smimeInfo 리소스의 pkcs12 필드에 할당하는 방법을 보여줍니다.\n--- 탭: 자바 ---\n.filepath {\n    color: #fff;\n    margin: 6px;\n    max-width: calc(100% - 160px); /* Give at least 160px for the ""View on GitHub"" button. */\n    text-overflow: ellipsis;\n    text-shadow: rgba(0,0,0,0.1) 1px 1px;\n    overflow: hidden;\n  }\n  .github-docwidget-gitinclude-code .prettyprint {\n    margin: 0;\n  }\n  .view-on-github {\n    text-shadow: rgba(12,12,12,0.1) 1px 1px;\n  }\n\n\n\n  \n  gmail/snippets/src/main/java/CreateSmimeInfo.java\n  \n    \n    GitHub에서 보기 [https://github.com/googleworkspace/java-samples/blob/main/gmail/snippets/src/main/java/CreateSmimeInfo.java]\n  \n  \n  \n\n  \n    \n  \n  \n  import com.google.api.services.gmail.model.SmimeInfo;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Base64;'
 'from datetime import datetime\n\nimport create_smime_info\nimport google.auth\nimport insert_smime_info\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\n\ndef update_smime_cert(\n    user_id, send_as_email, cert_filename, cert_password, expire_dt\n):\n  """"""Update S/MIME certificates for the user.\n\n  First performs a lookup of all certificates for a user.  If there are no\n  certificates, or they all expire before the specified date/time, uploads the\n  certificate in the specified file.  If the default certificate is expired or\n  there was no default set, chooses the certificate with the expiration furthest\n  into the future and sets it as default.\n\n  Args:\n    user_id: User\'s email address.\n    send_as_email: The ""send as"" email address, or None if it should be the same\n        as user_id.\n    cert_filename: Name of the file containing the S/MIME certificate.\n    cert_password: Password for the certificate file, or None if the file is not\n        password-protected.\n    expire_dt: DateTime object against which the certificate expiration is\n      compared.  If None, uses the current time.'
 '/* Class to demonstrate the use of Gmail Update Smime Certificate API*/\npublic class UpdateSmimeCerts {\n  /**\n   * Update S/MIME certificates for the user.\n   *\n   * <p>First performs a lookup of all certificates for a user. If there are no certificates, or\n   * they all expire before the specified date/time, uploads the certificate in the specified file.\n   * If the default certificate is expired or there was no default set, chooses the certificate with\n   * the expiration furthest into the future and sets it as default.\n   *\n   * @param userId       User\'s email address.\n   * @param sendAsEmail  The ""send as"" email address, or None if it should be the same as user_id.\n   * @param certFilename Name of the file containing the S/MIME certificate.\n   * @param certPassword Password for the certificate file, or None if the file is not\n   *                     password-protected.\n   * @param expireTime   DateTime object against which the certificate expiration is compared. If\n   *                     None, uses the current time. @ returns: The ID of the default certificate.\n   * @return The ID of the default certificate, {@code null} otherwise.'
 'def get_authorization_url(email_address, state):\n  """"""Retrieve the authorization URL.\n\n  Args:\n    email_address: User\'s e-mail address.\n    state: State for the authorization URL.\n\n  Returns:\n    Authorization URL to redirect the user to.\n  """"""\n  flow = flow_from_clientsecrets(CLIENTSECRETS_LOCATION, \' \'.join(SCOPES))\n  flow.params[\'access_type\'] = \'offline\'\n  flow.params[\'approval_prompt\'] = \'force\'\n  flow.params[\'user_id\'] = email_address\n  flow.params[\'state\'] = state\n  # The step1_get_authorize_url method uses the flow.redirect_uri attribute.\n  flow.redirect_uri = REDIRECT_URI\n  return flow.step1_get_authorize_url()\n\ndef get_credentials(authorization_code, state):\n  """"""Retrieve credentials using the provided authorization code.\n\n  This function exchanges the authorization code for an access token and queries\n  the UserInfo API to retrieve the user\'s e-mail address.\n\n  If a refresh token has been retrieved along with an access token, it is stored\n  in the application database using the user\'s e-mail address as key.'
 'Q: 여러 사용자의 S/MIME 인증서를 한 번에 관리하기 위해 어떤 방법을 사용할 수 있나요?\nA: 여러 사용자의 S/MIME 인증서를 한 번에 관리하기 위해 CSV 파일을 사용하여 사용자 ID와 각 사용자의 인증서 경로를 나열하고, 이를 기반으로 일괄 호출을 수행할 수 있습니다.'
 'Q: S/MIME 인증서를 관리하기 위해 CSV 파일을 처리하는 함수에서 어떤 작업을 수행해야 하나요?\nA: S/MIME 인증서를 관리하기 위해 CSV 파일을 처리하는 함수에서는 사용자의 인증서를 나열하고, 기본 인증서가 만료되었거나 설정되지 않은 경우 지정된 파일에서 인증서를 업로드해야 합니다. 그런 다음 만료일이 가장 늦은 인증서를 기본값으로 설정하는 작업을 수행해야 합니다.'
 'Q: 여러 사용자의 S/MIME 인증서를 CSV 파일을 통해 한 번에 업로드하려면 어떤 방법을 사용해야 하나요?\nA: 여러 사용자의 S/MIME 인증서를 CSV 파일을 통해 한 번에 업로드하려면, `insertCertFromCsv` 메서드를 사용해야 합니다. 이 메서드는 CSV 파일의 각 행에 사용자 ID, 인증서 경로, 인증서 비밀번호가 포함되어 있어야 합니다. 다음은 Java 코드 예시입니다:\n\n```java\npublic static void insertCertFromCsv(String csvFilename) {\n    try {\n        File csvFile = new File(csvFilename);\n        CSVParser parser =\n            CSVParser.parse(csvFile, java.nio.charset.StandardCharsets.UTF_8, CSVFormat.DEFAULT);\n        for (CSVRecord record : parser) {\n            String userId = record.get(0);\n            String certFilename = record.get(1);\n            String certPassword = record.get(2);\n            SmimeInfo smimeInfo = CreateSmimeInfo.createSmimeInfo(certFilename,\n                certPassword);\n            if (smimeInfo != null) {\n                InsertSmimeInfo.insertSmimeInfo(userId,\n                    userId,\n                    smimeInfo);\n            } else {\n                System.err.printf(""Unable to read certificate file for userId: %s\\n"", userId);\n            }\n        }\n    } catch (Exception e) {\n        System.err.printf(""An error occured while reading the CSV file: %s"", e);\n    }\n}\n```'
 'Q: CSV 파일에서 S/MIME 인증서를 업로드할 때 각 행의 형식은 어떻게 되나요?\nA: CSV 파일에서 S/MIME 인증서를 업로드할 때 각 행은 사용자 ID, 인증서 경로, 인증서 비밀번호의 형식으로 구성되어야 합니다. 예를 들어:\n```\nuser1@example.com,/path/to/user1_cert.p12,cert_password_1\nuser2@example.com,/path/to/user2_cert.p12,cert_password_2\nuser3@example.com,/path/to/user3_cert.p12,cert_password_3\n```'
 'Q: Python에서 CSV 파일을 통해 여러 사용자의 S/MIME 인증서를 업로드하는 방법은 무엇인가요?\nA: Python에서 CSV 파일을 통해 여러 사용자의 S/MIME 인증서를 업로드하려면, `insert_cert_from_csv` 함수를 사용해야 합니다. 이 함수는 CSV 파일의 각 행에 사용자 ID, 인증서 경로, 인증서 비밀번호가 포함되어 있어야 합니다. 다음은 Python 코드 예시입니다:\n\n```python\ndef insert_cert_from_csv(csv_filename):\n  try:\n    with open(csv_filename, ""rb"") as cert:\n      csv_reader = csv.reader(cert, delimiter="","")\n      next(csv_reader, None)  # skip CSV file header\n      for row in csv_reader:\n        user_id = row[0]\n        cert_filename = row[1]\n        cert_password = row[2]\n        smime_info = create_smime_info.create_smime_info(\n            cert_filename=cert_filename, cert_password=cert_password\n        )\n        if smime_info:\n          insert_smime_info.insert_smime_info()\n        else:\n          print(f""Unable to read certificate file for user_id: {user_id}"")\n  except (OSError, IOError) as error:\n    print(f""An error occured while reading the CSV file: {error}"")\n```'
 'Q: S/MIME 인증서를 CSV 파일에서 읽을 때 발생할 수 있는 예외는 무엇인가요?\nA: S/MIME 인증서를 CSV 파일에서 읽을 때 발생할 수 있는 예외는 `OSError`와 `IOError`입니다. 이러한 예외는 파일을 열거나 읽는 과정에서 문제가 발생했을 때 발생합니다.'
 'Q: Python에서 S/MIME 인증서를 CSV 파일에서 읽을 때 발생할 수 있는 오류는 무엇인가요?\nA: CSV 파일을 읽을 때 발생할 수 있는 오류는 `OSError` 또는 `IOError`입니다.'
 'Q: Python에서 S/MIME 인증서를 생성할 때 파일을 읽는 방법은 무엇인가요?\nA: Python에서 S/MIME 인증서를 생성할 때 파일을 읽기 위해 `open` 함수를 사용하여 파일을 바이너리 모드로 열고, `read` 메서드를 사용하여 파일 내용을 읽습니다. 예시는 다음과 같습니다:\n\n```python\nwith open(cert_filename, ""rb"") as cert:\n    data = cert.read().encode(""UTF-8"")\n```'
 'Q: Python에서 CSV 파일을 통해 S/MIME 인증서를 업로드할 때, 각 행에 포함되어야 하는 정보는 무엇인가요?\nA: 각 행에는 사용자 ID(user ID), 인증서 경로(path to the certificate), 인증서 비밀번호(certificate password)가 포함되어야 합니다.'
 'Q: S/MIME 인증서를 업로드할 때 발생할 수 있는 IOException의 원인은 무엇인가요?\nA: S/MIME 인증서를 업로드할 때 발생할 수 있는 `IOException`의 원인은 서비스 계정 자격 증명 파일을 찾을 수 없거나, 인증서 파일을 읽는 과정에서 발생할 수 있습니다.'
 'Q: S/MIME 인증서를 업로드할 때 발생할 수 있는 IOException의 원인은 무엇인가요?\nA: S/MIME 인증서를 업로드할 때 발생할 수 있는 IOException의 원인은 서비스 계정 자격 증명 파일을 찾을 수 없을 때입니다.'
 'Q: S/MIME 인증서를 업데이트할 때 발생할 수 있는 IOException의 원인은 무엇인가요?\nA: S/MIME 인증서를 업데이트할 때 발생할 수 있는 IOException의 원인은 서비스 계정 자격 증명 파일을 찾을 수 없거나, 인증서 파일이 잘못되었거나, 네트워크 오류 등 여러 가지가 있을 수 있습니다.'
 'Q: Python에서 S/MIME 인증서를 업데이트할 때, 기본 인증서를 설정하는 방법은 무엇인가요?\nA: Python에서 S/MIME 인증서를 업데이트할 때, 기본 인증서를 설정하기 위해 `setDefault` 메서드를 사용합니다. 다음은 관련 코드입니다:\n\n```python\nif default_id:\n    try:\n        service.users().settings().sendAs().smimeInfo().setDefault(\n            userId=user_id, sendAsEmail=send_as_email, id=default_id\n        ).execute()\n        return default_id\n    except HttpError as error:\n        print(f""An error occurred during setDefault: {error}"")\n```'
 'Q: Java에서 S/MIME 인증서를 업데이트하기 위해 어떤 메서드를 사용해야 하나요?\nA: S/MIME 인증서를 업데이트하기 위해 `updateSmimeCerts` 메서드를 사용해야 합니다.'
 ""Q: Java에서 S/MIME 인증서를 업로드하기 위해 어떤 메서드를 사용해야 하나요?\nA: S/MIME 인증서를 업로드하기 위해 Java에서는 `insertSmimeInfo` 메서드를 사용해야 합니다. 이 메서드는 사용자의 이메일 주소, 'send as' 이메일 주소, 그리고 S/MIME 인증서를 포함하는 `SmimeInfo` 객체를 매개변수로 받습니다.""
 'Q: Python에서 S/MIME 인증서를 업로드하기 위해 어떤 라이브러리를 사용해야 하나요?\nA: Python에서 S/MIME 인증서를 업로드하기 위해 `create_smime_info` 및 `insert_smime_info` 라이브러리를 사용해야 합니다.'
 'Q: S/MIME 인증서를 업로드할 때 기본 키 설정에 대한 주의사항은 무엇인가요?\nA: 사용자의 SendAs에는 하나의 S/MIME 키만 기본값으로 설정할 수 있습니다. `setDefault()`를 호출하면 이전 기본값이 설정 해제됩니다. 특정 키로 서명된 S/MIME 메일을 수신할 때 Gmail에서는 연결된 사용자에게 전송되는 메일을 암호화할 때 가장 먼 미래의 `not_before` 유효 기간을 기본값으로 사용하여 키를 연결합니다.'
 'Q: S/MIME 인증서를 업데이트할 때, 인증서 파일이 비밀번호로 보호되어 있는지 확인하는 방법은 무엇인가요?\nA: S/MIME 인증서를 업데이트할 때, 인증서 파일이 비밀번호로 보호되어 있는지 확인하기 위해 `cert_password` 매개변수를 사용합니다. 비밀번호가 None인 경우, 파일이 비밀번호로 보호되지 않은 것으로 간주합니다. 다음은 관련 코드입니다:\n\n```python\ncert_password: Password for the certificate file, or None if the file is not\n    password-protected.\n```'
 'Q: Python에서 S/MIME 인증서를 업로드하기 위해 어떤 요청 본문 구조를 사용해야 하나요?\nA: Python에서 S/MIME 인증서를 업로드하기 위해 요청 본문에 `smimeInfo` 리소스를 포함해야 합니다. 이 리소스는 S/MIME 인증서 정보를 담고 있어야 합니다.'
 'Q: S/MIME 인증서를 업로드할 때 API가 수행하는 유효성 검사는 무엇인가요?\nA: API는 S/MIME 인증서를 업로드하기 전에 다음과 같은 표준 유효성 검사를 수행합니다: 제목이 지정된 이메일 주소와 일치하는지, 만료가 유효한지, 발급 인증 기관 (CA)이 신뢰할 수 있는 목록에 있는지, 인증서가 Gmail의 기술적 제약 조건과 일치하는지.'
 'Q: Java에서 Gmail API를 사용하여 이메일 메시지를 생성하는 방법은 무엇인가요?\nA: 다음은 Java에서 이메일 메시지를 생성하는 코드 예시입니다.\n```java\nimport java.util.Properties;\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\n/* Class to demonstrate the use of Gmail Create Email API  */\npublic class CreateEmail {\n\n  /**\n   * Create a MimeMessage using the parameters provided.\n   *\n   * @param toEmailAddress   email address of the receiver\n   * @param fromEmailAddress email address of the sender, the mailbox account\n   * @param subject          subject of the email\n   * @param bodyText         body text of the email\n   * @return the MimeMessage to be used to send email\n   * @throws MessagingException - if a wrongly formatted address is encountered.\n   */\n  public static MimeMessage createEmail(String toEmailAddress,\n                                        String fromEmailAddress,\n                                        String subject,\n                                        String bodyText)\n      throws MessagingException {\n    Properties props = new Properties();\n    Session session = Session.getDefaultInstance(props, null);\n\n    MimeMessage email = new MimeMessage(session);\n\n    email.setFrom(new InternetAddress(fromEmailAddress));\n    email.addRecipient(javax.mail.Message.RecipientType.TO,\n        new InternetAddress(toEmailAddress));\n    email.setSubject(subject);\n    email.setText(bodyText);\n    return email;\n  }\n}\n```'
 'Q: Python에서 S/MIME 인증서를 생성하기 위해 어떤 메서드를 사용해야 하나요?\nA: Python에서 S/MIME 인증서를 생성하기 위해 `create_smime_info` 함수를 사용합니다. 이 함수는 인증서 파일의 이름과 비밀번호를 매개변수로 받아 S/MIME 정보를 포함하는 객체를 반환합니다. 다음은 코드 샘플입니다.\n\n```python\nimport base64\n\ndef create_smime_info(cert_filename, cert_password):\n  """"""Create an smimeInfo resource for a certificate from file.\n  Args:\n    cert_filename: Name of the file containing the S/MIME certificate.\n    cert_password: Password for the certificate file, or None if the file is not\n        password-protected.\n  Returns : Smime object, including smime information\n  """"""\n\n  smime_info = None\n  try:\n    with open(cert_filename, ""rb"") as cert:\n      smime_info = {}\n      data = cert.read().encode(""UTF-8"")\n      smime_info[""pkcs12""] = base64.urlsafe_b64encode(data).decode()\n      if cert_password and len(cert_password) > 0:\n        smime_info[""encryptedKeyPassword""] = cert_password\n  except Exception as e:\n    print(f""An error occurred: {e}"")\n  return smime_info\n```'
 'Q: S/MIME 인증서를 업로드할 때 어떤 형식으로 요청해야 하나요?\nA: S/MIME 인증서를 업로드할 때 S/MIME 인증서와 비공개 키는 해당 형식의 pkcs12 필드에 있어야 합니다. 요청에 다른 필드를 설정하면 안 됩니다. PKCS12 필드에는 사용자 S/MIME 키와 서명 인증서 체인이 모두 포함되어야 합니다.'
 'Q: S/MIME 인증서와 비공개 키는 어떤 형식으로 요청해야 하나요?\nA: S/MIME 인증서와 비공개 키는 pkcs12 필드에 있어야 하며, 이 필드에는 사용자 S/MIME 키와 서명 인증서 체인이 모두 포함되어야 합니다.'
 'Q: Java에서 MimeMessage를 base64url로 인코딩하여 Gmail API 메시지를 생성하는 방법은 무엇인가요?\nA: 다음은 Java에서 MimeMessage를 base64url로 인코딩하여 메시지를 생성하는 코드 예시입니다.\n```java\nimport com.google.api.services.gmail.model.Message;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeMessage;\nimport org.apache.commons.codec.binary.Base64;\n\n/* Class to demonstrate the use of Gmail Create Message API */\npublic class CreateMessage {\n\n  /**\n   * Create a message from an email.\n   *\n   * @param emailContent Email to be set to raw of message\n   * @return a message containing a base64url encoded email\n   * @throws IOException        - if service account credentials file not found.\n   * @throws MessagingException - if a wrongly formatted address is encountered.\n   */\n  public static Message createMessageWithEmail(MimeMessage emailContent)\n      throws MessagingException, IOException {\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    emailContent.writeTo(buffer);\n    byte[] bytes = buffer.toByteArray();\n    String encodedEmail = Base64.encodeBase64URLSafeString(bytes);\n    Message message = new Message();\n    message.setRaw(encodedEmail);\n    return message;\n  }\n}\n```'
 'Q: S/MIME 인증서를 업로드하기 위해 어떤 메서드를 사용해야 하나요?\nA: S/MIME 키를 업로드하기 위해서는 smimeInfo.insert() 메서드를 사용해야 합니다.'
 'Q: S/MIME 키의 기본값을 설정하기 위해 어떤 메서드를 사용해야 하나요?\nA: S/MIME 키의 기본값을 설정하기 위해 `setDefault()` 메서드를 사용합니다. 이 메서드는 지정된 S/MIME 키를 지정된 별칭의 기본값으로 설정합니다. 다음 매개변수를 사용하여 타겟 별칭을 식별합니다: `userId`, `sendAsEmail`, `id`.'
 ""Q: Python에서 S/MIME 인증서를 업데이트하기 위해 어떤 메서드를 사용해야 하나요?\nA: Python에서 S/MIME 인증서를 업데이트하기 위해 `update_smime_cert` 함수를 사용해야 합니다. 이 함수는 사용자 이메일 주소, 'send as' 이메일 주소, S/MIME 인증서 파일 이름, 인증서 파일 비밀번호, 만료 시간을 매개변수로 받습니다.""]","CSV 파일을 이용하여 S/MIME 인증서를 관리하려면 다음과 같은 작업이 필요합니다:

1. **CSV 파일 준비**: CSV 파일에는 각 행에 사용자 ID, 인증서 경로, 인증서 비밀번호가 포함되어야 합니다. 예를 들어:
   ```
   user1@example.com,/path/to/user1_cert.p12,cert_password_1
   user2@example.com,/path/to/user2_cert.p12,cert_password_2
   user3@example.com,/path/to/user3_cert.p12,cert_password_3
   ```

2. **CSV 파일 처리 함수 사용**: Python에서는 `insert_cert_from_csv` 함수를 사용하여 CSV 파일을 처리할 수 있습니다. 이 함수는 CSV 파일을 열고 각 행을 읽어 사용자 ID, 인증서 경로, 인증서 비밀번호를 추출합니다. 그런 다음 `create_smime_info`와 `insert_smime_info` 함수를 사용하여 인증서를 업로드합니다.

3. **오류 처리**: CSV 파일을 읽는 동안 `OSError` 또는 `IOError`가 발생할 수 있으며, 이러한 오류는 파일을 열거나 읽는 과정에서 문제가 발생했을 때 발생합니다. 이러한 오류를 적절히 처리하여 사용자에게 알릴 수 있습니다.

이러한 과정을 통해 여러 사용자의 S/MIME 인증서를 한 번에 관리할 수 있습니다.","CSV 파일을 처리하는 함수에서는 사용자의 인증서를 나열하고, 기본 인증서가 만료되었거나 설정되지 않은 경우 지정된 파일에서 인증서를 업로드해야 합니다. 그리고 만료일이 가장 늦은 인증서를 기본값으로 설정하는 작업을 해야 합니다."
클라우드 파이어스토어 부하 분산기 어떻게 써야되나요?,"['Cloud Firestore의 분할은 필요할 때 또는 키 공간이 확장될 때 더 많은 스토리지 서버에 트래픽을 제공하는 작업을 분산하기 위해 자동으로 더 작은 조각으로 분할됩니다. 초과 트래픽을 처리하기 위해 생성된 분할은 트래픽이 사라지더라도 약 24시간 동안 보관됩니다. 따라서 반복적으로 트래픽이 급증하면 분할이 유지되고 필요할 때마다 더 많은 분할이 도입됩니다.  이러한 메커니즘은 트래픽 부하 또는 데이터베이스 크기가 증가하면 Cloud Firestore 데이터베이스가 자동 확장되는 데 도움이 됩니다. 하지만 아래에 설명된 대로 주의해야 할 몇 가지 제한사항이 있습니다.\n\n스토리지와 부하를 분할하는 데 시간이 걸리는 데다가, 트래픽을 너무 빨리 늘리면 서비스가 조정되는 동안 지연 시간 증가 또는 기한 초과 오류(일반적으로 핫스팟이라고 함)가 발생할 수 있습니다. 그러므로 키 범위 전반에 작업을 분산하면서 초당 500개의 작업을 수행하는 데이터베이스의 컬렉션에서 트래픽을 늘리는 것이 좋습니다. 점진적으로 늘린 후에 5분마다 최대 50%씩 트래픽을 늘립니다. 이 프로세스를 500/50/5 규칙이라고 하며, 워크로드에 맞게 최적으로 확장되도록 데이터베이스를 배치합니다.\n핵심사항: 최적의 확장을 위해 500/50/5 규칙에 따라 트래픽을 늘려야 합니다.\n분할은 부하 증가에 따라 자동으로 생성되지만 Cloud Firestore에서는 전용 복제 스토리지 서버 집합을 사용하여 단일 문서를 제공할 때까지만 키 범위를 분할할 수 있습니다. 그 결과, 단일 문서에서 지속적으로 많은 양의 작업을 동시 실행하면 해당 문서에 핫스팟이 발생할 수 있습니다. 단일 문서에서 긴 지연 시간이 지속적으로 발생하는 경우 여러 문서에 걸쳐 데이터를 분할하거나 복제하도록 데이터 모델을 수정해야 합니다.'
 'Cloud Firestore는 비즈니스 요구사항을 충족하기 위해 자동 확장을 제공하는 고도로 분산된 시스템입니다. Cloud Firestore는 시스템에서 수신한 부하에 따라 데이터를 동적으로 분할하고 결합합니다.\n\n부하 기반 분할은 사전 구성 없이 자동으로 이루어집니다. Cloud Firestore 부하 기반 분할 시스템에는 데이터를 모델링할 때 유의해야 하는 다른 문서 데이터베이스와 비교되는 중요한 고유한 특징이 있습니다.\n\nCloud Firestore의 분산된 특성으로 인해 일부 설계 옵션을 변경해야 할 수 있습니다. 특히 기본 복제본이 쓰기 처리량의 병목 현상인 데이터베이스에 최적화된 워크로드의 경우 더욱 그렇습니다.\n\n권장사항\n\n단일 스레드 클라이언트에서 대량의 데이터를 처리하는 워크로드는 병목 현상을 일으킬 수 있습니다. 클라이언트와 서버의 처리량이 유사하게 일치하므로 클라이언트가 단일 스레딩을 사용하여 데이터를 일괄 로드할 수 있습니다.\nCloud Firestore 데이터베이스는 훨씬 더 많은 동시 로드를 처리할 수 있지만 클라이언트가 요청을 동시에 전송하도록 구성해야 합니다.\n\nmongoimport\n\nmongoimport 도구를 사용하면 기본적으로 요청이 순차적으로 이루어집니다.\nCloud Firestore로의 로드 시간을 개선하려면 --numInsertionWorkers 플래그를 사용하여 작업자 수를 설정하세요.\n올바른 설정은 클라이언트 크기에 따라 조정해야 할 수 있지만 일반적으로 최소 32로 시작하는 것이 좋습니다.\n\n비동기 프로그래밍\n\nMongoDB 호환 API를 사용하여 자체 소프트웨어를 개발할 때 다음과 같은 방법으로 동시 로드를 개선할 수 있습니다.\n\n비동기 프레임워크: 비동기 프레임워크를 사용하면 요청을 동시에 처리하고 응답할 수 있습니다. 데이터베이스를 호출할 때 복잡한 풀링이나 큐를 개발할 필요가 없습니다.\n각 요청 흐름은 독립적인 연결을 사용하고 데이터베이스 동시에 호출할 수 있습니다.\n병렬 컴퓨팅 제품 사용: Cloud Run과 같은 서비스를 사용하면 시스템에서 데이터를 처리하는 데 필요한 컴퓨팅 작업자 수를 확장할 수 있습니다.\n\n일시적인 실패\n\nCloud Firestore와 같은 대규모 분산 시스템으로 작업할 때는 네트워크 일시적 오류나 문서의 경합과 같은 일시적인 오류가 발생할 수 있습니다.'
 'require ""google/cloud/firestore""\n\nfirestore = Google::Cloud::Firestore.new project_id: project_id\n\nshards_ref = firestore.col_group collection_path\n\ncount = 0\nshards_ref.get do |doc_ref|\ncount += doc_ref[:count]\nend\n\nputs ""Count value is #{count}.""distributed_counters.rb [https://github.com/googleapis/google-cloud-ruby/blob/0539c9e4faccfe857c5cd0999d9f50f1a4404531/google-cloud-firestore/samples/distributed_counters.rb#L60-L74]\n\n제한사항\n\n위 솔루션은 Cloud Firestore에서 공유 카운터를 만드는 확장 가능한 방법이지만 다음과 같은 제한사항에 유의해야 합니다.\n\n샤드 수 - 샤드 수는 분산 카운터의 성능을 좌우합니다. 샤드가 너무 적으면 일부 트랜잭션을 재시도해야 하므로 쓰기 작업이 느려집니다. 샤드가 너무 많으면 읽기가 느려지고 비용이 증가합니다.  더 느린 주기로 업데이트되는 개별 롤업 문서에서 카운터 합계를 유지하고 클라이언트가 이 문서를 읽어 합계를 가져오도록 하면 읽기 비용을 상쇄할 수 있습니다. 하지만 이 경우 클라이언트가 업데이트 직후 모든 샤드를 읽어 합계를 계산하지 않고 롤업 문서가 업데이트될 때까지 기다려야 한다는 단점이 있습니다.\n비용 - 카운터 값을 읽을 때 전체 샤드 하위 컬렉션이 로드되어야 하므로 샤드 수에 따라 비용이 선형으로 증가합니다.\n\n의견 보내기'
 '스토리지와 부하를 분할하는 데 시간이 걸리는 데다가, 트래픽을 너무 빨리 늘리면 서비스가 조정되는 동안 지연 시간 증가 또는 기한 초과 오류(일반적으로 핫스팟이라고 함)가 발생할 수 있습니다. 그러므로 키 범위 전반에 작업을 분산하면서 초당 500개의 작업을 수행하는 데이터베이스의 컬렉션에서 트래픽을 늘리는 것이 좋습니다. 점진적으로 늘린 후에 5분마다 최대 50%씩 트래픽을 늘립니다. 이 프로세스를 500/50/5 규칙이라고 하며, 워크로드에 맞게 최적으로 확장되도록 데이터베이스를 배치합니다.\n핵심사항: 최적의 확장을 위해 500/50/5 규칙에 따라 트래픽을 늘려야 합니다.\n분할은 부하 증가에 따라 자동으로 생성되지만 Firestore에서는 전용 복제 스토리지 서버 집합을 사용하여 단일 문서를 제공할 때까지만 키 범위를 분할할 수 있습니다. 그 결과, 단일 문서에서 지속적으로 많은 양의 작업을 동시 실행하면 해당 문서에 핫스팟이 발생할 수 있습니다. 단일 문서에서 긴 지연 시간이 지속적으로 발생하는 경우 여러 문서에 걸쳐 데이터를 분할하거나 복제하도록 데이터 모델을 수정해야 합니다.'
 '순차적으로 색인이 지정된 필드의 쓰기 속도 제한은 Cloud Firestore에서 색인 값을 저장하고 색인 쓰기를 조정하는 방법에 좌우됩니다. Cloud Firestore는 색인 쓰기별로 문서 이름과 각 색인이 지정된 필드의 값을 연결하는 키-값 항목을 정의합니다. Cloud Firestore는 이러한 색인 항목을 태블릿이라는 데이터 그룹으로 정리합니다. Cloud Firestore 서버마다 태블릿이 한 개 이상 있습니다. 특정 태블릿에 대한 쓰기 부하가 너무 높아지면 Cloud Firestore는 태블릿을 더 작은 태블릿으로 분할하고 서로 다른 Cloud Firestore 서버에 새 태블릿을 분산하여 수평으로 확장합니다.\n\nCloud Firestore는 사전순으로 가까운 색인 항목을 동일한 태블릿에 배치합니다. timestamp 필드에서와 같이 태블릿의 색인 값들이 서로 너무 가까이에 있으면 Cloud Firestore에서 태블릿을 더 작은 태블릿으로 효율적으로 분할하지 못합니다. 이로 인해 단일 태블릿에서 너무 많은 트래픽을 수신하는 핫스팟이 생성되고 핫스팟에 대한 읽기 및 쓰기 작업 속도가 더 느려집니다.\n\ntimestamp 필드를 샤딩하면 Cloud Firestore에서 워크로드를 여러 태블릿에 효율적으로 분할할 수 있습니다. timestamp 필드의 값은 서로 가깝게 유지되더라도 연결된 샤드 및 색인 값 덕분에 Cloud Firestore의 색인 항목 간 공간이 충분히 넓기 때문에 여러 태블릿으로 항목을 분할할 수 있습니다.\n\n다음 단계\n\n규모 확장을 위한 설계 권장사항 [https://firebase.google.com/docs/firestore/best-practices?hl=ko#designing_for_scale] 읽기\n단일 문서에 대한 쓰기 속도가 높은 경우 분산 카운터 [https://firebase.google.com/docs/firestore/solutions/counters?hl=ko] 참조\nCloud Firestore의 표준 제한사항 [https://firebase.google.com/docs/firestore/quotas?hl=ko#limits] 참조\n\n도움이 되었나요?\n\n의견 보내기'
 'Cloud Firestore 작업, 스토리지, 네트워크 대역폭은 모두 사용량에 따라 청구되지만 추가 비용 없이 이용할 수 있는 다른 혜택도 많습니다. Cloud Firestore와 다른 데이터베이스 옵션을 비교할 때 무료로 제공되는 다음 서비스를 살펴보세요.\n\n직접 클라이언트 액세스: Cloud Firestore는 기본 SDK를 사용하여 클라이언트 코드에서 직접 액세스합니다. 즉, 모바일 클라이언트를 이 데이터베이스에 연결하기 위해 API 서버를 구축하고 실행할 필요가 없습니다.\n부하 분산: Cloud Firestore는 데이터베이스에 대한 트래픽을 지원하기 위해 자동으로 확장되므로 부하 분산기를 실행할 필요가 없습니다.\n서버 업타임: Cloud Firestore 데이터베이스는 Google Cloud 서버에서 작동하며, 월 99% 이상의 업타임 [https://cloud.google.com/firestore/sla?hl=ko]을 제공합니다.\n인증: Firebase Authentication [https://firebase.google.com/products/auth/?hl=ko]을 사용하여 사용자를 무제한으로 간단하고 안전하게 인증할 수 있습니다. Firebase Authentication은 Cloud Firestore와 직접 통합되므로 자체 인증 서비스를 실행할 필요가 없습니다.\n푸시 알림: Cloud Messaging [https://firebase.google.com/products/cloud-messaging/?hl=ko]으로 메시지와 알림을 보낼 수 있습니다.\n기타 Firebase 제품: A/B 테스팅, 애널리틱스, Crashlytics, Performance Monitoring, 원격 구성 등 다른 Firebase 제품을 무료로 통합하세요. 기타 Firebase 제품 [https://firebase.google.com/products/?hl=ko]과 Firebase 가격 책정 [https://firebase.google.com/pricing/?hl=ko]에 대해 자세히 알아보세요.\n\n도움이 되었나요?\n\n의견 보내기'
 'Source URL: https://cloud.google.com/firestore/docs/keyvis-patterns-index?hl=ko\nTitle: 색인 키의 히트맵 패턴\nbookmark_border\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\n\n의견 보내기\n\n이 페이지의 내용고르게 분산된 사용량 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#even-distribution]순차 키의 색인 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#indexes_on_sequential_keys]타임스탬프 증가로 인한 부하 집중 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#hotspotting_due_to_increasing_timestamp]필드 이름 증가로 인한 부하 집중 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#hotspotting_due_to_increasing_names]색인 키 구조 이해 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#understand_the_index_key_structure]히트맵의 색인 키 항목 예시 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#examples_of_index_key_entries_on_the_heatmap]다음 단계 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#whats-next]\n\n색인 키의 히트맵 패턴\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.'
 'Source URL: https://cloud.google.com/firestore/docs/disaster-recovery?hl=ko\nTitle: 재해 복구 계획\nbookmark_border\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\n\n의견 보내기\n\n이 페이지의 내용클라우드 인프라 서비스 중단 시 재해 복구 계획 [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#disaster_recovery_planning_for_cloud_infrastructure_outages]데이터를 위한 재해 복구 계획 [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#disaster_recovery_planning_for_data]예약 백업 [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#scheduled_backups]PITR(point-in-time recovery) [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#point-in-time_recovery_pitr]다음 단계 [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#whats_next]\n\n재해 복구 계획\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지에서는 재해 복구 계획을 만들고 구현하는 데 도움이 되는 Firestore 기능을 설명합니다.\n\n클라우드 인프라 서비스 중단 시 재해 복구 계획\n\n서비스 중단이 발생한 영역이나 리전과 같이 Google Cloud에서 잠재적인 클라우드 인프라 중단을 방지하기 위해 Firestore는 여러 복제본 데이터베이스에 데이터를 복제합니다.'
 '색인 키의 히트맵 패턴\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지에서는 Key Visualizer 히트맵에 표시될 수 있는 패턴 예시를 설명합니다. 이러한 패턴은 특정 성능 문제를 해결하는 데 도움이 될 수 있습니다.\n\n고르게 분산된 사용량\n\n히트맵에 밝고 어두운 색상이 고운 결로 혼합되어 표시되는 경우에는 데이터베이스 전반에서 색인 키의 쓰기/삭제 작업이 고르게 분산된 것입니다. 이 히트맵은 Firestore의 효과적인 사용 패턴을 나타냅니다.\n\n순차 키의 색인\n\n밝은 대각선 하나가 있는 히트맵은 타임스탬프와 같이 엄격하게 증가하거나 감소하는 키에 있는 색인을 나타낼 수 있습니다. 순차 키의 색인은 권장되지 않으며 핫스팟을 만들 수 있습니다. 부하 집중 시 해당하는 지연 시간이 길어질 수 있습니다.\n\n색인에 있는 일반적인 핫스팟의 예시는 다음과 같습니다.\n참고: Firestore의 경우 다음 히트맵 예시에서 히트맵의 x축은 시간을, y축은 색인 키를 나타냅니다.\n타임스탬프 증가로 인한 부하 집중\n\n이 예시에서 밝은 대각선 하나가 있는 히트맵은 타임스탬프 필드 이름에서 색인 쓰기/삭제 작업을 엄격하게 늘리거나 줄이는 데 사용하는 데이터베이스를 나타낼 수 있습니다.\n\n필드 이름 증가로 인한 부하 집중\n\n이 예시에서 밝은 대각선 하나가 있는 히트맵은 자동 생성된 인보이스 번호와 같이 증분 필드에서 색인 쓰기/삭제 작업을 엄격하게 늘리거나 줄이는 데 사용하는 데이터베이스를 나타낼 수 있습니다.\n\n부하 집중 문제를 식별하려면 Key Visualizer 도구를 사용하고 색인 키 구조를 이해 [https://cloud.google.com/firestore/docs/keyvis-patterns-index?hl=ko#understand_the_index_key_structure]하여 문제를 일으키는 색인을 결정하고 권장사항 [https://cloud.google.com/firestore/native/docs/best-practices?hl=ko#high_read_write_and_delete_rates_to_a_narrow_document_range]에 따라 이러한 색인을 제외합니다.\n\n색인 키 구조 이해'
 '클라우드 인프라 서비스 중단 시 재해 복구 계획\n\n서비스 중단이 발생한 영역이나 리전과 같이 Google Cloud에서 잠재적인 클라우드 인프라 중단을 방지하기 위해 Firestore는 여러 복제본 데이터베이스에 데이터를 복제합니다.\n\n복제 아키텍처는 데이터베이스가 리전 위치에 있는지 아니면 멀티 리전 위치에 있는지에 따라 달라집니다. 리전 데이터베이스는 3개 이상의 영역에 데이터를 동기식으로 복제합니다. 멀티 리전 데이터베이스는 3개 리전(2개의 제공 리전과 1개의 감시 리전)에서 5개의 영역에 데이터를 동기식으로 복제합니다. 멀티 리전 데이터베이스는 99.999%의 가용성을 제공하여 데이터베이스의 가용성과 내구성을 극대화합니다. 리전 데이터베이스는 99.99%의 가용성을 제공합니다.\n\nFirestore는 복제를 자동으로 처리하며 추가 구성이나 프로비저닝이 필요하지 않습니다. 자세한 내용은 다음을 참조하세요.\n\n복제 아키텍처에 대한 자세한 내용은 클라우드 인프라 중단을 위한 재해 복구 설계 [https://cloud.google.com/architecture/disaster-recovery?hl=ko#firestore]를 참조하세요.\n\n데이터를 위한 재해 복구 계획\n\n우발적인 데이터 삭제 또는 수정과 같은 데이터 재해로부터 보호하려면 예약된 백업 및 PITR(point-in-time recovery)을 사용합니다. 재해 복구 요구사항에 따라 두 기능을 함께 사용할 수 있습니다.\n\n예약 백업\n\n백업은 최대 14주 보관을 지원합니다. 일 혹은 주 단위로 백업을 예약할 수 있습니다. 백업에서 동일한 프로젝트의 새 Firestore 데이터베이스로 데이터베이스를 복원할 수 있습니다. 자세한 내용은 데이터 백업 및 복원 [https://cloud.google.com/firestore/native/docs/backups?hl=ko]을 참조하세요.\n\n백업은 PITR보다 보관 기간이 더 깁니다. 백업에서 데이터베이스를 복원하는 것은 PITR 데이터에서 데이터베이스를 복원하는 것보다 비용이 저렴합니다.\n\nPITR(point-in-time recovery)'
 'Source URL: https://firebase.google.com/docs/firestore/index.html?hl=ko\nTitle: Cloud Firestore\nbookmark_border\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\n이 페이지의 내용주요 기능 [https://firebase.google.com/docs/firestore/index.html?hl=ko#key_capabilities]기본 원리 [https://firebase.google.com/docs/firestore/index.html?hl=ko#how_does_it_work]구현 경로 [https://firebase.google.com/docs/firestore/index.html?hl=ko#implementation_path]다음 단계 [https://firebase.google.com/docs/firestore/index.html?hl=ko#next_steps]\n\nCloud Firestore\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nplat_ios\nplat_android\nplat_web\nplat_flutter\nplat_cpp\nplat_unity\nplat_node\nplat_java\nplat_python\nplat_go\n\nGoogle Cloud 인프라를 기반으로 하는 유연하고 확장 가능한 NoSQL 클라우드 데이터베이스를 사용해 클라이언트 측 개발 및 서버 측 개발에 사용되는 데이터를 저장하고 동기화하세요.'
 'Source URL: https://firebase.google.com/docs/firestore/quickstart?hl=ko\nTitle: Cloud Firestore 시작하기\nbookmark_border\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\nCloud Firestore 시작하기\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.'
 '많은 앱이 Cloud Firestore가 예방 조치 없이 수용할 수 있는 예측 가능한 유기적인 성장을 보입니다. 그러나 대규모 데이터 세트 가져오기와 같은 일괄 워크로드는 쓰기 작업을 너무 빠르게 늘릴 수 있습니다. 앱을 설계할 때는 쓰기 트래픽의 출처를 염두에 두어야 합니다.\n핵심 사항: Cloud Firestore는 자동으로 확장되지만 쓰기를 너무 빨리 늘리면 경합 및 성능 문제가 발생합니다. 쓰기 핫스팟이 생성되지 않도록 5-5-5 규칙 [https://firebase.google.com/docs/firestore/best-practices?hl=ko#ramping_up_traffic]을 따라야 합니다.\n쓰기와 읽기의 상호작용 방식 이해\n\n실시간 쿼리 시스템을 쓰기 작업을 리더와 연결하는 파이프라인이라고 볼 수 있습니다. 문서가 생성, 업데이트 또는 삭제될 때마다 변경사항이 스토리지 시스템에서 현재 등록된 리스너로 전파됩니다. Cloud Firestore의 변경 로그 구조는 strong consistency를 보장합니다. 즉, 앱이 데이터베이스가 데이터 변경사항을 커밋했을 때와 비교해 순서에 맞지 않는 업데이트 알림은 받지 않습니다. 이를 통해 데이터 일관성과 관련된 특이 사례를 제거하여 앱 개발을 간소화합니다.\n\n이 연결된 파이프라인은 핫스팟이나 잠금 경합을 유발하는 쓰기 작업이 읽기 작업에 부정적인 영향을 줄 수 있다는 것을 의미합니다.\n쓰기 작업이 실패하거나 제한이 있는 경우 변경 로그의 일관된 데이터를 기다리는 읽기 작업이 중단될 수 있습니다. 이 문제가 앱에서 발생하면 쓰기 작업과 쿼리에 대한 응답 속도가 모두 느려질 수 있습니다. 핫스팟을 피하는 것이 바로 이 문제를 해결하는 열쇠입니다.\n핵심사항: 쓰기와 스냅샷 리스너가 연결됩니다. 쓰기 작업에 문제가 있으면 응답 속도가 느려질 수 있습니다.\n문서 및 쓰기 작업을 작게 유지\n\n스냅샷 리스너로 앱을 빌드할 때는 일반적으로 사용자가 데이터 변경사항을 빠르게 파악하도록 하는 것이 좋습니다. 이렇게 하려면 작게 유지해보세요. 시스템은 수십 개의 필드가 있는 작은 문서를 시스템을 통해 신속하게 푸시할 수 있습니다. 수백 개의 필드와 대규모 데이터가 포함된 대용량 문서는 처리 시간이 더 오래 걸립니다.'
 'Source URL: https://firebase.google.com/docs/firestore?hl=ko\nTitle: Cloud Firestore\nbookmark_border\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\n이 페이지의 내용주요 기능 [https://firebase.google.com/docs/firestore?hl=ko#key_capabilities]기본 원리 [https://firebase.google.com/docs/firestore?hl=ko#how_does_it_work]구현 경로 [https://firebase.google.com/docs/firestore?hl=ko#implementation_path]다음 단계 [https://firebase.google.com/docs/firestore?hl=ko#next_steps]\n\nCloud Firestore\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nplat_ios\nplat_android\nplat_web\nplat_flutter\nplat_cpp\nplat_unity\nplat_node\nplat_java\nplat_python\nplat_go\n\nGoogle Cloud 인프라를 기반으로 하는 유연하고 확장 가능한 NoSQL 클라우드 데이터베이스를 사용해 클라이언트 측 개발 및 서버 측 개발에 사용되는 데이터를 저장하고 동기화하세요.\n\nCloud Firestore는 Firebase 및 Google Cloud의 모바일, 웹, 서버 개발에 사용되는 유연하고 확장 가능한 데이터베이스입니다. Firebase Realtime Database와 마찬가지로 실시간 리스너를 통해 클라이언트 애플리케이션 간에 데이터의 동기화를 유지하고 모바일 및 웹에 대한 오프라인 지원을 제공해 네트워크 지연 시간이나 인터넷 연결에 상관없이 원활하게 반응하는 앱을 개발할 수 있습니다. Cloud Firestore는 Cloud Functions를 비롯한 다른 Firebase 및 Google Cloud 제품과도 원활하게 통합됩니다.'
 "". We'll cover Cloud SQL, Spanner, Firestore, Bigtable, and more. Understand when to use each forYouTubeStop guessing! Choose the right Google Cloud databaseEnroll today! → https://goo.gle/4icxI12 Tired of database confusion? Learn to confidently select the right Google Cloud database for ANY application! This course breaks down Cloud SQL, AlloyDB, Spanner, Bigtable, Firestore, and Memorystore. Plus, getYouTube🧠 Problem: Too much data for embedding? 🤯🧩 Solution: Chunk your data! ✂️A core principal of RAG is to search through your data to use as an input for LLMs. You can embed the data into a vector so it is searchable, but if you have a large video or entire book that will be too much data in one embedding. Let's talk aboutYouTubeGenAI is a game changer for podcasts 💡🎧Gemini is revolutionizing how I learn from tech podcasts! It helps me pinpoint the exact discussions that align with my interests, so I can deep-dive into the topics that matter most""
 'C++\ndb->LoadBundle(""bundle_name"", [](const LoadBundleTaskProgress& progress) {\nswitch(progress.state()) {\ncase LoadBundleTaskProgress::State::kError: {\n// The bundle load has errored. Handle the error in the returned future.\nreturn;\n}\ncase LoadBundleTaskProgress::State::kInProgress: {\nstd::cout << ""Bytes loaded from bundle: "" << progress.bytes_loaded()\n<< std::endl;\nbreak;\n}\ncase LoadBundleTaskProgress::State::kSuccess: {\nstd::cout << ""Bundle load succeeeded"" << std::endl;\nbreak;\n}\n}\n}).OnCompletion([db](const Future<LoadBundleTaskProgress>& future) {\nif (future.error() != Error::kErrorOk) {\n// Handle error...\nreturn;\n}\n\nconst std::string& query_name = ""latest_stories_query"";\ndb->NamedQuery(query_name).OnCompletion([](const Future<Query>& query_future){\nif (query_future.error() != Error::kErrorOk) {\n// Handle error...\nreturn;\n}\n\nconst Query* query = query_future.result();\nquery->Get().OnCompletion([](const Future<QuerySnapshot> &){\n// ...\n});\n});\n});snippets.cpp [https://github.com/firebase/snippets-cpp/blob/778b6bcc8e8e8fcabb1c2e3a8d11ab51a26aa77b/firestore/android/FirestoreSnippetsCpp/app/src/main/cpp/snippets.cpp#L1215-L1249]'
 '| UpdateField |\n| --- |\n| rpc UpdateField(UpdateFieldRequest) returns (Operation) Updates a field configuration. Currently, field updates apply only to single field index configuration. However, calls to FirestoreAdmin.UpdateField should provide a field mask to avoid changing any configuration that the caller isn\'t aware of. The field mask should be specified as: { paths: ""index_config"" }. This call returns a google.longrunning.Operation which may be used to track the status of the field update. The metadata for the operation will be the type FieldOperationMetadata. To configure the default field settings for the database, use the special Field with resource name: projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*. Authorization scopes Requires one of the following OAuth scopes: https://www.googleapis.com/auth/datastore https://www.googleapis.com/auth/cloud-platform For more information, see the Authentication Overview. |\n\nBackup\n\nA Backup of a Cloud Firestore Database.The backup contains all documents and index configurations for the given database at a specific point in time.'
 '| UpdateField |\n| --- |\n| rpc UpdateField(UpdateFieldRequest) returns (Operation) Updates a field configuration. Currently, field updates apply only to single field index configuration. However, calls to FirestoreAdmin.UpdateField should provide a field mask to avoid changing any configuration that the caller isn\'t aware of. The field mask should be specified as: { paths: ""index_config"" }. This call returns a google.longrunning.Operation which may be used to track the status of the field update. The metadata for the operation will be the type FieldOperationMetadata. To configure the default field settings for the database, use the special Field with resource name: projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*. Authorization scopes Requires one of the following OAuth scopes: https://www.googleapis.com/auth/datastore https://www.googleapis.com/auth/cloud-platform For more information, see the OAuth 2.0 Overview. |\n\nBackup\n\nA Backup of a Cloud Firestore Database.The backup contains all documents and index configurations for the given database at a specific point in time.'
 ""| Fields |\n| --- |\n| collectionIds[] | string Which collection IDs to export. Unspecified means all collections. Each collection ID in this list must be unique. |\n| outputUriPrefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |\n| namespaceIds[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |""
 'Q: Cloud Firestore의 부하 분산 기능은 어떻게 작동하나요?\nA: Cloud Firestore는 데이터베이스에 대한 트래픽을 지원하기 위해 자동으로 확장되므로 부하 분산기를 실행할 필요가 없습니다.'
 'Q: Cloud Firestore에서 핫스팟을 방지하기 위해 문서 ID를 어떻게 설정해야 하나요?\nA: 부하 집중을 방지하려면 분산형 알고리즘을 사용하는 Cloud Firestore 자동 문서 ID를 활용하여 문서 ID를 사전순으로 분산하는 것이 좋습니다.'
 'Q: Cloud Firestore의 부하 기반 분할 시스템의 특징은 무엇인가요?\nA: Cloud Firestore는 시스템에서 수신한 부하에 따라 데이터를 동적으로 분할하고 결합합니다. 부하 기반 분할은 사전 구성 없이 자동으로 이루어집니다.'
 'Q: Cloud Firestore에서 자주 업데이트해야 하는 집계와 관련된 해결 방법은 무엇인가요?\nA: 더 자주 업데이트해야 하는 집계와 관련된 해결 방법은 분산 카운터 (distributed counter)를 참조하세요.'
 'Q: Cloud Firestore는 대규모 워크로드를 어떻게 처리하나요?\nA: Cloud Firestore는 대규모 워크로드를 처리하기 위해 여러 머신 또는 스토리지 서버에서 저장하고 제공할 수 있는 별도의 조각으로 데이터를 분할합니다. 이러한 파티션은 분할이라는 키 범위 블록의 데이터베이스 테이블에서 만들어집니다.'
 'Q: Key Visualizer 도구를 사용하여 부하 집중 문제를 어떻게 식별하나요?\nA: 부하 집중 문제를 식별하려면 Key Visualizer 도구를 사용하고 색인 키 구조를 이해하여 문제를 일으키는 색인을 결정하고 권장사항에 따라 이러한 색인을 제외합니다.'
 'Q: Firestore에서 인덱스를 삭제하는 요청은 어떻게 하나요?\nA: 인덱스를 삭제하기 위해서는 DeleteIndexRequest를 사용해야 합니다.'
 'Q: Firestore에서 데이터베이스를 복원하는 요청은 어떻게 하나요?\nA: 데이터베이스를 복원하기 위해서는 RestoreDatabaseRequest를 사용해야 합니다.'
 'Q: Firestore에서 데이터베이스를 복제할 때, 복제된 데이터베이스의 위치는 어떻게 설정하나요?\nA: 복제된 데이터베이스는 기존 데이터베이스와 동일한 클라우드 지역(cloud region) 또는 다중 지역(multi-region) 위치에 생성되어야 합니다.'
 'Q: Firestore에서 백업 스케줄을 업데이트하는 요청은 어떻게 하나요?\nA: 백업 스케줄을 업데이트하기 위해서는 UpdateBackupScheduleRequest를 사용해야 합니다.'
 'Q: Firestore에서 사용자 자격 증명을 비활성화하는 요청은 어떻게 하나요?\nA: 사용자 자격 증명을 비활성화하기 위해서는 DisableUserCredsRequest를 사용해야 합니다.'
 'Q: Firebase의 블로그에 접근하려면 어떤 링크를 사용해야 하나요?\nA: Firebase의 블로그에 접근하려면 [여기](https://firebase.googleblog.com/)를 사용해야 합니다.'
 'Q: Firebase 콘솔에 접근하려면 어떤 링크를 사용해야 하나요?\nA: Firebase 콘솔에 접근하려면 [여기](https://console.firebase.google.com/)를 사용해야 합니다.'
 'Q: 부하 집중 문제를 해결하기 위한 권장사항은 무엇인가요?\nA: 부하 집중 문제를 해결하기 위해서는 문제를 일으키는 색인을 결정하고 권장사항에 따라 이러한 색인을 제외해야 합니다.'
 'Q: Cloud Firestore에서 쿼리를 실행하려면 어떤 메서드를 사용해야 하나요?\nA: 쿼리를 실행하려면 `RunQuery` 메서드를 사용해야 합니다.'
 'Q: Cloud Firestore에서 트랜잭션을 시작하려면 어떤 메서드를 사용해야 하나요?\nA: 트랜잭션을 시작하려면 `BeginTransaction` 메서드를 사용해야 합니다.'
 'Q: Cloud Firestore에서 문서 업데이트를 위해 어떤 메서드를 사용해야 하나요?\nA: 문서를 업데이트하려면 `UpdateDocument` 메서드를 사용해야 합니다.'
 'Q: Google Cloud Firestore에서 documents를 export할 때, 어떤 HTTP 요청을 사용해야 하나요?\nA: POST https://firestore.googleapis.com/v1/{name=projects/*/databases/*}:exportDocuments를 사용해야 합니다.'
 'Q: long-running operation을 삭제하려면 어떤 메서드를 사용해야 하나요?\nA: long-running operation을 삭제하려면 `delete` 메서드(메서드: delete)를 사용해야 합니다.'
 'Q: Firestore에서 필드를 업데이트하는 요청은 어떻게 하나요?\nA: 필드를 업데이트하기 위해서는 `UpdateFieldRequest`를 사용해야 합니다. 이 요청은 특정 필드의 속성을 수정하는 데 사용됩니다.'
 'Q: Cloud Firestore에서 부하 집중 문제를 해결하기 위한 도구는 무엇인가요?\nA: Cloud Firestore는 사용 패턴을 분석하고 부하 집중 문제를 해결하기 위해 설계된 진단 도구로 Key Visualizer를 제공합니다.'
 'Q: Cloud Firestore에서 문서를 업데이트하거나 삽입하려면 어떤 메서드를 사용해야 하나요?\nA: 문서를 업데이트하거나 삽입하려면 `UpdateDocument` 메서드를 사용해야 합니다.'
 'Q: Firestore에서 벡터 저장소를 사용하려면 어떤 클래스를 사용해야 하나요?\nA: Firestore에서 벡터 저장소를 사용하려면 FirestoreVectorStore 클래스를 사용해야 합니다.'
 'Q: Cloud Firestore Enterprise 버전에서 MongoDB 호환성을 갖춘 클라이언트를 사용하기 위한 연결 요구사항은 무엇인가요?\nA: MongoDB 호환성을 갖춘 Cloud Firestore 클라이언트에는 다음이 필요합니다.\n\n- 드라이버는 load balanced 모드로 연결해야 합니다.\n- 드라이버는 SSL이 사용 설정된 상태로 연결해야 합니다.\n- 드라이버는 재시도 가능한 쓰기를 사용 중지해야 합니다. MongoDB 호환성을 갖춘 Cloud Firestore는 재시도 가능한 쓰기를 지원하지 않습니다. 재시도 가능한 읽기는 지원되므로 사용 중지할 필요가 없습니다.'
 'Q: Cloud Firestore에서 콘텐츠를 어떻게 저장하고 분류하나요?\nA: 내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요. Cloud Firestore 및 Firebase Extensions를 사용하여 AI 모델로 오디오 및 이미지 리소스의 가치를 최대한 활용하세요.'
 'Q: mongoimport 도구를 사용하여 Cloud Firestore에 데이터를 일괄 로드할 때, 요청의 순차적 처리 문제를 어떻게 해결할 수 있나요?\nA: Cloud Firestore로의 로드 시간을 개선하려면 --numInsertionWorkers 플래그를 사용하여 작업자 수를 설정하세요. 올바른 설정은 클라이언트 크기에 따라 조정해야 할 수 있지만 일반적으로 최소 32로 시작하는 것이 좋습니다.'
 'Q: google.rpc.Status의 필드에는 어떤 정보가 포함되나요?\nA: | Fields |\n| --- |\n| code | int32 The status code, which should be an enum value of google.rpc.Code. |\n| message | string A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client. |\n| details[] | Any A list of messages that carry the error details. There is a common set of message types for APIs to use. |'
 'Q: FirestoreAdmin API에서 CloneDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}. |'
 'Q: Firestore에서 데이터베이스를 복제하기 위한 CloneDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}. |'
 'Q: Firestore에서 데이터베이스 복제 요청의 CloneDatabaseRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}.'
 ""Q: FirestoreAdmin API에서 ImportDocumentsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to import. Unspecified means all collections included in the import. Each collection ID in this list must be unique. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |""
 ""Q: FirestoreAdmin API에서 ImportDocumentsRequest의 요청 구조는 어떻게 되나요?\nA: ImportDocumentsRequest의 요청 구조는 다음과 같습니다:\n\n| Fields |\n| --- |\n| name | string Required. Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to import. Unspecified means all collections included in the import. Each collection ID in this list must be unique. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique.""
 'Q: google.rpc.Status의 message 필드는 어떤 언어로 작성되어야 하나요?\nA: A developer-facing error message, which should be in English.'
 'Q: RestoreDatabaseMetadata에서 progressPercentage 필드는 어떤 정보를 제공하나요?\nA: progressPercentage | object (Progress) How far along the restore is as an estimated percentage of remaining time.'
 'Q: RestoreDatabaseMetadata의 progressPercentage 필드는 어떤 정보를 포함하나요?\nA: progressPercentage | object (Progress) How far along the restore is as an estimated percentage of remaining time.'
 ""Q: Firestore에서 CreateUserCredsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id}/databases/{database_id} |\n| user_creds | UserCreds Required. The user creds to create. |\n| user_creds_id | string Required. The ID to use for the user creds, which will become the final component of the user creds's resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. |""
 ""Q: FirestoreAdmin API에서 ExportDocumentsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to export. Unspecified means all collections. Each collection ID in this list must be unique. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |\n| snapshot_time | Timestamp The timestamp that corresponds to the version of the database to be exported. The timestamp must be in the past, rounded to the minute and not older than earliestVersionTime. If specified, then the exported documents will represent a consistent view of the database at the provided time. Otherwise, there are no guarantees about the consistency of the exported documents.""
 'Q: FirestoreAdmin API에서 RestoreDatabaseRequest의 database_id 필드는 어떤 규칙을 따라야 하나요?\nA: | Fields |\n| --- |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |'
 ""Q: FirestoreAdmin API에서 ExportDocumentsRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| name | string Required. Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to export. Unspecified means all collections. Each collection ID in this list must be unique. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |\n| snapshot_time | Timestamp The timestamp that corresponds to the version of the database to be exported. The timestamp must be in the past, rounded to the minute and not older than earliestVersionTime. If specified, then the exported documents will represent a consistent view of the database at the provided time. Otherwise, there are no guarantees about the consistency of the exported documents.""
 ""Q: Firestore에서 사용자 자격 증명을 생성하는 CreateUserCredsRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id}/databases/{database_id} |\n| user_creds | UserCreds Required. The user creds to create. |\n| user_creds_id | string Required. The ID to use for the user creds, which will become the final component of the user creds's resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.""
 ""Q: Firestore에서 사용자 자격 증명을 생성하기 위한 CreateUserCredsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id}/databases/{database_id} |\n| user_creds | UserCreds Required. The user creds to create. |\n| user_creds_id | string Required. The ID to use for the user creds, which will become the final component of the user creds's resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. |""
 ""Q: Firestore에서 사용자 자격 증명을 생성할 때 필요한 CreateUserCredsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id}/databases/{database_id} |\n| user_creds | UserCreds Required. The user creds to create. |\n| user_creds_id | string Required. The ID to use for the user creds, which will become the final component of the user creds's resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.""
 'Q: Firestore에서 데이터베이스를 생성하는 CreateDatabaseRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition.'
 'Q: Firestore에서 데이터베이스를 생성할 때 필요한 CreateDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition.'
 'Q: FirestoreAdmin API에서 CreateDatabaseRequest의 필드에는 어떤 것들이 있나요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |'
 'Q: Firestore에서 데이터베이스 생성 요청을 위한 CreateDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |']",Cloud Firestore는 데이터베이스에 대한 트래픽을 지원하기 위해 자동으로 확장되므로 별도의 부하 분산기를 실행할 필요가 없습니다. Firestore는 시스템에서 수신한 부하에 따라 데이터를 동적으로 분할하고 결합하여 부하를 분산합니다. 따라서 사용자는 부하 분산을 위해 추가적인 설정을 할 필요가 없습니다.,Cloud Firestore는 데이터베이스에 대한 트래픽을 지원하기 위해 자동으로 확장되므로 부하 분산기를 실행할 필요가 없습니다.
범위 많으면 동의 어렵나요?,"['Cloud Firestore의 분할은 필요할 때 또는 키 공간이 확장될 때 더 많은 스토리지 서버에 트래픽을 제공하는 작업을 분산하기 위해 자동으로 더 작은 조각으로 분할됩니다. 초과 트래픽을 처리하기 위해 생성된 분할은 트래픽이 사라지더라도 약 24시간 동안 보관됩니다. 따라서 반복적으로 트래픽이 급증하면 분할이 유지되고 필요할 때마다 더 많은 분할이 도입됩니다.  이러한 메커니즘은 트래픽 부하 또는 데이터베이스 크기가 증가하면 Cloud Firestore 데이터베이스가 자동 확장되는 데 도움이 됩니다. 하지만 아래에 설명된 대로 주의해야 할 몇 가지 제한사항이 있습니다.\n\n스토리지와 부하를 분할하는 데 시간이 걸리는 데다가, 트래픽을 너무 빨리 늘리면 서비스가 조정되는 동안 지연 시간 증가 또는 기한 초과 오류(일반적으로 핫스팟이라고 함)가 발생할 수 있습니다. 그러므로 키 범위 전반에 작업을 분산하면서 초당 500개의 작업을 수행하는 데이터베이스의 컬렉션에서 트래픽을 늘리는 것이 좋습니다. 점진적으로 늘린 후에 5분마다 최대 50%씩 트래픽을 늘립니다. 이 프로세스를 500/50/5 규칙이라고 하며, 워크로드에 맞게 최적으로 확장되도록 데이터베이스를 배치합니다.\n핵심사항: 최적의 확장을 위해 500/50/5 규칙에 따라 트래픽을 늘려야 합니다.\n분할은 부하 증가에 따라 자동으로 생성되지만 Cloud Firestore에서는 전용 복제 스토리지 서버 집합을 사용하여 단일 문서를 제공할 때까지만 키 범위를 분할할 수 있습니다. 그 결과, 단일 문서에서 지속적으로 많은 양의 작업을 동시 실행하면 해당 문서에 핫스팟이 발생할 수 있습니다. 단일 문서에서 긴 지연 시간이 지속적으로 발생하는 경우 여러 문서에 걸쳐 데이터를 분할하거나 복제하도록 데이터 모델을 수정해야 합니다.'
 'Cloud Firestore는 비즈니스 요구사항을 충족하기 위해 자동 확장을 제공하는 고도로 분산된 시스템입니다. Cloud Firestore는 시스템에서 수신한 부하에 따라 데이터를 동적으로 분할하고 결합합니다.\n\n부하 기반 분할은 사전 구성 없이 자동으로 이루어집니다. Cloud Firestore 부하 기반 분할 시스템에는 데이터를 모델링할 때 유의해야 하는 다른 문서 데이터베이스와 비교되는 중요한 고유한 특징이 있습니다.\n\nCloud Firestore의 분산된 특성으로 인해 일부 설계 옵션을 변경해야 할 수 있습니다. 특히 기본 복제본이 쓰기 처리량의 병목 현상인 데이터베이스에 최적화된 워크로드의 경우 더욱 그렇습니다.\n\n권장사항\n\n단일 스레드 클라이언트에서 대량의 데이터를 처리하는 워크로드는 병목 현상을 일으킬 수 있습니다. 클라이언트와 서버의 처리량이 유사하게 일치하므로 클라이언트가 단일 스레딩을 사용하여 데이터를 일괄 로드할 수 있습니다.\nCloud Firestore 데이터베이스는 훨씬 더 많은 동시 로드를 처리할 수 있지만 클라이언트가 요청을 동시에 전송하도록 구성해야 합니다.\n\nmongoimport\n\nmongoimport 도구를 사용하면 기본적으로 요청이 순차적으로 이루어집니다.\nCloud Firestore로의 로드 시간을 개선하려면 --numInsertionWorkers 플래그를 사용하여 작업자 수를 설정하세요.\n올바른 설정은 클라이언트 크기에 따라 조정해야 할 수 있지만 일반적으로 최소 32로 시작하는 것이 좋습니다.\n\n비동기 프로그래밍\n\nMongoDB 호환 API를 사용하여 자체 소프트웨어를 개발할 때 다음과 같은 방법으로 동시 로드를 개선할 수 있습니다.\n\n비동기 프레임워크: 비동기 프레임워크를 사용하면 요청을 동시에 처리하고 응답할 수 있습니다. 데이터베이스를 호출할 때 복잡한 풀링이나 큐를 개발할 필요가 없습니다.\n각 요청 흐름은 독립적인 연결을 사용하고 데이터베이스 동시에 호출할 수 있습니다.\n병렬 컴퓨팅 제품 사용: Cloud Run과 같은 서비스를 사용하면 시스템에서 데이터를 처리하는 데 필요한 컴퓨팅 작업자 수를 확장할 수 있습니다.\n\n일시적인 실패\n\nCloud Firestore와 같은 대규모 분산 시스템으로 작업할 때는 네트워크 일시적 오류나 문서의 경합과 같은 일시적인 오류가 발생할 수 있습니다.'
 'require ""google/cloud/firestore""\n\nfirestore = Google::Cloud::Firestore.new project_id: project_id\n\nshards_ref = firestore.col_group collection_path\n\ncount = 0\nshards_ref.get do |doc_ref|\ncount += doc_ref[:count]\nend\n\nputs ""Count value is #{count}.""distributed_counters.rb [https://github.com/googleapis/google-cloud-ruby/blob/0539c9e4faccfe857c5cd0999d9f50f1a4404531/google-cloud-firestore/samples/distributed_counters.rb#L60-L74]\n\n제한사항\n\n위 솔루션은 Cloud Firestore에서 공유 카운터를 만드는 확장 가능한 방법이지만 다음과 같은 제한사항에 유의해야 합니다.\n\n샤드 수 - 샤드 수는 분산 카운터의 성능을 좌우합니다. 샤드가 너무 적으면 일부 트랜잭션을 재시도해야 하므로 쓰기 작업이 느려집니다. 샤드가 너무 많으면 읽기가 느려지고 비용이 증가합니다.  더 느린 주기로 업데이트되는 개별 롤업 문서에서 카운터 합계를 유지하고 클라이언트가 이 문서를 읽어 합계를 가져오도록 하면 읽기 비용을 상쇄할 수 있습니다. 하지만 이 경우 클라이언트가 업데이트 직후 모든 샤드를 읽어 합계를 계산하지 않고 롤업 문서가 업데이트될 때까지 기다려야 한다는 단점이 있습니다.\n비용 - 카운터 값을 읽을 때 전체 샤드 하위 컬렉션이 로드되어야 하므로 샤드 수에 따라 비용이 선형으로 증가합니다.\n\n의견 보내기'
 '스토리지와 부하를 분할하는 데 시간이 걸리는 데다가, 트래픽을 너무 빨리 늘리면 서비스가 조정되는 동안 지연 시간 증가 또는 기한 초과 오류(일반적으로 핫스팟이라고 함)가 발생할 수 있습니다. 그러므로 키 범위 전반에 작업을 분산하면서 초당 500개의 작업을 수행하는 데이터베이스의 컬렉션에서 트래픽을 늘리는 것이 좋습니다. 점진적으로 늘린 후에 5분마다 최대 50%씩 트래픽을 늘립니다. 이 프로세스를 500/50/5 규칙이라고 하며, 워크로드에 맞게 최적으로 확장되도록 데이터베이스를 배치합니다.\n핵심사항: 최적의 확장을 위해 500/50/5 규칙에 따라 트래픽을 늘려야 합니다.\n분할은 부하 증가에 따라 자동으로 생성되지만 Firestore에서는 전용 복제 스토리지 서버 집합을 사용하여 단일 문서를 제공할 때까지만 키 범위를 분할할 수 있습니다. 그 결과, 단일 문서에서 지속적으로 많은 양의 작업을 동시 실행하면 해당 문서에 핫스팟이 발생할 수 있습니다. 단일 문서에서 긴 지연 시간이 지속적으로 발생하는 경우 여러 문서에 걸쳐 데이터를 분할하거나 복제하도록 데이터 모델을 수정해야 합니다.'
 '순차적으로 색인이 지정된 필드의 쓰기 속도 제한은 Cloud Firestore에서 색인 값을 저장하고 색인 쓰기를 조정하는 방법에 좌우됩니다. Cloud Firestore는 색인 쓰기별로 문서 이름과 각 색인이 지정된 필드의 값을 연결하는 키-값 항목을 정의합니다. Cloud Firestore는 이러한 색인 항목을 태블릿이라는 데이터 그룹으로 정리합니다. Cloud Firestore 서버마다 태블릿이 한 개 이상 있습니다. 특정 태블릿에 대한 쓰기 부하가 너무 높아지면 Cloud Firestore는 태블릿을 더 작은 태블릿으로 분할하고 서로 다른 Cloud Firestore 서버에 새 태블릿을 분산하여 수평으로 확장합니다.\n\nCloud Firestore는 사전순으로 가까운 색인 항목을 동일한 태블릿에 배치합니다. timestamp 필드에서와 같이 태블릿의 색인 값들이 서로 너무 가까이에 있으면 Cloud Firestore에서 태블릿을 더 작은 태블릿으로 효율적으로 분할하지 못합니다. 이로 인해 단일 태블릿에서 너무 많은 트래픽을 수신하는 핫스팟이 생성되고 핫스팟에 대한 읽기 및 쓰기 작업 속도가 더 느려집니다.\n\ntimestamp 필드를 샤딩하면 Cloud Firestore에서 워크로드를 여러 태블릿에 효율적으로 분할할 수 있습니다. timestamp 필드의 값은 서로 가깝게 유지되더라도 연결된 샤드 및 색인 값 덕분에 Cloud Firestore의 색인 항목 간 공간이 충분히 넓기 때문에 여러 태블릿으로 항목을 분할할 수 있습니다.\n\n다음 단계\n\n규모 확장을 위한 설계 권장사항 [https://firebase.google.com/docs/firestore/best-practices?hl=ko#designing_for_scale] 읽기\n단일 문서에 대한 쓰기 속도가 높은 경우 분산 카운터 [https://firebase.google.com/docs/firestore/solutions/counters?hl=ko] 참조\nCloud Firestore의 표준 제한사항 [https://firebase.google.com/docs/firestore/quotas?hl=ko#limits] 참조\n\n도움이 되었나요?\n\n의견 보내기'
 'Cloud Firestore 작업, 스토리지, 네트워크 대역폭은 모두 사용량에 따라 청구되지만 추가 비용 없이 이용할 수 있는 다른 혜택도 많습니다. Cloud Firestore와 다른 데이터베이스 옵션을 비교할 때 무료로 제공되는 다음 서비스를 살펴보세요.\n\n직접 클라이언트 액세스: Cloud Firestore는 기본 SDK를 사용하여 클라이언트 코드에서 직접 액세스합니다. 즉, 모바일 클라이언트를 이 데이터베이스에 연결하기 위해 API 서버를 구축하고 실행할 필요가 없습니다.\n부하 분산: Cloud Firestore는 데이터베이스에 대한 트래픽을 지원하기 위해 자동으로 확장되므로 부하 분산기를 실행할 필요가 없습니다.\n서버 업타임: Cloud Firestore 데이터베이스는 Google Cloud 서버에서 작동하며, 월 99% 이상의 업타임 [https://cloud.google.com/firestore/sla?hl=ko]을 제공합니다.\n인증: Firebase Authentication [https://firebase.google.com/products/auth/?hl=ko]을 사용하여 사용자를 무제한으로 간단하고 안전하게 인증할 수 있습니다. Firebase Authentication은 Cloud Firestore와 직접 통합되므로 자체 인증 서비스를 실행할 필요가 없습니다.\n푸시 알림: Cloud Messaging [https://firebase.google.com/products/cloud-messaging/?hl=ko]으로 메시지와 알림을 보낼 수 있습니다.\n기타 Firebase 제품: A/B 테스팅, 애널리틱스, Crashlytics, Performance Monitoring, 원격 구성 등 다른 Firebase 제품을 무료로 통합하세요. 기타 Firebase 제품 [https://firebase.google.com/products/?hl=ko]과 Firebase 가격 책정 [https://firebase.google.com/pricing/?hl=ko]에 대해 자세히 알아보세요.\n\n도움이 되었나요?\n\n의견 보내기'
 'Source URL: https://cloud.google.com/firestore/docs/keyvis-patterns-index?hl=ko\nTitle: 색인 키의 히트맵 패턴\nbookmark_border\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\n\n의견 보내기\n\n이 페이지의 내용고르게 분산된 사용량 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#even-distribution]순차 키의 색인 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#indexes_on_sequential_keys]타임스탬프 증가로 인한 부하 집중 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#hotspotting_due_to_increasing_timestamp]필드 이름 증가로 인한 부하 집중 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#hotspotting_due_to_increasing_names]색인 키 구조 이해 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#understand_the_index_key_structure]히트맵의 색인 키 항목 예시 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#examples_of_index_key_entries_on_the_heatmap]다음 단계 [https://cloud.google.com/firestore/native/docs/keyvis-patterns-index?hl=ko#whats-next]\n\n색인 키의 히트맵 패턴\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.'
 'Source URL: https://cloud.google.com/firestore/docs/disaster-recovery?hl=ko\nTitle: 재해 복구 계획\nbookmark_border\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\n\n의견 보내기\n\n이 페이지의 내용클라우드 인프라 서비스 중단 시 재해 복구 계획 [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#disaster_recovery_planning_for_cloud_infrastructure_outages]데이터를 위한 재해 복구 계획 [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#disaster_recovery_planning_for_data]예약 백업 [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#scheduled_backups]PITR(point-in-time recovery) [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#point-in-time_recovery_pitr]다음 단계 [https://cloud.google.com/firestore/native/docs/disaster-recovery?hl=ko#whats_next]\n\n재해 복구 계획\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지에서는 재해 복구 계획을 만들고 구현하는 데 도움이 되는 Firestore 기능을 설명합니다.\n\n클라우드 인프라 서비스 중단 시 재해 복구 계획\n\n서비스 중단이 발생한 영역이나 리전과 같이 Google Cloud에서 잠재적인 클라우드 인프라 중단을 방지하기 위해 Firestore는 여러 복제본 데이터베이스에 데이터를 복제합니다.'
 '색인 키의 히트맵 패턴\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지에서는 Key Visualizer 히트맵에 표시될 수 있는 패턴 예시를 설명합니다. 이러한 패턴은 특정 성능 문제를 해결하는 데 도움이 될 수 있습니다.\n\n고르게 분산된 사용량\n\n히트맵에 밝고 어두운 색상이 고운 결로 혼합되어 표시되는 경우에는 데이터베이스 전반에서 색인 키의 쓰기/삭제 작업이 고르게 분산된 것입니다. 이 히트맵은 Firestore의 효과적인 사용 패턴을 나타냅니다.\n\n순차 키의 색인\n\n밝은 대각선 하나가 있는 히트맵은 타임스탬프와 같이 엄격하게 증가하거나 감소하는 키에 있는 색인을 나타낼 수 있습니다. 순차 키의 색인은 권장되지 않으며 핫스팟을 만들 수 있습니다. 부하 집중 시 해당하는 지연 시간이 길어질 수 있습니다.\n\n색인에 있는 일반적인 핫스팟의 예시는 다음과 같습니다.\n참고: Firestore의 경우 다음 히트맵 예시에서 히트맵의 x축은 시간을, y축은 색인 키를 나타냅니다.\n타임스탬프 증가로 인한 부하 집중\n\n이 예시에서 밝은 대각선 하나가 있는 히트맵은 타임스탬프 필드 이름에서 색인 쓰기/삭제 작업을 엄격하게 늘리거나 줄이는 데 사용하는 데이터베이스를 나타낼 수 있습니다.\n\n필드 이름 증가로 인한 부하 집중\n\n이 예시에서 밝은 대각선 하나가 있는 히트맵은 자동 생성된 인보이스 번호와 같이 증분 필드에서 색인 쓰기/삭제 작업을 엄격하게 늘리거나 줄이는 데 사용하는 데이터베이스를 나타낼 수 있습니다.\n\n부하 집중 문제를 식별하려면 Key Visualizer 도구를 사용하고 색인 키 구조를 이해 [https://cloud.google.com/firestore/docs/keyvis-patterns-index?hl=ko#understand_the_index_key_structure]하여 문제를 일으키는 색인을 결정하고 권장사항 [https://cloud.google.com/firestore/native/docs/best-practices?hl=ko#high_read_write_and_delete_rates_to_a_narrow_document_range]에 따라 이러한 색인을 제외합니다.\n\n색인 키 구조 이해'
 '클라우드 인프라 서비스 중단 시 재해 복구 계획\n\n서비스 중단이 발생한 영역이나 리전과 같이 Google Cloud에서 잠재적인 클라우드 인프라 중단을 방지하기 위해 Firestore는 여러 복제본 데이터베이스에 데이터를 복제합니다.\n\n복제 아키텍처는 데이터베이스가 리전 위치에 있는지 아니면 멀티 리전 위치에 있는지에 따라 달라집니다. 리전 데이터베이스는 3개 이상의 영역에 데이터를 동기식으로 복제합니다. 멀티 리전 데이터베이스는 3개 리전(2개의 제공 리전과 1개의 감시 리전)에서 5개의 영역에 데이터를 동기식으로 복제합니다. 멀티 리전 데이터베이스는 99.999%의 가용성을 제공하여 데이터베이스의 가용성과 내구성을 극대화합니다. 리전 데이터베이스는 99.99%의 가용성을 제공합니다.\n\nFirestore는 복제를 자동으로 처리하며 추가 구성이나 프로비저닝이 필요하지 않습니다. 자세한 내용은 다음을 참조하세요.\n\n복제 아키텍처에 대한 자세한 내용은 클라우드 인프라 중단을 위한 재해 복구 설계 [https://cloud.google.com/architecture/disaster-recovery?hl=ko#firestore]를 참조하세요.\n\n데이터를 위한 재해 복구 계획\n\n우발적인 데이터 삭제 또는 수정과 같은 데이터 재해로부터 보호하려면 예약된 백업 및 PITR(point-in-time recovery)을 사용합니다. 재해 복구 요구사항에 따라 두 기능을 함께 사용할 수 있습니다.\n\n예약 백업\n\n백업은 최대 14주 보관을 지원합니다. 일 혹은 주 단위로 백업을 예약할 수 있습니다. 백업에서 동일한 프로젝트의 새 Firestore 데이터베이스로 데이터베이스를 복원할 수 있습니다. 자세한 내용은 데이터 백업 및 복원 [https://cloud.google.com/firestore/native/docs/backups?hl=ko]을 참조하세요.\n\n백업은 PITR보다 보관 기간이 더 깁니다. 백업에서 데이터베이스를 복원하는 것은 PITR 데이터에서 데이터베이스를 복원하는 것보다 비용이 저렴합니다.\n\nPITR(point-in-time recovery)'
 'Source URL: https://firebase.google.com/docs/firestore/index.html?hl=ko\nTitle: Cloud Firestore\nbookmark_border\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\n이 페이지의 내용주요 기능 [https://firebase.google.com/docs/firestore/index.html?hl=ko#key_capabilities]기본 원리 [https://firebase.google.com/docs/firestore/index.html?hl=ko#how_does_it_work]구현 경로 [https://firebase.google.com/docs/firestore/index.html?hl=ko#implementation_path]다음 단계 [https://firebase.google.com/docs/firestore/index.html?hl=ko#next_steps]\n\nCloud Firestore\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nplat_ios\nplat_android\nplat_web\nplat_flutter\nplat_cpp\nplat_unity\nplat_node\nplat_java\nplat_python\nplat_go\n\nGoogle Cloud 인프라를 기반으로 하는 유연하고 확장 가능한 NoSQL 클라우드 데이터베이스를 사용해 클라이언트 측 개발 및 서버 측 개발에 사용되는 데이터를 저장하고 동기화하세요.'
 'Source URL: https://firebase.google.com/docs/firestore/quickstart?hl=ko\nTitle: Cloud Firestore 시작하기\nbookmark_border\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\nCloud Firestore 시작하기\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.'
 '많은 앱이 Cloud Firestore가 예방 조치 없이 수용할 수 있는 예측 가능한 유기적인 성장을 보입니다. 그러나 대규모 데이터 세트 가져오기와 같은 일괄 워크로드는 쓰기 작업을 너무 빠르게 늘릴 수 있습니다. 앱을 설계할 때는 쓰기 트래픽의 출처를 염두에 두어야 합니다.\n핵심 사항: Cloud Firestore는 자동으로 확장되지만 쓰기를 너무 빨리 늘리면 경합 및 성능 문제가 발생합니다. 쓰기 핫스팟이 생성되지 않도록 5-5-5 규칙 [https://firebase.google.com/docs/firestore/best-practices?hl=ko#ramping_up_traffic]을 따라야 합니다.\n쓰기와 읽기의 상호작용 방식 이해\n\n실시간 쿼리 시스템을 쓰기 작업을 리더와 연결하는 파이프라인이라고 볼 수 있습니다. 문서가 생성, 업데이트 또는 삭제될 때마다 변경사항이 스토리지 시스템에서 현재 등록된 리스너로 전파됩니다. Cloud Firestore의 변경 로그 구조는 strong consistency를 보장합니다. 즉, 앱이 데이터베이스가 데이터 변경사항을 커밋했을 때와 비교해 순서에 맞지 않는 업데이트 알림은 받지 않습니다. 이를 통해 데이터 일관성과 관련된 특이 사례를 제거하여 앱 개발을 간소화합니다.\n\n이 연결된 파이프라인은 핫스팟이나 잠금 경합을 유발하는 쓰기 작업이 읽기 작업에 부정적인 영향을 줄 수 있다는 것을 의미합니다.\n쓰기 작업이 실패하거나 제한이 있는 경우 변경 로그의 일관된 데이터를 기다리는 읽기 작업이 중단될 수 있습니다. 이 문제가 앱에서 발생하면 쓰기 작업과 쿼리에 대한 응답 속도가 모두 느려질 수 있습니다. 핫스팟을 피하는 것이 바로 이 문제를 해결하는 열쇠입니다.\n핵심사항: 쓰기와 스냅샷 리스너가 연결됩니다. 쓰기 작업에 문제가 있으면 응답 속도가 느려질 수 있습니다.\n문서 및 쓰기 작업을 작게 유지\n\n스냅샷 리스너로 앱을 빌드할 때는 일반적으로 사용자가 데이터 변경사항을 빠르게 파악하도록 하는 것이 좋습니다. 이렇게 하려면 작게 유지해보세요. 시스템은 수십 개의 필드가 있는 작은 문서를 시스템을 통해 신속하게 푸시할 수 있습니다. 수백 개의 필드와 대규모 데이터가 포함된 대용량 문서는 처리 시간이 더 오래 걸립니다.'
 'Source URL: https://firebase.google.com/docs/firestore?hl=ko\nTitle: Cloud Firestore\nbookmark_border\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\n이 페이지의 내용주요 기능 [https://firebase.google.com/docs/firestore?hl=ko#key_capabilities]기본 원리 [https://firebase.google.com/docs/firestore?hl=ko#how_does_it_work]구현 경로 [https://firebase.google.com/docs/firestore?hl=ko#implementation_path]다음 단계 [https://firebase.google.com/docs/firestore?hl=ko#next_steps]\n\nCloud Firestore\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nplat_ios\nplat_android\nplat_web\nplat_flutter\nplat_cpp\nplat_unity\nplat_node\nplat_java\nplat_python\nplat_go\n\nGoogle Cloud 인프라를 기반으로 하는 유연하고 확장 가능한 NoSQL 클라우드 데이터베이스를 사용해 클라이언트 측 개발 및 서버 측 개발에 사용되는 데이터를 저장하고 동기화하세요.\n\nCloud Firestore는 Firebase 및 Google Cloud의 모바일, 웹, 서버 개발에 사용되는 유연하고 확장 가능한 데이터베이스입니다. Firebase Realtime Database와 마찬가지로 실시간 리스너를 통해 클라이언트 애플리케이션 간에 데이터의 동기화를 유지하고 모바일 및 웹에 대한 오프라인 지원을 제공해 네트워크 지연 시간이나 인터넷 연결에 상관없이 원활하게 반응하는 앱을 개발할 수 있습니다. Cloud Firestore는 Cloud Functions를 비롯한 다른 Firebase 및 Google Cloud 제품과도 원활하게 통합됩니다.'
 "". We'll cover Cloud SQL, Spanner, Firestore, Bigtable, and more. Understand when to use each forYouTubeStop guessing! Choose the right Google Cloud databaseEnroll today! → https://goo.gle/4icxI12 Tired of database confusion? Learn to confidently select the right Google Cloud database for ANY application! This course breaks down Cloud SQL, AlloyDB, Spanner, Bigtable, Firestore, and Memorystore. Plus, getYouTube🧠 Problem: Too much data for embedding? 🤯🧩 Solution: Chunk your data! ✂️A core principal of RAG is to search through your data to use as an input for LLMs. You can embed the data into a vector so it is searchable, but if you have a large video or entire book that will be too much data in one embedding. Let's talk aboutYouTubeGenAI is a game changer for podcasts 💡🎧Gemini is revolutionizing how I learn from tech podcasts! It helps me pinpoint the exact discussions that align with my interests, so I can deep-dive into the topics that matter most""
 'C++\ndb->LoadBundle(""bundle_name"", [](const LoadBundleTaskProgress& progress) {\nswitch(progress.state()) {\ncase LoadBundleTaskProgress::State::kError: {\n// The bundle load has errored. Handle the error in the returned future.\nreturn;\n}\ncase LoadBundleTaskProgress::State::kInProgress: {\nstd::cout << ""Bytes loaded from bundle: "" << progress.bytes_loaded()\n<< std::endl;\nbreak;\n}\ncase LoadBundleTaskProgress::State::kSuccess: {\nstd::cout << ""Bundle load succeeeded"" << std::endl;\nbreak;\n}\n}\n}).OnCompletion([db](const Future<LoadBundleTaskProgress>& future) {\nif (future.error() != Error::kErrorOk) {\n// Handle error...\nreturn;\n}\n\nconst std::string& query_name = ""latest_stories_query"";\ndb->NamedQuery(query_name).OnCompletion([](const Future<Query>& query_future){\nif (query_future.error() != Error::kErrorOk) {\n// Handle error...\nreturn;\n}\n\nconst Query* query = query_future.result();\nquery->Get().OnCompletion([](const Future<QuerySnapshot> &){\n// ...\n});\n});\n});snippets.cpp [https://github.com/firebase/snippets-cpp/blob/778b6bcc8e8e8fcabb1c2e3a8d11ab51a26aa77b/firestore/android/FirestoreSnippetsCpp/app/src/main/cpp/snippets.cpp#L1215-L1249]'
 '| UpdateField |\n| --- |\n| rpc UpdateField(UpdateFieldRequest) returns (Operation) Updates a field configuration. Currently, field updates apply only to single field index configuration. However, calls to FirestoreAdmin.UpdateField should provide a field mask to avoid changing any configuration that the caller isn\'t aware of. The field mask should be specified as: { paths: ""index_config"" }. This call returns a google.longrunning.Operation which may be used to track the status of the field update. The metadata for the operation will be the type FieldOperationMetadata. To configure the default field settings for the database, use the special Field with resource name: projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*. Authorization scopes Requires one of the following OAuth scopes: https://www.googleapis.com/auth/datastore https://www.googleapis.com/auth/cloud-platform For more information, see the Authentication Overview. |\n\nBackup\n\nA Backup of a Cloud Firestore Database.The backup contains all documents and index configurations for the given database at a specific point in time.'
 '| UpdateField |\n| --- |\n| rpc UpdateField(UpdateFieldRequest) returns (Operation) Updates a field configuration. Currently, field updates apply only to single field index configuration. However, calls to FirestoreAdmin.UpdateField should provide a field mask to avoid changing any configuration that the caller isn\'t aware of. The field mask should be specified as: { paths: ""index_config"" }. This call returns a google.longrunning.Operation which may be used to track the status of the field update. The metadata for the operation will be the type FieldOperationMetadata. To configure the default field settings for the database, use the special Field with resource name: projects/{project_id}/databases/{database_id}/collectionGroups/__default__/fields/*. Authorization scopes Requires one of the following OAuth scopes: https://www.googleapis.com/auth/datastore https://www.googleapis.com/auth/cloud-platform For more information, see the OAuth 2.0 Overview. |\n\nBackup\n\nA Backup of a Cloud Firestore Database.The backup contains all documents and index configurations for the given database at a specific point in time.'
 ""| Fields |\n| --- |\n| collectionIds[] | string Which collection IDs to export. Unspecified means all collections. Each collection ID in this list must be unique. |\n| outputUriPrefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |\n| namespaceIds[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |""
 'Q: Cloud Firestore의 부하 분산 기능은 어떻게 작동하나요?\nA: Cloud Firestore는 데이터베이스에 대한 트래픽을 지원하기 위해 자동으로 확장되므로 부하 분산기를 실행할 필요가 없습니다.'
 'Q: Cloud Firestore에서 핫스팟을 방지하기 위해 문서 ID를 어떻게 설정해야 하나요?\nA: 부하 집중을 방지하려면 분산형 알고리즘을 사용하는 Cloud Firestore 자동 문서 ID를 활용하여 문서 ID를 사전순으로 분산하는 것이 좋습니다.'
 'Q: Cloud Firestore의 부하 기반 분할 시스템의 특징은 무엇인가요?\nA: Cloud Firestore는 시스템에서 수신한 부하에 따라 데이터를 동적으로 분할하고 결합합니다. 부하 기반 분할은 사전 구성 없이 자동으로 이루어집니다.'
 'Q: Cloud Firestore에서 자주 업데이트해야 하는 집계와 관련된 해결 방법은 무엇인가요?\nA: 더 자주 업데이트해야 하는 집계와 관련된 해결 방법은 분산 카운터 (distributed counter)를 참조하세요.'
 'Q: Cloud Firestore는 대규모 워크로드를 어떻게 처리하나요?\nA: Cloud Firestore는 대규모 워크로드를 처리하기 위해 여러 머신 또는 스토리지 서버에서 저장하고 제공할 수 있는 별도의 조각으로 데이터를 분할합니다. 이러한 파티션은 분할이라는 키 범위 블록의 데이터베이스 테이블에서 만들어집니다.'
 'Q: Key Visualizer 도구를 사용하여 부하 집중 문제를 어떻게 식별하나요?\nA: 부하 집중 문제를 식별하려면 Key Visualizer 도구를 사용하고 색인 키 구조를 이해하여 문제를 일으키는 색인을 결정하고 권장사항에 따라 이러한 색인을 제외합니다.'
 'Q: Firestore에서 인덱스를 삭제하는 요청은 어떻게 하나요?\nA: 인덱스를 삭제하기 위해서는 DeleteIndexRequest를 사용해야 합니다.'
 'Q: Firestore에서 데이터베이스를 복원하는 요청은 어떻게 하나요?\nA: 데이터베이스를 복원하기 위해서는 RestoreDatabaseRequest를 사용해야 합니다.'
 'Q: Firestore에서 데이터베이스를 복제할 때, 복제된 데이터베이스의 위치는 어떻게 설정하나요?\nA: 복제된 데이터베이스는 기존 데이터베이스와 동일한 클라우드 지역(cloud region) 또는 다중 지역(multi-region) 위치에 생성되어야 합니다.'
 'Q: Firestore에서 백업 스케줄을 업데이트하는 요청은 어떻게 하나요?\nA: 백업 스케줄을 업데이트하기 위해서는 UpdateBackupScheduleRequest를 사용해야 합니다.'
 'Q: Firestore에서 사용자 자격 증명을 비활성화하는 요청은 어떻게 하나요?\nA: 사용자 자격 증명을 비활성화하기 위해서는 DisableUserCredsRequest를 사용해야 합니다.'
 'Q: Firebase의 블로그에 접근하려면 어떤 링크를 사용해야 하나요?\nA: Firebase의 블로그에 접근하려면 [여기](https://firebase.googleblog.com/)를 사용해야 합니다.'
 'Q: Firebase 콘솔에 접근하려면 어떤 링크를 사용해야 하나요?\nA: Firebase 콘솔에 접근하려면 [여기](https://console.firebase.google.com/)를 사용해야 합니다.'
 'Q: 부하 집중 문제를 해결하기 위한 권장사항은 무엇인가요?\nA: 부하 집중 문제를 해결하기 위해서는 문제를 일으키는 색인을 결정하고 권장사항에 따라 이러한 색인을 제외해야 합니다.'
 'Q: Cloud Firestore에서 쿼리를 실행하려면 어떤 메서드를 사용해야 하나요?\nA: 쿼리를 실행하려면 `RunQuery` 메서드를 사용해야 합니다.'
 'Q: Cloud Firestore에서 트랜잭션을 시작하려면 어떤 메서드를 사용해야 하나요?\nA: 트랜잭션을 시작하려면 `BeginTransaction` 메서드를 사용해야 합니다.'
 'Q: Cloud Firestore에서 문서 업데이트를 위해 어떤 메서드를 사용해야 하나요?\nA: 문서를 업데이트하려면 `UpdateDocument` 메서드를 사용해야 합니다.'
 'Q: Google Cloud Firestore에서 documents를 export할 때, 어떤 HTTP 요청을 사용해야 하나요?\nA: POST https://firestore.googleapis.com/v1/{name=projects/*/databases/*}:exportDocuments를 사용해야 합니다.'
 'Q: long-running operation을 삭제하려면 어떤 메서드를 사용해야 하나요?\nA: long-running operation을 삭제하려면 `delete` 메서드(메서드: delete)를 사용해야 합니다.'
 'Q: Firestore에서 필드를 업데이트하는 요청은 어떻게 하나요?\nA: 필드를 업데이트하기 위해서는 `UpdateFieldRequest`를 사용해야 합니다. 이 요청은 특정 필드의 속성을 수정하는 데 사용됩니다.'
 'Q: Cloud Firestore에서 부하 집중 문제를 해결하기 위한 도구는 무엇인가요?\nA: Cloud Firestore는 사용 패턴을 분석하고 부하 집중 문제를 해결하기 위해 설계된 진단 도구로 Key Visualizer를 제공합니다.'
 'Q: Cloud Firestore에서 문서를 업데이트하거나 삽입하려면 어떤 메서드를 사용해야 하나요?\nA: 문서를 업데이트하거나 삽입하려면 `UpdateDocument` 메서드를 사용해야 합니다.'
 'Q: Firestore에서 벡터 저장소를 사용하려면 어떤 클래스를 사용해야 하나요?\nA: Firestore에서 벡터 저장소를 사용하려면 FirestoreVectorStore 클래스를 사용해야 합니다.'
 'Q: Cloud Firestore Enterprise 버전에서 MongoDB 호환성을 갖춘 클라이언트를 사용하기 위한 연결 요구사항은 무엇인가요?\nA: MongoDB 호환성을 갖춘 Cloud Firestore 클라이언트에는 다음이 필요합니다.\n\n- 드라이버는 load balanced 모드로 연결해야 합니다.\n- 드라이버는 SSL이 사용 설정된 상태로 연결해야 합니다.\n- 드라이버는 재시도 가능한 쓰기를 사용 중지해야 합니다. MongoDB 호환성을 갖춘 Cloud Firestore는 재시도 가능한 쓰기를 지원하지 않습니다. 재시도 가능한 읽기는 지원되므로 사용 중지할 필요가 없습니다.'
 'Q: Cloud Firestore에서 콘텐츠를 어떻게 저장하고 분류하나요?\nA: 내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요. Cloud Firestore 및 Firebase Extensions를 사용하여 AI 모델로 오디오 및 이미지 리소스의 가치를 최대한 활용하세요.'
 'Q: mongoimport 도구를 사용하여 Cloud Firestore에 데이터를 일괄 로드할 때, 요청의 순차적 처리 문제를 어떻게 해결할 수 있나요?\nA: Cloud Firestore로의 로드 시간을 개선하려면 --numInsertionWorkers 플래그를 사용하여 작업자 수를 설정하세요. 올바른 설정은 클라이언트 크기에 따라 조정해야 할 수 있지만 일반적으로 최소 32로 시작하는 것이 좋습니다.'
 'Q: google.rpc.Status의 필드에는 어떤 정보가 포함되나요?\nA: | Fields |\n| --- |\n| code | int32 The status code, which should be an enum value of google.rpc.Code. |\n| message | string A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client. |\n| details[] | Any A list of messages that carry the error details. There is a common set of message types for APIs to use. |'
 'Q: FirestoreAdmin API에서 CloneDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}. |'
 'Q: Firestore에서 데이터베이스를 복제하기 위한 CloneDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}. |'
 'Q: Firestore에서 데이터베이스 복제 요청의 CloneDatabaseRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}.'
 ""Q: FirestoreAdmin API에서 ImportDocumentsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to import. Unspecified means all collections included in the import. Each collection ID in this list must be unique. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |""
 ""Q: FirestoreAdmin API에서 ImportDocumentsRequest의 요청 구조는 어떻게 되나요?\nA: ImportDocumentsRequest의 요청 구조는 다음과 같습니다:\n\n| Fields |\n| --- |\n| name | string Required. Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to import. Unspecified means all collections included in the import. Each collection ID in this list must be unique. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique.""
 'Q: google.rpc.Status의 message 필드는 어떤 언어로 작성되어야 하나요?\nA: A developer-facing error message, which should be in English.'
 'Q: RestoreDatabaseMetadata에서 progressPercentage 필드는 어떤 정보를 제공하나요?\nA: progressPercentage | object (Progress) How far along the restore is as an estimated percentage of remaining time.'
 'Q: RestoreDatabaseMetadata의 progressPercentage 필드는 어떤 정보를 포함하나요?\nA: progressPercentage | object (Progress) How far along the restore is as an estimated percentage of remaining time.'
 ""Q: Firestore에서 CreateUserCredsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id}/databases/{database_id} |\n| user_creds | UserCreds Required. The user creds to create. |\n| user_creds_id | string Required. The ID to use for the user creds, which will become the final component of the user creds's resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. |""
 ""Q: FirestoreAdmin API에서 ExportDocumentsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to export. Unspecified means all collections. Each collection ID in this list must be unique. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |\n| snapshot_time | Timestamp The timestamp that corresponds to the version of the database to be exported. The timestamp must be in the past, rounded to the minute and not older than earliestVersionTime. If specified, then the exported documents will represent a consistent view of the database at the provided time. Otherwise, there are no guarantees about the consistency of the exported documents.""
 'Q: FirestoreAdmin API에서 RestoreDatabaseRequest의 database_id 필드는 어떤 규칙을 따라야 하나요?\nA: | Fields |\n| --- |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |'
 ""Q: FirestoreAdmin API에서 ExportDocumentsRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| name | string Required. Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to export. Unspecified means all collections. Each collection ID in this list must be unique. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |\n| snapshot_time | Timestamp The timestamp that corresponds to the version of the database to be exported. The timestamp must be in the past, rounded to the minute and not older than earliestVersionTime. If specified, then the exported documents will represent a consistent view of the database at the provided time. Otherwise, there are no guarantees about the consistency of the exported documents.""
 ""Q: Firestore에서 사용자 자격 증명을 생성하는 CreateUserCredsRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id}/databases/{database_id} |\n| user_creds | UserCreds Required. The user creds to create. |\n| user_creds_id | string Required. The ID to use for the user creds, which will become the final component of the user creds's resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.""
 ""Q: Firestore에서 사용자 자격 증명을 생성하기 위한 CreateUserCredsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id}/databases/{database_id} |\n| user_creds | UserCreds Required. The user creds to create. |\n| user_creds_id | string Required. The ID to use for the user creds, which will become the final component of the user creds's resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. |""
 ""Q: Firestore에서 사용자 자격 증명을 생성할 때 필요한 CreateUserCredsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id}/databases/{database_id} |\n| user_creds | UserCreds Required. The user creds to create. |\n| user_creds_id | string Required. The ID to use for the user creds, which will become the final component of the user creds's resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/.""
 'Q: Firestore에서 데이터베이스를 생성하는 CreateDatabaseRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition.'
 'Q: Firestore에서 데이터베이스를 생성할 때 필요한 CreateDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition.'
 'Q: FirestoreAdmin API에서 CreateDatabaseRequest의 필드에는 어떤 것들이 있나요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |'
 'Q: Firestore에서 데이터베이스 생성 요청을 위한 CreateDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |']","""범위가 많으면 동의가 어려운지""는 제가 모르는 내용입니다. 일상 질문 혹은 구글 API 관련 질문만 답변드릴 수 있어요.",요청된 범위 수가 많으면 사용자 동의를 얻을 가능성이 낮아질 수 있습니다.
"As a beginner who is not familiar with Google APIs, could you please explain in detail how the Cloud Platform is affected when Google Cloud session control features are enabled, and what specific user actions or applications are impacted by these policies?","['또한 사용자 계정 또는 서비스 계정이 모든 클라이언트에서 보유할 수 있는 총 새로고침 토큰 수에 대한 더 큰 제한도 있습니다. 일반적인 사용자는 이 한도를 초과하지 않지만 구현을 테스트하는 데 사용되는 개발자 계정은 초과할 수 있습니다.\n여러 프로그램, 머신 또는 기기를 승인해야 하는 경우 Google 계정당 승인하는 클라이언트 수를 15개 또는 20개로 제한하는 것이 한 가지 해결 방법입니다. Google Workspace 관리자 [https://support.google.com/a/answer/172176?hl=ko]인 경우 관리 권한이 있는 사용자를 추가로 만들어 일부 클라이언트를 승인할 수 있습니다.\nGoogle Cloud Platform (GCP) 조직의 세션 관리 정책 처리\nGCP 조직의 관리자는 Google Cloud 세션 제어 기능 [https://support.google.com/a/answer/9368756?hl=ko]을 사용하여 사용자가 GCP 리소스에 액세스하는 동안 사용자의 재인증을 자주 요구할 수 있습니다. 이 정책은 Google Cloud Console, Google Cloud SDK [https://cloud.google.com/sdk/gcloud?hl=ko] (gcloud CLI라고도 함), Cloud Platform 범위가 필요한 서드 파티 OAuth 애플리케이션에 대한 액세스에 영향을 미칩니다. 사용자에게 세션 제어 정책이 적용되어 있는 경우 세션 기간이 만료되면 갱신 토큰이 취소된 경우와 마찬가지로 API 호출에 오류가 발생합니다. 호출이 오류 유형 invalid_grant로 실패합니다. error_subtype 필드를 사용하여 취소된 토큰과 세션 제어 정책으로 인한 실패 (예: ""error_subtype"": ""invalid_rapt"")를 구분할 수 있습니다. 세션 기간이 매우 제한적일 수 있으므로 (1시간~24시간) 인증 세션을 다시 시작하여 이 시나리오를 원활하게 처리해야 합니다.\n마찬가지로 서버 간 배포에 사용자 인증 정보를 사용하거나 사용을 장려해서는 안 됩니다. 사용자 사용자 인증 정보가 장기 실행 작업 또는 작업을 위해 서버에 배포되고 고객이 이러한 사용자에게 세션 제어 정책을 적용하는 경우 세션 기간이 만료될 때 사용자를 다시 인증할 방법이 없으므로 서버 애플리케이션이 실패합니다.'
 '--- 탭: bq [https://cloud.google.com/bigquery/docs/control-access-to-resources-iam?hl=ko#bq] ---\nIn the Google Cloud console, activate Cloud Shell.\n    Activate Cloud Shell [https://console.cloud.google.com/?cloudshell=true&hl=ko]\n    \n      At the bottom of the Google Cloud console, a\n      Cloud Shell [https://cloud.google.com/shell/docs/how-cloud-shell-works?hl=ko]\n      session starts and displays a command-line prompt. Cloud Shell is a shell environment\n      with the Google Cloud CLI\n      already installed and with values already set for\n      your current project. It can take a few seconds for the session to initialize.\n    \n    \n  \n\n\n\n\n\n\n\n\n\n\n테이블 또는 뷰에 대한 액세스 권한을 부여하려면 bq add-iam-policy-binding 명령어 [https://cloud.google.com/bigquery/docs/reference/bq-cli-reference?hl=ko#bq_add-iam-policy-binding]를 사용합니다.\n\nbq add-iam-policy-binding --member=MEMBER_TYPE:MEMBER --role=ROLE\n  --table=true RESOURCE\n\n다음을 바꿉니다.\n\n\nMEMBER_TYPE: 구성원 유형(예: user, group, serviceAccount, domain)\nMEMBER: 회원의 이메일 주소 또는 도메인 이름\nROLE: 구성원에게 부여할 역할\nRESOURCE: 정책을 업데이트하려는 테이블 또는 뷰의 이름'
 '--- 탭: bq [https://cloud.google.com/bigquery/docs/control-access-to-resources-iam?hl=ko#bq] ---\nIn the Google Cloud console, activate Cloud Shell.\n    Activate Cloud Shell [https://console.cloud.google.com/?cloudshell=true&hl=ko]\n    \n      At the bottom of the Google Cloud console, a\n      Cloud Shell [https://cloud.google.com/shell/docs/how-cloud-shell-works?hl=ko]\n      session starts and displays a command-line prompt. Cloud Shell is a shell environment\n      with the Google Cloud CLI\n      already installed and with values already set for\n      your current project. It can take a few seconds for the session to initialize.\n    \n    \n  \n\n\n\n\n\n\n\n\n\n\n기존 루틴 정보(액세스 제어 포함)를 JSON 파일에 기록하려면 bq get-iam-policy 명령어 [https://cloud.google.com/bigquery/docs/reference/bq-cli-reference?hl=ko#bq_get-iam-policy]를 사용합니다.\n\nbq get-iam-policy --routine PROJECT_ID:DATASET.ROUTINE > PATH_TO_FILE\n\n다음을 바꿉니다.'
 '--- 탭: bq [https://cloud.google.com/bigquery/docs/control-access-to-resources-iam?hl=ko#bq] ---\nIn the Google Cloud console, activate Cloud Shell.\n    Activate Cloud Shell [https://console.cloud.google.com/?cloudshell=true&hl=ko]\n    \n      At the bottom of the Google Cloud console, a\n      Cloud Shell [https://cloud.google.com/shell/docs/how-cloud-shell-works?hl=ko]\n      session starts and displays a command-line prompt. Cloud Shell is a shell environment\n      with the Google Cloud CLI\n      already installed and with values already set for\n      your current project. It can take a few seconds for the session to initialize.\n    \n    \n  \n\n\n\n\n\n\n\n\n\n\n기존 루틴 정보(액세스 제어 포함)를 JSON 파일에 기록하려면 bq get-iam-policy 명령어 [https://cloud.google.com/bigquery/docs/reference/bq-cli-reference?hl=ko#bq_get-iam-policy]를 사용합니다.\n\nbq get-iam-policy \\\n    PROJECT_ID:DATASET.ROUTINE \\\n    > PATH_TO_FILE\n\n다음을 바꿉니다.\n\n\nPROJECT_ID: 프로젝트 ID\nDATASET: 업데이트하려는 루틴이 포함된 데이터 세트의 이름\nROUTINE: 업데이트할 리소스의 이름\nPATH_TO_FILE: 로컬 머신의 JSON 파일 경로'
 'BigQuery로 이동 [https://console.cloud.google.com/bigquery?hl=ko] \n탐색기 창에서 프로젝트를 확장하고 테이블 또는 뷰를 선택합니다.\nperson_add 공유를 클릭합니다.\n\n테이블 또는 뷰 액세스 정책이 공유 창에 나타납니다.\n\n--- 탭: bq [https://cloud.google.com/bigquery/docs/control-access-to-resources-iam?hl=ko#bq] ---\nIn the Google Cloud console, activate Cloud Shell.\n    Activate Cloud Shell [https://console.cloud.google.com/?cloudshell=true&hl=ko]\n    \n      At the bottom of the Google Cloud console, a\n      Cloud Shell [https://cloud.google.com/shell/docs/how-cloud-shell-works?hl=ko]\n      session starts and displays a command-line prompt. Cloud Shell is a shell environment\n      with the Google Cloud CLI\n      already installed and with values already set for\n      your current project. It can take a few seconds for the session to initialize.\n    \n    \n  \n\n\n\n\n\n\n\n\n\n\n기존 액세스 정책을 가져와서 JSON의 로컬 파일로 출력하려면 Cloud Shell에서 bq get-iam-policy 명령어 [https://cloud.google.com/bigquery/docs/reference/bq-cli-reference?hl=ko#bq_get-iam-policy]를 사용합니다.\n\nbq get-iam-policy \\\n    --table=true \\\n    PROJECT_ID:DATASET.RESOURCE > PATH_TO_FILE\n\n다음을 바꿉니다.\n\n\nPROJECT_ID: 프로젝트 ID\nDATASET: 데이터 세트의 이름\nRESOURCE: 정책을 보려는 테이블 또는 뷰의 이름\nPATH_TO_FILE: 로컬 머신의 JSON 파일 경로\n\n\n API'
 '확인되지 않은 요청 수: 오래된 클라이언트 요청일 수 있음 - 앱 체크 토큰이 누락된 요청입니다. 이러한 요청은 앱 체크 구현이 포함되지 않은 이전 버전의 앱에서 전송되었을 수 있습니다.\n확인되지 않은 요청 수: 알 수 없는 출처 요청 - 앱 체크 토큰이 없고 앱에서 전송된 것으로 보이지 않는 요청입니다.\n확인되지 않은 요청 수: 잘못된 요청 - 잘못된 앱 체크 토큰이 있는 요청이며, 앱을 가장하려고 시도하는 허위 클라이언트 또는 에뮬레이션된 환경에서 전송되었을 수 있습니다.\n이러한 측정항목을 검토하여 앱 체크 적용이 사용자에게 어떤 영향을 미치는지 알아보세요.\nApp Check를 적용하려면 적용 버튼을 클릭하고 선택한 내용을 확인합니다. 적용이 활성화되면 클라이언트의 확인되지 않은 모든 요청이 거부됩니다.\n참고: 적용을 사용 설정한 후 변경사항이 적용되기까지 최대 15분이 걸릴 수 있습니다.\niOS 클라이언트의 앱 체크 적용 해제\n앱에 앱 체크를 적용 해제하면 적용 [https://developers.google.com/identity/protocols/oauth2/native-app?hl=ko#enforce-app-check]이 중지되고 확인되지 않은 요청을 포함하여 클라이언트에서 Google OAuth 2.0 엔드포인트로 전송하는 모든 요청이 허용됩니다.\niOS 클라이언트의 앱 확인을 적용하지 않으려면 iOS 클라이언트의 수정 보기로 이동하여 적용 해제 버튼을 클릭하고 선택을 확인합니다.\n참고: 앱 확인을 적용 해제한 후 변경사항이 적용되기까지 최대 15분이 걸릴 수 있습니다.\niOS 클라이언트의 앱 체크 사용 중지\n앱의 앱 체크를 사용 중지하면 모든 앱 체크 모니터링 및 강제 시행 [https://developers.google.com/identity/protocols/oauth2/native-app?hl=ko#enforce-app-check]이 중지됩니다. 대신 앱 체크를 강제 적용하지 않음 [https://developers.google.com/identity/protocols/oauth2/native-app?hl=ko#unenforce-app-check]으로 설정하여 클라이언트의 측정항목을 계속 모니터링하는 것이 좋습니다.'
 ""지원되는 이벤트 유형 [https://developers.google.com/identity/protocols/risc?hl=ko#supported_event_types]\n앱에서 사용자가 Google을 사용하여 계정에 로그인할 수 있도록 하는 경우 교차 계정 보호 서비스에서 제공하는 보안 이벤트 알림을 수신하고 이에 응답하여 이러한 공유 사용자의 계정 보안을 개선할 수 있습니다.\n이러한 알림은 사용자의 Google 계정에 대한 주요 변경사항을 알려주며, 이는 앱의 계정에도 보안 영향을 미칠 수 있습니다. 예를 들어 사용자의 Google 계정이 도용되면 이메일 계정 복구 또는 싱글 사인온 사용을 통해 앱의 사용자 계정이 손상될 수 있습니다.\n이러한 이벤트의 위험 가능성을 완화할 수 있도록 Google에서는 보안 이벤트 토큰이라는 서비스 객체를 전송합니다. 이러한 토큰은 보안 이벤트의 유형과 발생 시간, 영향을 받는 사용자의 식별자 등 매우 적은 정보만 노출하지만 이를 사용하여 적절한 조치를 취할 수 있습니다. 예를 들어 사용자의 Google 계정이 도용된 경우 해당 사용자의'Google로 로그인'을 일시적으로 사용 중지하고 계정 복구 이메일이 사용자의 Gmail 주소로 전송되지 않도록 할 수 있습니다.\n계정 간 보안은 OpenID Foundation에서 개발한 RISC 표준 [https://openid.net/wg/sse/]을 기반으로 합니다.\n중요: 이 데이터는 Google API 서비스 약관 [https://developers.google.com/terms?hl=ko] 및 추가 RISC 서비스 약관 [https://console.cloud.google.com/tos?id=risc&hl=ko] ('RISC 약관')에 따라 제공됩니다. 이러한 신호는 보안, 사기 방지, 세션 관리 목적으로만 사용할 수 있습니다. RISC 약관을 검토하고 준수하세요. 그렇지 않으면 프로젝트 또는 계정이 정지될 수 있습니다.\n참고: 교차 계정 보호는 현재 Google Workspace (이전 명칭: G Suite) 사용자의 보안 이벤트를 전송하지 않습니다.\n개요\n앱 또는 서비스에서 계정 간 보안을 사용하려면 다음 작업을 완료해야 합니다.\nAPI Console에서 프로젝트를 설정합니다.""
 '자세한 내용은 기기용 OAuth 2.0 사용 [https://developers.google.com/identity/protocols/oauth2/limited-input-device?hl=ko]을 참고하세요.\n서비스 계정\nPrediction API 및 Google Cloud Storage와 같은 Google API는 사용자 정보에 액세스하지 않고도 애플리케이션을 대신하여 작동할 수 있습니다. 이러한 상황에서는 애플리케이션이 API에 자체 ID를 증명해야 하지만 사용자 동의는 필요하지 않습니다. 마찬가지로 엔터프라이즈 시나리오에서 애플리케이션은 일부 리소스에 대한 위임된 액세스를 요청할 수 있습니다.\n이러한 유형의 서버 간 상호작용에는 개별 최종 사용자가 아닌 애플리케이션에 속한 계정인 서비스 계정이 필요합니다. 애플리케이션이 서비스 계정을 대신하여 Google API를 호출하며 사용자 동의가 필요하지 않습니다. (서비스 계정이 아닌 시나리오에서는 애플리케이션이 최종 사용자를 대신하여 Google API를 호출하며, 사용자 동의가 필요한 경우가 있습니다.)\n참고: 이러한 서비스 계정 시나리오에서는 애플리케이션이 JSON 웹 토큰 (JWT)을 만들고 암호화 서명해야 합니다. 이러한 작업을 실행하는 라이브러리를 사용하는 것이 좋습니다. 토큰 생성 및 서명을 추상화하는 라이브러리를 사용하지 않고 이 코드를 작성하면 애플리케이션의 보안에 심각한 영향을 미치는 오류가 발생할 수 있습니다. 이 시나리오를 지원하는 라이브러리 목록은 서비스 계정 문서 [https://developers.google.com/identity/protocols/oauth2/service-account?hl=ko]를 참고하세요.\nGoogle API Console에서 획득하는 서비스 계정의 사용자 인증 정보에는 고유하게 생성된 이메일 주소, 클라이언트 ID, 하나 이상의 공개/비공개 키 쌍이 포함됩니다. 클라이언트 ID와 하나의 비공개 키를 사용하여 서명된 JWT를 만들고 적절한 형식으로 액세스 토큰 요청을 구성합니다. 그런 다음 애플리케이션에서 토큰 요청을 Google OAuth 2.0 승인 서버로 전송하면 액세스 토큰이 반환됩니다. 애플리케이션은 토큰을 사용하여 Google API에 액세스합니다. 토큰이 만료되면 애플리케이션에서 이 프로세스를 반복합니다.'
 ""이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nGoogle Identity [https://developers.google.com/identity?hl=ko]\n승인 [https://developers.google.com/identity/protocols/oauth2?hl=ko]\nGoogle Account Linking [https://developers.google.com/identity/account-linking?hl=ko]\n도움이 되었나요?\n의견 보내기\n개요\nbookmark_border\n이 페이지의 내용\n사용 사례 [https://developers.google.com/identity/account-linking?hl=ko#use_cases]\n지원되는 기능 [https://developers.google.com/identity/account-linking?hl=ko#supported_features]\n계정 연결 흐름 [https://developers.google.com/identity/account-linking?hl=ko#account_linking_flows]\nOAuth 연결 ('웹 OAuth') [https://developers.google.com/identity/account-linking?hl=ko#oauth_linking_web_oauth]\nOAuth 기반 앱 전환 연결 ('앱 전환') [https://developers.google.com/identity/account-linking?hl=ko#oauth-based_app_flip_linking_app_flip]\nOAuth 기반 간소화된 연결 ('간소화된') [https://developers.google.com/identity/account-linking?hl=ko#oauth-based_streamlined_linking_streamlined]\n어떤 흐름을 사용해야 하나요? [https://developers.google.com/identity/account-linking?hl=ko#which_flow_should_you_use]""
 'spec:\n  rules:\n  - enforce: true\nPROJECT_ID를 프로젝트 ID로 바꿉니다.\n정책을 적용합니다.\ngcloud org-policies set-policy ~/policy-dts-enable-email.yaml\n정책이 있는지 확인합니다.\ngcloud org-policies list --project=\nPROJECT_ID\n출력은 다음과 비슷합니다.\nCONSTRAINT                         LIST_POLICY  BOOLEAN_POLICY        ETAG\ncustom.dtsEnableEmailNotification  -            SET                   CPyxlbgGENDL3tEC-\n정책을 적용한 후 Google Cloud 가 정책 시행을 시작할 때까지 2분 정도 기다립니다.\n정책 테스트\n프로젝트에서 이메일 알림을 사용 중지한 BigQuery Data Transfer Service 전송 구성을 만들어 보세요.\n출력은 다음과 같습니다.\nOperation denied by custom org policy: [""customConstraints/custom.dtsEnableEmailNotification"": ""The BigQuery Data Transfer Service always enables email notications on data transfer failures.""].\n일반적인 사용 사례의 커스텀 조직 정책 예시\n다음 표에는 일반적인 사용 사례에 대한 몇 가지 커스텀 제약조건의 구문이 나와 있습니다.\n설명 제약조건 구문\nAzure Blob Storage에서 데이터 전송 허용 안함\n    name: organizations/\nORGANIZATION_ID/customConstraints/custom.denyDtsAzureTransfers\n    resourceTypes:\n    - bigquerydatatransfer.googleapis.com/TransferConfig\n    methodTypes:\n    - CREATE\n    condition: resource.dataSourceId == ""azure_blob_storage""\n    actionType: DENY\n    displayName: Deny data transfers from Azure Blob Storage to BigQuery'
 '지역 휴일 [https://support.google.com/googlecloud/answer/6047804?hl=ko]을 제외한 평일 1시간 평일 및 주말 1시간\n높은 수준의 영향 - 서비스에 심각한 문제가 있음\n일반 안정화 버전 [https://developers.google.com/maps/launch-stages?hl=ko]으로 표시된 Google Maps Platform 서비스에만 적용됩니다.\n프로덕션 환경에서 제품 또는 서비스의 성능이 저하되어 사용자가 겪는 오류가 눈에 띄게 증가합니다.\n비즈니스에 미치는 영향이 중간 수준입니다 (예: 수익 손실 위험 또는 생산성 저하).\n심각한 비즈니스 영향을 줄일 수 있는 해결 방법이 있으며 이를 빠르게 구현할 수 있습니다.\n평일 24시간 평일 및 주말 4시간\n중간 수준의 영향 - 서비스에 부분적인 문제가 있음\n문제의 범위 또는 심각도가 제한적입니다.\n사용자에게 눈에 띄는 영향을 주지 않습니다.\n불편함, 비즈니스 프로세스에 대한 사소한 영향 등 비즈니스에 약간의 영향이 있습니다.\n평일 24시간 평일 24시간\n낮은 수준의 영향 - 정상적으로 서비스 사용 가능\n업무적, 기술적 영향이 없거나 거의 없습니다.\n평일 24시간 평일 24시간\n개인 정보 보호 문의\n데이터 개인 정보 보호 및 보호 조치와 관련된 질문은 데이터 개인 정보 보호 문의 양식 [https://support.google.com/cloud/contact/maps_api_privacy?hl=ko]을 사용하여 Google에 문의할 수 있습니다.\n케이스 에스컬레이션\n참고: 케이스 에스컬레이션은 고급 지원 [https://developers.google.com/maps/documentation/datasets/support?hl=ko#enhanced] 구독자만 이용할 수 있습니다.\n케이스가 적절하게 처리되지 않고 있다고 생각되면 케이스를 에스컬레이션할 수 있습니다. 에스컬레이션 관리자가 케이스를 검토하여 제대로 처리되고 있는지 확인합니다. 참고: 에스컬레이션 관리자는 전문 지식을 추가로 제공하거나 비즈니스 요건에 따라 케이스 우선순위를 더욱 효과적으로 조정할 수 있지만 정책이나 서비스 약관에 예외를 부여할 수는 없습니다.'
 'Your project configuration in the Google Cloud Console Consent Screen page [https://console.developers.google.com/apis/credentials/consent] must match the list of scopes requested by your app. When a change in app functionality or in Google APIs necessitates an update to the scopes that are used, you must revoke [https://developers.google.com/identity/protocols/oauth2/web-server#tokenrevoke] the tokens with the previously-used scopes that are no longer in use at the earliest opportunity and update your project configuration in the Google Cloud Console. Proper configuration is particularly important for scopes that require verification [https://support.google.com/cloud/answer/9110914#sensitive-restricted-scopes]; if an app is no longer approved to use them, Google may revoke tokens that contain these scopes at any time without notice.'
 'Comply with all terms of service and policies\nThe use of Google API Services, which includes our implementation of OAuth 2.0, is governed by the Google APIs Terms of Service [https://developers.google.com/terms] and Google API Services User Data Policy [https://developers.google.com/terms/api-services-user-data-policy]. In addition, the use of OAuth 2.0 is governed by this policy. Please read these documents carefully, as well as any other terms or policies that apply to any other Google products or services you are using. Be sure to check for updates periodically as these documents are occasionally updated.\nRegister an appropriate OAuth client'
 'Some Google development platforms, such as Firebase and Actions on Google, automatically create Google Cloud projects and OAuth clients on your behalf. If you develop on these platforms, you are still subject to the policies on this page.\nUse separate projects for testing and production\nFor the purposes of these requirements, a ""production"" app meets the following criteria:\nIt isn\'t for personal use. An app is considered to be for personal use if it\'s not shared with anyone else or will be used by fewer than 100 people (all of whom are known personally to you).\nIt isn\'t used for development, testing, or staging.\nIt isn\'t for internal use; that is, restricted to people in your Google Workspace or Cloud Identity organization.\nSome policies and requirements only apply to production apps. For this reason, you must create separate projects in the Google Cloud Console [https://console.developers.google.com/] for each deployment tier, such as development, staging, and production.\nMaintain a list of relevant contacts for the project'
 'Last modified: May 17, 2021\nThe applications and services you design and build with Google APIs must do more than provide value to users and businesses. We also require that they be secure and provide the appropriate level of privacy demanded by users. The following policies are part of the Google APIs Terms of Service [https://developers.google.com/terms]. They apply to all developers who use OAuth 2.0, which includes OpenID Connect [https://developers.google.com/identity/protocols/oauth2/openid-connect] for authentication only. The policies below are a minimum set of requirements; we recommend that you take any additional steps necessary to ensure that your applications and systems are safe and secure.\nComply with all terms of service and policies'
 ""Handle user tokens securely\nOAuth 2.0 tokens are entrusted to you by users who give you permission to act and access data on their behalf. Never transmit tokens in plaintext, and always store encrypted tokens at rest to provide an extra layer of protection in the event of a data breach. Revoke tokens [https://developers.google.com/identity/protocols/oauth2/web-server#tokenrevoke] when you no longer need access to a user's account or when your app no longer needs access to permissions that a user previously granted. After the tokens are revoked, delete them permanently from your application or system.\nAccurately represent your identity\nProvide a valid name and (optionally) a logo to show to users. This brand information must accurately represent the identity of the application. App branding information is configured when you set up OAuth 2.0 in the Google Cloud Console Consent Screen page [https://console.developers.google.com/apis/credentials/consent].""
 'Q: Google Cloud 세션 제어 기능이란 무엇이며, 어떤 영향을 미치나요?\nA: Google Cloud 세션 제어 기능을 사용하여 사용자가 GCP 리소스에 액세스하는 동안 사용자의 재인증을 자주 요구할 수 있습니다. 이 정책은 Google Cloud Console, Google Cloud SDK (gcloud CLI라고도 함), Cloud Platform 범위가 필요한 서드 파티 OAuth 애플리케이션에 대한 액세스에 영향을 미칩니다.'
 'Q: Google Cloud 세션 제어 기능이란 무엇이며, 어떤 영향을 미치나요?\nA: GCP 조직의 관리자는 Google Cloud 세션 제어 기능을 사용하여 사용자가 GCP 리소스에 액세스하는 동안 사용자의 재인증을 자주 요구할 수 있습니다. 이 정책은 Google Cloud Console, Google Cloud SDK (gcloud CLI라고도 함), Cloud Platform 범위가 필요한 서드 파티 OAuth 애플리케이션에 대한 액세스에 영향을 미칩니다.'
 'Q: Google Cloud Platform에서 세션 관리 정책이 적용되면 API 호출에 어떤 오류가 발생하나요?\nA: 사용자에게 세션 제어 정책이 적용되어 있는 경우 세션 기간이 만료되면 갱신 토큰이 취소된 경우와 마찬가지로 API 호출에 오류가 발생합니다. 호출이 오류 유형 invalid_grant로 실패합니다.'
 'Q: Google Cloud Platform API에서 관리자가 설정한 세션 길이를 초과하면 어떤 오류가 발생하나요?\nA: Google Cloud Platform API의 경우 관리자가 설정한 세션 길이가 초과되면 API 호출에 오류가 발생합니다. 호출이 오류 유형 invalid_grant로 실패하며, error_subtype 필드를 사용하여 취소된 토큰과 세션 제어 정책으로 인한 실패를 구분할 수 있습니다.'
 'Q: 세션 제어 정책이 적용된 경우, 사용자 인증 정보를 서버에 배포하면 어떤 문제가 발생하나요?\nA: 사용자 인증 정보를 서버에 배포하면, 고객이 이러한 사용자에게 세션 제어 정책을 적용하는 경우 세션 기간이 만료될 때 사용자를 다시 인증할 방법이 없으므로 서버 애플리케이션이 실패하게 됩니다.'
 'Q: 세션 기간이 만료되었을 때 사용자 인증 정보를 서버에 배포하면 어떤 문제가 발생하나요?\nA: 사용자 사용자 인증 정보가 장기 실행 작업 또는 작업을 위해 서버에 배포되고 고객이 이러한 사용자에게 세션 제어 정책을 적용하는 경우 세션 기간이 만료될 때 사용자를 다시 인증할 방법이 없으므로 서버 애플리케이션이 실패합니다.'
 'Q: 서버 간 배포에 사용자 인증 정보를 사용하는 것에 대한 주의사항은 무엇인가요?\nA: 서버 간 배포에 사용자 인증 정보를 사용하거나 사용을 장려해서는 안 됩니다. 사용자 인증 정보가 장기 실행 작업 또는 작업을 위해 서버에 배포되고 고객이 이러한 사용자에게 세션 제어 정책을 적용하는 경우, 세션 기간이 만료될 때 사용자를 다시 인증할 방법이 없으므로 서버 애플리케이션이 실패합니다.'
 'Q: 기기에서 요청한 범위(scope)의 수와 사용자 동의 간의 관계는 무엇인가요?\nA: 기기에서 요청한 범위(scope)의 수가 많을수록 사용자 동의가 필요할 수 있습니다. 사용자가 승인 절차를 완료하기 위해 입력 기능이 더 풍부한 기기를 사용해야 하므로, 요청한 범위의 수는 사용자 동의에 영향을 미칩니다.'
 'Q: 서비스 계정(Service Account)이란 무엇이며, 어떤 상황에서 사용되나요?\nA: 서비스 계정은 개별 최종 사용자가 아닌 애플리케이션에 속한 계정으로, Prediction API 및 Google Cloud Storage와 같은 Google API는 사용자 정보에 액세스하지 않고도 애플리케이션을 대신하여 작동할 수 있습니다. 이러한 상황에서는 애플리케이션이 API에 자체 ID를 증명해야 하지만 사용자 동의는 필요하지 않습니다.'
 ""Q: 세션 기간이 만료되었을 때 API 호출에서 어떤 오류가 발생하나요?\nA: 세션 기간이 만료되면 API 호출에 오류가 발생하며, 오류 유형은 invalid_grant입니다. error_subtype 필드를 사용하여 취소된 토큰과 세션 제어 정책으로 인한 실패를 구분할 수 있습니다. 예를 들어, 'error_subtype': 'invalid_rapt'와 같은 형태로 구분됩니다.""
 'Q: 세션 제어 정책이 적용된 경우, 인증 세션을 다시 시작하는 방법은 무엇인가요?\nA: 세션 제어 정책이 적용된 경우, 세션 기간이 매우 제한적일 수 있으므로 (1시간~24시간) 인증 세션을 다시 시작하여 이 시나리오를 원활하게 처리해야 합니다.'
 'Q: 서비스 계정을 사용할 때 애플리케이션이 주의해야 할 보안 사항은 무엇인가요?\nA: 애플리케이션은 JSON 웹 토큰(JWT)을 만들고 암호화 서명해야 하며, 이를 위해 토큰 생성 및 서명을 추상화하는 라이브러리를 사용하는 것이 좋습니다. 이러한 라이브러리를 사용하지 않고 코드를 작성하면 애플리케이션의 보안에 심각한 영향을 미칠 수 있습니다.'
 'Q: disallowed_useragent 오류는 무엇을 의미하나요?\nA: disallowed_useragent 오류는 승인 엔드포인트가 Google의 OAuth 2.0 정책에 의해 허용되지 않는 삽입된 사용자 에이전트 내에 표시될 때 발생합니다.'
 'Q: 유지보수의 영향을 최소화하기 위한 권장사항은 무엇인가요?\nA: 유지보수의 영향을 최소화하기 위한 권장사항은 다음과 같습니다: 1) 기존 서비스를 유지하고 제한된 수의 요청을 새로 업데이트된 서비스로 라우트합니다. 2) 유지보수 기간 동안 토큰 요청 수를 줄입니다.'
 'Q: Google Cloud 데이터에 대한 읽기 전용 액세스를 위해 어떤 OAuth 2.0 범위를 사용해야 하나요?\nA: Google Cloud 서비스에서 데이터 조회 및 Google 계정의 이메일 주소 확인을 위해 다음의 OAuth 2.0 범위를 사용해야 합니다: `https://www.googleapis.com/auth/cloud-platform.read-only`.'
 'Q: OAuth 클라이언트 사용자 인증 정보를 안전하게 처리하기 위한 방법은 무엇인가요?\nA: OAuth 클라이언트 사용자 인증 정보는 앱의 ID를 식별하므로 신중하게 처리해야 합니다. Google Cloud Secret Manager와 같은 보안 비밀 관리자를 사용하여 이러한 사용자 인증 정보를 안전한 저장소에만 저장합니다. 사용자 인증 정보를 하드코딩하거나 코드 저장소에 커밋하거나 공개적으로 게시하지 마세요.'
 'Q: 유지보수의 영향을 최소화하기 위한 권장사항은 무엇인가요?\nA: 유지보수의 영향을 최소화할 수 있는 많은 솔루션이 있습니다. 고려할 수 있는 옵션은 다음과 같습니다.\n- 기존 서비스를 유지하고 제한된 수의 요청을 새로 업데이트된 서비스로 라우트합니다. 예상되는 기능을 확인한 후에만 모든 요청을 이전합니다.\n- 유지보수 기간 동안 토큰 요청 수를 줄입니다.\n- 유지보수 기간을 액세스 토큰 수명보다 짧게 제한합니다.'
 'Q: Google API 클라이언트 라이브러리를 사용하는 이유는 무엇인가요?\nA: Google API 클라이언트 라이브러리를 사용하면 애플리케이션 코드에서 암호화를 추상화하여 실수로 인해 애플리케이션의 보안에 심각한 영향을 미칠 수 있는 오류를 방지할 수 있습니다.'
 'Q: Google Cloud 데이터에 대한 읽기 전용 액세스를 위해 어떤 OAuth 2.0 범위를 사용해야 하나요?\nA: Google Cloud 데이터에 대한 읽기 전용 액세스를 위해 필요한 OAuth 2.0 범위는 다음과 같습니다:\n\n```\nhttps://www.googleapis.com/auth/cloud-platform.read-only\n```\n이 범위는 Google 계정의 이메일 주소도 확인합니다.'
 ""Q: OAuth 클라이언트 ID가 특정 Google Cloud 조직에 대한 액세스를 제한하는 경우 어떤 오류가 발생할 수 있나요?\nA: 요청의 OAuth 클라이언트 ID는 특정 Google Cloud 조직의 Google 계정에 대한 액세스를 제한하는 프로젝트에 속합니다. 이 경우 'org_internal' 오류가 발생할 수 있습니다.""
 ""Q: Google OAuth 2.0 승인 엔드포인트에 대한 요청에서 발생할 수 있는 'admin_policy_enforced' 오류는 무엇을 의미하나요?\nA: 이 오류는 Google Workspace 관리자의 정책으로 인해 Google 계정에서 요청된 하나 이상의 범위를 승인할 수 없음을 의미합니다. 관리자가 OAuth 클라이언트 ID에 대한 액세스 권한이 명시적으로 부여될 때까지 모든 범위 또는 민감하고 제한된 범위에 대한 액세스가 제한됩니다.""
 ""Q: Node.js에서 사용자가 부여한 범위를 확인하는 방법은 무엇인가요?\nA: // User authorized the request. Now, check which scopes were granted.\nif (tokens.scope.includes('https://www.googleapis.com/auth/drive.metadata.readonly'))\n{\n  // User authorized read-only Drive activity permission.\n  // Calling the APIs, etc.\n}\nelse\n{\n  // User didn't authorize read-only Drive activity permission.\n  // Update UX and application accordingly\n}\n\n// Check if user authorized Calendar read permission.\nif (tokens.scope.includes('https://www.googleapis.com/auth/calendar.readonly'))\n{\n  // User authorized Calendar read permission.\n  // Calling the APIs, etc.\n}\nelse\n{\n  // User didn't authorize Calendar read permission.\n  // Update UX and application accordingly\n}""
 'Q: Flask에서 API 요청을 테스트하는 페이지를 만드는 방법은 무엇인가요?\nA: Flask에서 API 요청을 테스트하는 페이지를 만들려면, 다음과 같은 코드를 사용할 수 있습니다:\n\n```python\ndef print_index_table():\n  return (\'<table>\' +\n          \'<tr><td><a href=""/test"">Test an API request</a></td>\' +\n          \'<td>Submit an API request and see a formatted JSON response. \' +\n          \'    Go through the authorization flow if there are no stored \' +\n          \'    credentials for the user.</td></tr>\' +\n          \'<tr><td><a href=""/authorize"">Test the auth flow directly</a></td>\' +\n          \'<td>Go directly to the authorization flow. If there are stored \' +\n          \'    credentials, you still might not be prompted to reauthorize \' +\n          \'    the application.</td></tr>\' +\n          \'<tr><td><a href=""/revoke"">Revoke current credentials</a></td>\' +\n          \'<td>Revoke the access token associated with the current user \' +\n          \'    session. After revoking credentials, if you go to the test \' +\n          \'    page, you should see an <code>invalid_grant</code> error.\' +\n          \'</td></tr>\' +\n          \'<tr><td><a href=""/clear"">Clear Flask session credentials</a></td>\' +\n          \'<td>Clear the access token currently stored in the user session. \' +\n          \'    After clearing the token, if you <a href=""/test"">test the \' +\n          \'    API request</a> again, you should go back to the auth flow.\' +\n          \'</td></tr></table>\')\n```'
 'Q: Cloud Runtime Configuration API에서 Google Cloud Platform 서비스의 런타임 구성을 관리하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Cloud Runtime Configuration API에서 Google Cloud Platform 서비스의 런타임 구성을 관리하기 위해 필요한 OAuth 2.0 범위는 `https://www.googleapis.com/auth/cloudruntimeconfig`입니다.'
 'Q: Ruby에서 Google API 클라이언트를 사용하여 OAuth 2.0 승인 요청의 매개변수를 설정하는 방법은 무엇인가요?\nA: 다음 코드는 승인 요청의 매개변수를 정의하는 Google\\Client() 객체를 만듭니다.\n\n```php\nuse Google\\Client;\n\n$client = new Client();\n\n// Required, call the setAuthConfig function to load authorization credentials from\n// client_secret.json file.\n$client->setAuthConfig(\'client_secret.json\');\n\n// Required, to set the scope value, call the addScope function\n$client->addScope([Google\\Service\\Drive::DRIVE_METADATA_READONLY, Google\\Service\\Calendar::CALENDAR_READONLY]);\n\n// Required, call the setRedirectUri function to specify a valid redirect URI for the\n// provided client_id\n$client->setRedirectUri(\'http://\' . $_SERVER[\'HTTP_HOST\'] . \'/oauth2callback.php\');\n\n// Recommended, offline access will give you both an access and refresh token so that\n// your app can refresh the access token without user interaction.\n$client->setAccessType(\'offline\');\n\n// Recommended, call the setState function. Using a state value can increase your assurance that\n// an incoming connection is the result of an authentication request.\n$client->setState($sample_passthrough_value);\n\n// Optional, if your application knows which user is trying to authenticate, it can use this\n// parameter to provide a hint to the Google Authentication Server.\n$client->setLoginHint(\'hint@example.com\');\n\n// Optional, call the setPrompt function to set ""consent"" will prompt the user for consent\n$client->setPrompt(\'consent\');\n\n// Optional, call the setIncludeGrantedScopes function with true to enable incremental\n// authorization\n$client->setIncludeGrantedScopes(true);\n```'
 ""Q: Node.js에서 OAuth 2.0 인증 흐름을 시작하는 방법은 무엇인가요?\nA: 다음은 Node.js에서 OAuth 2.0 인증 흐름을 시작하는 예시입니다.\n\n```javascript\n// Example on redirecting user to Google's OAuth 2.0 server.\napp.get('/', async (req, res) => {\n  // Generate a secure random state value.\n  const state = crypto.randomBytes(32).toString('hex');\n  // Store state in the session\n  req.session.state = state;\n\n  // Generate a url that asks permissions for the Drive activity and Google Calendar scope\n  const authorizationUrl = oauth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: scopes,\n    include_granted_scopes: true,\n    state: state\n  });\n\n  res.redirect(authorizationUrl);\n});\n```""
 ""Q: Google Cloud Platform 프로젝트에서 외부 사용자 유형으로 구성된 OAuth 동의 화면이 '테스트' 상태일 때 갱신 토큰의 만료 기간은 어떻게 되나요?\nA: 외부 사용자 유형으로 구성되고 게시 상태가 '테스트'인 OAuth 동의 화면이 있는 Google Cloud Platform 프로젝트에는 요청된 OAuth 범위가 이름, 이메일 주소, 사용자 프로필 (userinfo.email, userinfo.profile, openid) 범위를 통해 또는 OpenID Connect 동등 항목을 통해의 하위 집합인 경우를 제외하고 7일 후에 만료되는 갱신 토큰이 발급됩니다.""
 ""Q: Flask에서 사용자가 Google Calendar API에 대한 권한을 부여했는지 확인하는 방법은 무엇인가요?\nA: 사용자가 Google Calendar API에 대한 권한을 부여했는지 확인하려면, 다음과 같은 코드를 사용할 수 있습니다:\n\n```python\n@app.route('/calendar')\ndef calendar_api_request():\n  if 'credentials' not in flask.session:\n    return flask.redirect('authorize')\n\n  features = flask.session['features']\n\n  if features['calendar']:\n    return ('<p>User granted the Google Calendar read permission.</p>')\n  else:\n    return '<p>Calendar feature is not enabled.</p>'\n```""
 ""Q: Ruby에서 사용자가 부여한 범위를 확인하는 방법은 무엇인가요?\nA: # User authorized the request. Now, check which scopes were granted.\nif credentials.scope.include?(Google::Apis::DriveV3::AUTH_DRIVE_METADATA_READONLY)\n  # User authorized read-only Drive activity permission.\n  # Calling the APIs, etc\nelse\n  # User didn't authorize read-only Drive activity permission.\n  # Update UX and application accordingly\nend\n\n# Check if user authorized Calendar read permission.\nif credentials.scope.include?(Google::Apis::CalendarV3::AUTH_CALENDAR_READONLY)\n  # User authorized Calendar read permission.\n  # Calling the APIs, etc.\nelse\n  # User didn't authorize Calendar read permission.\n  # Update UX and application accordingly\nend""
 'Q: Cloud Resource Manager API에서 Google Cloud 서비스에서 데이터 조회를 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Cloud Resource Manager API에서 Google Cloud 서비스에서 데이터 조회를 위해 필요한 OAuth 2.0 범위는 `https://www.googleapis.com/auth/cloud-platform.read-only`입니다.'
 ""Q: Google API를 호출하는 애플리케이션에서 API를 사용 설정하려면 어떤 단계를 따라야 하나요?\nA: 프로젝트에서 API를 사용 설정하려면 다음 단계를 따르세요.\n1. Google API Console에서 Open the API Library을 사용합니다.\n2. If prompted, select a project, or create a new one.\n3. API Library에는 사용 가능한 모든 API가 제품군과 인기도를 기준으로 분류되어 있습니다. 사용 설정하려는 API가 목록에 없는 경우 검색을 사용하여 찾거나 속한 제품군에서 모두 보기를 클릭합니다.\n4. 사용 설정하려는 API를 선택한 다음 사용 설정 버튼을 클릭합니다.\n5. If prompted, enable billing.\n6. If prompted, read and accept the API's Terms of Service.""
 'Q: Cloud Functions API를 사용하여 Google Cloud 데이터에 대한 확인, 수정, 구성 및 삭제를 수행하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Cloud Functions API를 사용하여 Google Cloud 데이터에 대한 확인, 수정, 구성 및 삭제를 수행하기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/cloud-platform 입니다.'
 'Q: Cloud Data Fusion API를 사용하여 Google Cloud 데이터를 확인하고 수정하기 위한 OAuth 2.0 범위는 무엇인가요?\nA: Google Cloud 데이터를 확인하고 수정하기 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n```\nhttps://www.googleapis.com/auth/cloud-platform\n```'
 'Q: Cloud Functions API를 통해 Google Cloud 데이터에 대한 확인, 수정, 구성 및 삭제를 수행하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Cloud Functions API를 통해 Google Cloud 데이터에 대한 확인, 수정, 구성 및 삭제를 수행하기 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n\n```\nhttps://www.googleapis.com/auth/cloud-platform\n```'
 ""Q: Google API를 호출하는 애플리케이션에서 API를 사용 설정하려면 어떤 단계를 따라야 하나요?\nA: Google API를 호출하는 애플리케이션은 API Console에서 해당 API를 사용 설정해야 합니다. 프로젝트에서 API를 사용 설정하려면 다음 단계를 따르세요.\n1. Google API Console에서 Open the API Library을 사용합니다.\n2. If prompted, select a project, or create a new one.\n3. API Library에는 사용 가능한 모든 API가 제품군과 인기도를 기준으로 분류되어 있습니다. 사용 설정하려는 API가 목록에 없는 경우 검색을 사용하여 찾거나 속한 제품군에서 모두 보기를 클릭합니다.\n4. 사용 설정하려는 API를 선택한 다음 사용 설정 버튼을 클릭합니다.\n5. If prompted, enable billing.\n6. If prompted, read and accept the API's Terms of Service.""
 'Q: Cloud Identity-Aware Proxy API를 사용하여 Google Cloud 데이터에 대한 확인, 수정, 구성 및 삭제를 수행하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Cloud Identity-Aware Proxy API를 사용하여 Google Cloud 데이터에 대한 확인, 수정, 구성 및 삭제를 수행하기 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n\n```\nhttps://www.googleapis.com/auth/cloud-platform\n```'
 'Q: Cloud Run Admin API에서 Google Cloud 데이터 확인, 수정, 구성 및 삭제를 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Google Cloud 데이터 확인, 수정, 구성 및 삭제를 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n```\nhttps://www.googleapis.com/auth/cloud-platform\n```']","When Google Cloud session control features are enabled, they can require users to frequently re-authenticate while accessing Google Cloud Platform (GCP) resources. This policy impacts access to the Google Cloud Console, Google Cloud SDK (also known as gcloud CLI), and third-party OAuth applications that require Cloud Platform scopes.

If a session control policy is applied, and the session duration expires, API calls will fail with an error type of `invalid_grant`. The `error_subtype` field can be used to distinguish between failures due to revoked tokens and those due to session control policies, such as `""error_subtype"": ""invalid_rapt""`.

Additionally, if user credentials are deployed on a server for long-running tasks, and session control policies are applied, the server application may fail when the session expires, as there would be no way to re-authenticate the user. Therefore, it is advised not to use or encourage the use of user credentials for server-to-server deployments.","When Google Cloud session control features are enabled, administrators in a GCP organization can require users to re-authenticate more frequently while accessing GCP resources. This policy affects access to the Google Cloud Console, the Google Cloud SDK (also known as gcloud CLI), and third-party OAuth applications that require Cloud Platform scopes."
"firebase_functions 어떻게 쓰는지 잘 모르겠는데, Cloud Firestore에서 문서 바뀔 때마다 자동으로 뭔가 실행되게 하려면 firebase_functions에서 뭘 써야 되고, 예시 코드도 보여줄 수 있나요?","['Cloud Functions로 Firestore 확장\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nCloud Functions를 사용하면 Firestore 데이터베이스를 변경하여 트리거되는 이벤트를 처리하는 Node.js 코드를 배포할 수 있습니다. 덕분에 자체 서버를 실행하지 않고도 앱에 서버 측 기능을 쉽게 추가할 수 있습니다.\n참고: 이 페이지의 예시는 Firebase용 Cloud Functions [https://firebase.google.com/docs/functions/?hl=ko]를 사용하며 Google Cloud용 Cloud Functions와 약간 다릅니다 [https://cloud.google.com/functions/docs/concepts/functions-and-firebase?hl=ko].\n사용 사례의 예시를 보려면 Cloud Functions로 무엇을 할 수 있나요? [https://firebase.google.com/docs/functions/use-cases?hl=ko] 또는 함수 샘플 [https://github.com/firebase/functions-samples] GitHub 저장소를 참조하세요.\n\nFirestore 함수 트리거\n\nFirebase용 Cloud Functions SDK는 특정 Firestore 이벤트에 연결된 핸들러를 만들 수 있는 functions.firestore [https://firebase.google.com/docs/reference/functions/firebase-functions.firestore?hl=ko] 객체를 내보냅니다.'
 '문서의 모든 변경사항에 대해 함수 트리거\n\n실행되는 이벤트 유형에 관계없이 Cloud Firestore 문서의 모든 변경사항을 리슨하려면 \'작성된 문서\' 이벤트 트리거를 사용합니다. 다음은 사용자가 생성, 업데이트 또는 삭제될 때 실행되는 함수의 예시입니다.\n\nNode.jsconst {\nonDocumentWritten,\nChange,\nFirestoreEvent\n} = require(\'firebase-functions/v2/firestore\');\n\nexports.modifyuser = onDocumentWritten(""users/{userId}"", (event) => {\n// Get an object with the current document values.\n// If the document does not exist, it was deleted\nconst document =  event.data.after.data();\n\n// Get an object with the previous document values\nconst previousValues =  event.data.before.data();\n\n// perform more operations ...\n});\n\n추가 인증 정보의 경우 onDocumentWrittenWithAuthContext를 사용하세요.\nPythonfrom firebase_functions.firestore_fn import (\non_document_written,\nEvent,\nChange,\nDocumentSnapshot,\n)\n\n@on_document_written(document=""users/{userId}"")\ndef myfunction(event: Event[Change[DocumentSnapshot | None]]) -> None:\n# Get an object with the current document values.\n# If the document does not exist, it was deleted.\ndocument = (event.data.after.to_dict()\nif event.data.after is not None else None)'
 'Cloud Firestore 함수 트리거\n\nCloud Functions for Firebase SDK는 특정 Cloud Firestore 이벤트에 연결된 핸들러를 생성할 수 있도록 다음 Cloud Firestore 이벤트 트리거를 내보냅니다.\n\nNode.js|  |  |\n| --- | --- |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\nPython|  |  |\n| --- | --- |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n|  |  |\n\nCloud Firestore 이벤트는 문서 변경 시에만 트리거됩니다. 데이터가 변경되지 않는 Cloud Firestore 문서를 업데이트(노옵스(no-ops) 쓰기)할 때에는 업데이트 또는 쓰기 이벤트가 생성되지 않습니다. 특정 필드에 이벤트를 추가할 수 없습니다.\n\nCloud Functions for Firebase가 사용 설정된 프로젝트가 없으면 Cloud Functions for Firebase(2세대) 시작하기 [https://firebase.google.com/docs/functions/beta/get-started?hl=ko]를 읽고 Cloud Functions for Firebase 프로젝트를 구성 및 설정하세요.\n\nCloud Firestore 트리거 함수 작성\n\n함수 트리거 정의\n\nCloud Firestore 트리거를 정의하려면 문서 경로와 이벤트 유형을 지정합니다.\n\nNode.jsconst {\nonDocumentWritten,\nonDocumentCreated,\nonDocumentUpdated,\nonDocumentDeleted,\nChange,\nFirestoreEvent\n} = require(\'firebase-functions/v2/firestore\');\n\nexports.myfunction = onDocumentWritten(""my-collection/{docId}"", (event) => {\n/* ... */\n});\n\nPythonfrom firebase_functions.firestore_fn import (\non_document_created,\non_document_deleted,\non_document_updated,\non_document_written,\nEvent,\nChange,\nDocumentSnapshot,\n)'
 'Source URL: https://cloud.google.com/firestore/docs/manage-data/add-data?hl=ko\nTitle: 데이터 추가 및 업데이트\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\n\n의견 보내기\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n데이터 추가 및 업데이트\n\n이 문서에서는 Firestore에서 개별 문서를 설정, 추가 또는 업데이트하는 방법을 설명합니다. 데이터를 일괄 쓰기하려면 트랜잭션 및 일괄 쓰기 [https://cloud.google.com/firestore/native/docs/manage-data/transactions?hl=ko]를 참고하세요.\n\n개요\n\n다음 방법 중 하나로 Firestore에 데이터를 쓸 수 있습니다.\n\n문서 식별자를 명시적으로 지정하여 컬렉션 내의 문서 데이터를 설정합니다.\n컬렉션에 새 문서를 추가합니다. 이 경우 Firestore에서 자동으로 문서 식별자를 생성합니다.\n자동으로 생성된 식별자로 빈 문서를 만들고 나중에 데이터를 할당합니다.\n\n참고: 코드 샘플에서는 여러 언어를 다루지만 샘플을 설명하는 텍스트는 웹 메서드 이름을 참조합니다.시작하기 전에\n\n데이터를 설정, 추가 또는 업데이트하도록 Firestore를 초기화하려면 다음 단계를 완료해야 합니다.'
 ""Cloud Functions는 프로젝트의 서비스 계정으로 승인되기 때문에 신뢰할 수 있는 환경에서 실행됩니다. Firebase Admin SDK [https://firebase.google.com/docs/reference/admin?hl=ko]를 사용해 읽기 및 쓰기를 수행할 수 있습니다.\n\n--- 탭: Node.js [https://cloud.google.com/firestore/native/docs/extend-with-functions?hl=ko#node.js] ---\n```\nconst admin = require('firebase-admin');\nadmin.initializeApp();\n\nconst db = admin.firestore();\n\nexports.writeToFirestore = functions.firestore\n.document('some/doc')\n.onWrite((change, context) => {\ndb.doc('some/otherdoc').set({ ... });\n});\n```참고: Cloud Functions에서 수행되는 읽기 및 쓰기는 보안 규칙으로 제어되지 않으며 데이터베이스의 모든 부분에 액세스할 수 있습니다.\n제한사항\n\nCloud Run Functions용 Firestore 트리거의 다음 제한사항에 유의하세요.""
 'Source URL: https://firebase.google.com/docs/firestore/extend-with-functions?hl=ko\nTitle: Cloud Functions로 Cloud Firestore 확장\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\nCloud Functions로 Cloud Firestore 확장\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nCloud Functions를 사용하면 Node.js 코드를 배포하여 Cloud Firestore 데이터베이스의 변경을 통해 트리거되는 이벤트를 처리할 수 있습니다. 덕분에 자체 서버를 실행하지 않고도 앱에 서버 측 기능을 쉽게 추가할 수 있습니다.\n\n사용 사례의 예시를 보려면 Cloud Functions로 무엇을 할 수 있나요? [https://firebase.google.com/docs/functions/use-cases?hl=ko]를 참조하세요. 또는 Firebase Functions 샘플 [https://github.com/firebase/functions-samples] GitHub 저장소를 참조하세요.\n\nCloud Firestore 함수 트리거\n\nCloud Functions for Firebase SDK는 특정 Cloud Firestore 이벤트에 연결된 핸들러를 만들 수 있는 functions.firestore [https://firebase.google.com/docs/reference/functions/firebase-functions.firestore?hl=ko] 객체를 내보냅니다.'
 '예제 및 사용 사례\n\n다음은 구체적인 Firebase 사용 사례에서 커스텀 클레임을 어떻게 사용하는지\n보여주는 예입니다.\n\n사용자 생성 시 Firebase 함수를 통한 역할 정의\n\n이 예시에서는 사용자를 생성할 때 Cloud Functions를 사용하여 커스텀 클레임을 설정합니다.\n\nCloud Functions를 사용하여 커스텀 클레임을 추가하고 Realtime Database로 커스텀 클레임을 즉시 전파할 수 있습니다. 이 함수는 가입 시에만 onCreate 트리거를 사용하여 호출됩니다. 커스텀 클레임이 설정되면 모든 기존 세션과 이후 세션에 커스텀 클레임이 전파됩니다. 다음 번에 사용자 인증 정보로 사용자가 로그인하면 토큰에\n커스텀 클레임이 포함됩니다.\n\n클라이언트 측 구현(자바스크립트)\nconst provider = new firebase.auth.GoogleAuthProvider();\nfirebase.auth().signInWithPopup(provider)\n.catch(error => {\nconsole.log(error);\n});'
 'Cloud Run Functions를 사용하여 이벤트 트리거로 Cloud Run 확장\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nCloud Run 함수를 사용하면 Cloud Run 데이터베이스의 변경으로 트리거되는 이벤트를 처리하는 코드를 배포할 수 있습니다. 이렇게 하면 자체 서버를 실행하지 않고도 서버 측 기능을 추가할 수 있습니다.\n참고: 이 기능은 Firebase용 Cloud Functions(2세대)를 통해서도 사용할 수 있습니다. Firebase SDK를 사용하는 예시를 보려면 Firebase용 Cloud Functions (2세대)로 Cloud Run 확장 [https://firebase.google.com/docs/firestore/extend-with-functions-2nd-gen?hl=ko]을 참고하세요.\n\n이 가이드에서는 Firestore 이벤트에서 Cloud Run 함수의 트리거를 만드는 방법을 설명합니다.\n\nFirestore 데이터베이스의 이벤트에서 Cloud Run 함수를 트리거할 수 있습니다. 트리거되면 함수는 Firestore API 및 클라이언트 라이브러리 [https://cloud.google.com/firestore/docs/apis?hl=ko]를 통해 이러한 이벤트에 대한 응답으로 Firestore 데이터베이스를 읽고 업데이트합니다.\n\nFirestore 이벤트가 Cloud Run 함수를 트리거하는 프로세스는 다음 단계로 구성됩니다.\n\n서비스는 특정 문서가 변경될 때까지 기다립니다.\n변경되면 서비스가 트리거되어 태스크를 수행합니다.\n서비스는 영향을 받는 문서의 스냅샷이 있는 데이터 객체를 수신합니다.\nwrite 또는 update 이벤트의 경우 데이터 객체에는 이벤트 트리거 전후의 문서 상태를 나타내는 스냅샷이 포함됩니다.\n\n시작하기 전에\n\n설정 [https://cloud.google.com/run/docs/setup?hl=ko] 페이지에 설명된 대로 Cloud Run용 새 프로젝트를 설정했는지 확인합니다.\nArtifact Registry, Cloud Build, Cloud Run Admin API, Eventarc, Firestore Cloud Logging, Pub/Sub API를 사용 설정합니다.'
 'Source URL: https://firebase.google.com/docs/auth/extend-with-functions?hl=ko\nTitle: Cloud Functions로 Firebase 인증 확장\nbookmark_border\n\n의견 보내기\n\nCloud Functions로 Firebase 인증 확장\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지의 내용사용자 생성 시 함수 트리거 [https://firebase.google.com/docs/auth/extend-with-functions?hl=ko#trigger_a_function_on_user_creation]사용자 속성에 액세스 [https://firebase.google.com/docs/auth/extend-with-functions?hl=ko#access_user_attributes]사용자 삭제 시 함수 트리거 [https://firebase.google.com/docs/auth/extend-with-functions?hl=ko#trigger_a_function_on_user_deletion]차단 함수 트리거 [https://firebase.google.com/docs/auth/extend-with-functions?hl=ko#trigger_blocking_functions]\n\nFirebase 사용자 계정 생성 및 삭제에 대한 응답으로 함수를 트리거할 수 있습니다. 예를 들어 앱에 방금 계정을 만든 사용자에게 환영 이메일을 보낼 수 있습니다. 이 페이지에 있는 예시는 계정을 생성하거나 삭제한 사용자에게 발송하는 환영 이메일과 작별 이메일 샘플에 기반한 것입니다.\n\n사용 사례의 예를 더 보려면 Cloud Functions로 무엇을 할 수 있나요? [https://firebase.google.com/docs/functions/use-cases?hl=ko]를 참wh하세요.\n참고: Cloud Functions for Firebase(2세대)는 이 가이드에 설명된 이벤트 및 트리거를 지원하지 않습니다. 그러나 1세대 함수와 2세대 함수가 동일한 소스 파일에 나란히 공존할 수 있으므로 2세대 함수를 함께 사용하여 이 기능을 개발하고 배포할 수 있습니다.\n사용자 생성 시 함수 트리거'
 '보이지 않는 reCAPTCHA: 보이지 않는 reCAPTCHA는 렌더링 시 자동으로 확인되지 않으며, 그 대신 appVerifier.verify()를 호출하거나 reCAPTCHA의 버튼 앵커를 클릭하면 1초 내에 확인됩니다. 마찬가지로 일정 시간이 지나면 응답이 만료되며 appVerifier.verify() 호출을 사용하거나 reCAPTCHA의 버튼 앵커를 다시 클릭해야만 자동으로 확인 처리됩니다.\n\n모의 reCAPTCHA가 확인되면 해당하는 콜백 함수가 가짜 응답과 함께 정상적으로 트리거됩니다. 만료 콜백도 지정한 경우 만료 시에 트리거됩니다.\n\n다음 단계\n\n사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.\n\n앱에서 사용자의 인증 상태를 파악할 때 권장하는 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 그러면 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리 [https://firebase.google.com/docs/auth/web/manage-users?hl=ko]를 참조하세요.\n\nFirebase Realtime Database와 Cloud Storage 보안 규칙 [https://firebase.google.com/docs/database/security/user-security?hl=ko]의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.\n\n인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결 [https://firebase.google.com/docs/auth/web/account-linking?hl=ko]하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다.\n\n사용자를 로그아웃시키려면 signOut [https://firebase.google.com/docs/reference/js/auth?hl=ko#signout]을 호출합니다.'
 'Source URL: https://firebase.google.com/docs/firestore/manage-data/enable-offline?hl=ko\nTitle: 오프라인으로 데이터에 액세스\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\n오프라인으로 데이터에 액세스\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nCloud Firestore는 오프라인 데이터 지속성을 지원합니다. 이 기능은 기기가 오프라인 상태일 때 앱에서 데이터에 액세스할 수 있도록 앱에서 자주 사용하는 Cloud Firestore 데이터의 사본을 캐시합니다. 캐시된 데이터를 쓰고, 읽고, 리슨하고, 쿼리할 수 있습니다. 기기가 다시 온라인 상태가 되면 Cloud Firestore는 앱이 적용한 로컬 변경사항을 Cloud Firestore 백엔드에 동기화합니다.\n참고: 오프라인 지속성은 Android, Apple, 웹 앱에서만 지원됩니다.오프라인 지속성을 사용하기 위해 Cloud Firestore 데이터에 액세스할 때 사용하는 코드를 변경할 필요는 없습니다. 오프라인 지속성을 사용 설정하면 Cloud Firestore 클라이언트 라이브러리는 온라인 및 오프라인 데이터 액세스를 자동으로 관리하고 기기가 다시 온라인 상태가 되면 로컬 데이터를 동기화합니다.\n\n오프라인 지속성 구성\n\nCloud Firestore를 초기화할 때 오프라인 지속성을 사용 설정하거나 중지할 수 있습니다.'
 '앱이 시작되면 로컬 스토리지의 사용자 인증 정보(있는 경우)가 복원된 후 이벤트가 발생합니다. 즉, 사용자 상태가 초기화되면 항상 리스너가 호출됩니다. 그런 다음 인증 상태가 변경될 때마다 업데이트된 사용자 상태로 새 이벤트가 발생합니다.\n\n인증 상태를 수신 대기하면 이러한 인증 상태 변경사항에 반응하는 사용자 인터페이스를 빌드할 수 있습니다.\nauthStateChanges().listen(...)은 위젯의 빌드 메서드 내부에 직접 배치하지 마세요. 다시 빌드할 때마다 새 구독이 생성되기 때문입니다. 인증 상태에 따라 UI를 업데이트해야 하는 경우 StreamBuilder를 사용하세요.\nStreamBuilder<User?>(\nstream: FirebaseAuth.instance.authStateChanges(),\nbuilder: (BuildContext context, AsyncSnapshot<User?> snapshot) {\nif (snapshot.hasError) {\nreturn const Text(\'Something went wrong\');\n}\n\nif (snapshot.connectionState == ConnectionState.waiting) {\nreturn const Text(""Loading..."");\n}\n\nif (!snapshot.hasData) {\nreturn const SignInScreen();\n}\n\nfinal user = snapshot.data!;\nreturn HomeScreen(userId: user.uid);\n},\n)\n\n이 접근 방식을 사용하면 사용자의 인증 상태가 변경될 때 위젯 트리가 자동으로 다시 빌드됩니다.\n인증(signIn-) 메서드에서 반환하는 UserCredential 객체: UserCredential 객체에는 현재 User가 있는 user 속성이 포함되어 있습니다.\nfinal userCredential =\nawait FirebaseAuth.instance.signInWithCredential(credential);\nfinal user = userCredential.user;\nprint(user?.uid);'
 '새로운 데이터를 이전 데이터로 덮어쓰지 않으려면 이전 데이터를 먼저 추가해야 할 수 있습니다. 다음 단계의 설명처럼 새로운 데이터를 두 데이터베이스에 동시에 추가하는 경우에는 Cloud Functions를 사용해 Cloud Firestore에 추가된 새로운 데이터에 우선 순위를 부여하세요.\n\n이전 데이터를 Cloud Firestore로 마이그레이션하려면 다음 단계를 따르세요.\n\nRealtime Database에서 데이터를 내보내거나 최근 백업을 사용 [https://firebase.google.com/docs/database/backups?hl=ko]합니다.\n\nFirebase 콘솔에서 Realtime Database 섹션 [https://console.firebase.google.com/project/_/database/?hl=ko]으로 이동합니다.\n데이터 탭에서 데이터베이스의 루트 레벨 노드를 선택하고 메뉴에서 JSON 내보내기를 선택합니다.\n\nCloud Firestore에서 새 데이터베이스를 만들고 데이터를 추가 [https://firebase.google.com/docs/firestore/manage-data/add-data?hl=ko]합니다.\n\n일부 데이터를 Cloud Firestore로 이동할 때 다음과 같은 전략을 고려해 보세요.'
 '권장: 이메일 열거 보호 사용 설정\n\n이메일 주소가 등록되어 있어야 하는데(예: 이메일 주소와 비밀번호로 로그인할 때) 등록되지 않은 경우 또는 이메일 주소를 사용해서는 안 되는데(예: 사용자의 이메일 주소를 변경할 때) 등록된 경우, 이메일 주소를 파라미터로 사용하는 일부 Firebase Authentication 메서드에서 특정 오류가 발생합니다.\n이는 사용자에게 특정 조치를 제안하는 데 유용할 수 있지만 사용자가 등록한 이메일 주소를 악의적인 행위자가 발견하는 데 악용될 수도 있습니다.\n\n이러한 위험을 완화하려면 Google Cloud gcloud 도구를 사용하여 프로젝트에 이메일 열거 보호 기능을 사용 설정 [https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection?hl=ko]하는 것이 좋습니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경됩니다. 앱이 더 구체적인 오류에 의존하지 않는지 확인하세요.\n\n다음 단계\n\n사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.\n\n앱에서 사용자의 인증 상태를 파악할 때 권장하는 방법은 Auth 객체에 관찰자를 설정하는 것입니다. 그러면 User 객체로부터 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리 [https://firebase.google.com/docs/auth/web/manage-users?hl=ko]를 참조하세요.\n\nFirebase Realtime Database와 Cloud Storage 보안 규칙 [https://firebase.google.com/docs/database/security/user-security?hl=ko]의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.'
 'cur_value = firestore_payload.value.fields[""original""].string_value\nnew_value = cur_value.upper()\n\nif cur_value != new_value:\nprint(f""Replacing value: {cur_value} --> {new_value}"")\naffected_doc.set({""original"": new_value})\nelse:\n# Value is already upper-case\n# Don\'t perform a second write (which can trigger an infinite loop)\nprint(""Value is already upper-case."")\n```\n\n--- 탭: Go [https://cloud.google.com/firestore/native/docs/extend-with-cloud-run-functions?hl=ko#go] ---\n```\n// Package upper contains a Firestore Cloud Function.\npackage upper\n\nimport (\n""context""\n""errors""\n""fmt""\n""log""\n""os""\n""strings""\n\n""cloud.google.com/go/firestore""\nfirebase ""firebase.google.com/go/v4""\n""github.com/GoogleCloudPlatform/functions-framework-go/functions""\n""github.com/cloudevents/sdk-go/v2/event""\n""github.com/googleapis/google-cloudevents-go/cloud/firestoredata""\n""google.golang.org/protobuf/proto""\n)\n\n// set the GOOGLE_CLOUD_PROJECT environment variable when deploying.\nvar projectID = os.Getenv(""GOOGLE_CLOUD_PROJECT"")\n\n// client is a Firestore client, reused between function invocations.\nvar client *firestore.Client'
 ""| 이벤트 유형 | 트리거 |\n| --- | --- |\n| onCreate | 문서를 처음으로 기록할 때 트리거됩니다. |\n| onUpdate | 이미 존재하는 문서에서 값이 변경되었을 때 트리거됩니다. |\n| onDelete | 데이터가 있는 문서가 삭제되면 트리거됩니다. |\n| onWrite | onCreate, onUpdate 또는 onDelete가 트리거될 때 트리거됩니다. |\n참고: Firestore 이벤트는 문서 변경 시에만 트리거됩니다. 데이터가 변경되지 않는 Firestore 문서를 업데이트(노옵스(no-ops) 쓰기)할 때에는 업데이트 또는 쓰기 이벤트가 생성되지 않습니다. 특정 필드에 이벤트를 추가할 수 없습니다.\nFirebase용 Cloud 함수가 사용 설정된 프로젝트가 없으면\n시작하기: 첫 번째 함수 작성 및 배포 [https://firebase.google.com/docs/functions/get-started?hl=ko]를\n읽고 Firebase 프로젝트에 Cloud 함수를 구성 및 설정하세요.\n\nFirestore 트리거 함수 작성\n\n함수 트리거 정의\n\nFirestore 트리거를 정의하려면 문서 경로와 이벤트 유형을 지정합니다.\n\n--- 탭: Node.js [https://cloud.google.com/firestore/native/docs/extend-with-functions?hl=ko#node.js] ---\n```\nconst functions = require('firebase-functions');\n\nexports.myFunction = functions.firestore\n.document('my-collection/{docId}')\n.onWrite((change, context) => { /* ... */ });\n```\n문서 경로는 특정 문서 [https://cloud.google.com/firestore/native/docs/extend-with-functions?hl=ko#specific-documents] 또는 와일드 카드 패턴 [https://cloud.google.com/firestore/native/docs/extend-with-functions?hl=ko#wildcards-parameters]을 참조할 수 있습니다.\n중요: 문서 경로 끝에 슬래시가 없어야 합니다.\n단일 문서 지정\n\n다음 함수를 사용하면 특정 문서의 모든 변경에 이벤트를 트리거할 수 있습니다.""
 "". We'll cover Cloud SQL, Spanner, Firestore, Bigtable, and more. Understand when to use each forYouTubeStop guessing! Choose the right Google Cloud databaseEnroll today! → https://goo.gle/4icxI12 Tired of database confusion? Learn to confidently select the right Google Cloud database for ANY application! This course breaks down Cloud SQL, AlloyDB, Spanner, Bigtable, Firestore, and Memorystore. Plus, getYouTube🧠 Problem: Too much data for embedding? 🤯🧩 Solution: Chunk your data! ✂️A core principal of RAG is to search through your data to use as an input for LLMs. You can embed the data into a vector so it is searchable, but if you have a large video or entire book that will be too much data in one embedding. Let's talk aboutYouTubeGenAI is a game changer for podcasts 💡🎧Gemini is revolutionizing how I learn from tech podcasts! It helps me pinpoint the exact discussions that align with my interests, so I can deep-dive into the topics that matter most""
 '--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#kotlin-android] ---\n```\nval callbacks = object : OnVerificationStateChangedCallbacks() {\noverride fun onVerificationCompleted(credential: PhoneAuthCredential) {\n// This callback will be invoked in two situations:\n// 1) Instant verification. In some cases, the phone number can be\n//    instantly verified without needing to send or enter a verification\n//    code. You can disable this feature by calling\n//    PhoneAuthOptions.builder#requireSmsValidation(true) when building\n//    the options to pass to PhoneAuthProvider#verifyPhoneNumber().\n// 2) Auto-retrieval. On some devices, Google Play services can\n//    automatically detect the incoming verification SMS and perform\n//    verification without user action.\nthis@MainActivity.credential = credential\n}'
 ""YouTubeFirestore is now compatible with MongoDBLearn more: https://goo.gle/4klM1Bn This highly-requested capability is now available: Firestore is now compatible with MongoDB. This means you can use MongoDB's tools and drivers while taking advantage of Firestore's serverless features to buildYouTubeGen AI databases: speed, scale and securityReady to get started? → https://goo.gle/4icxI12 How do you choose the right database for generative AI? Learn about speed, scale, and security with AlloyDB, Spanner, Firestore, and Cloud SQL. Discover how to handle massive data, complex queries, andYouTubeVector-enabled databases: unlock semantic search!Enroll today! → https://goo.gle/4icxI12 Unlock the power of generative AI! Learn how vector embeddings and Google Cloud databases (AlloyDB, Spanner, Cloud SQL, BigQuery, Firestore) revolutionize data handling for AI applications. Discover how toYouTubeRelational vs. NoSQL: databases explained simplyReady to learn more? → https://goo.gle/4icxI12 Demystifying databases! Learn the core differences between relational and NoSQL databases on Google Cloud. We'll cover Cloud SQL, Spanner, Firestore, Bigtable, and more""
 '--- 탭: Java [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#java-android] ---\n```\nOnVerificationStateChangedCallbacks callbacks =\nnew OnVerificationStateChangedCallbacks() {\n@Override\npublic void onVerificationCompleted(PhoneAuthCredential credential) {\n// This callback will be invoked in two situations:\n// 1) Instant verification. In some cases, the phone number can be\n//    instantly verified without needing to send or enter a verification\n//    code. You can disable this feature by calling\n//    PhoneAuthOptions.builder#requireSmsValidation(true) when building\n//    the options to pass to PhoneAuthProvider#verifyPhoneNumber().\n// 2) Auto-retrieval. On some devices, Google Play services can\n//    automatically detect the incoming verification SMS and perform\n//    verification without user action.\nthis.credential = credential;\n}\n@Override\npublic void onVerificationFailed(FirebaseException e) {\n// This callback is invoked in response to invalid requests for\n// verification, like an incorrect phone number.\nif (e instanceof FirebaseAuthInvalidCredentialsException) {\n// Invalid request\n// ...\n} else if (e instanceof FirebaseTooManyRequestsException) {'
 '. Watch along to learn how an old circuit board and imaginary maps can help you thinkYouTubeServerless application development with a document databaseLosing time to market while building, testing and deploying your apps? Start building serverless, enterprise-grade apps that allow you to move faster. Hear from Forbes as they share how they used serverless technologies like Firestore, BigQuery andYouTubeFrom a virtual machine database to FirestoreHow to deploy an existing web app on Cloud Run → https://goo.gle/3S5mNZz'
 ""const OFFSCREEN_DOCUMENT_PATH = '/offscreen.html';\n\n// A global promise to avoid concurrency issues\nlet creatingOffscreenDocument;\n\n// Chrome only allows for a single offscreenDocument. This is a helper function\n// that returns a boolean indicating if a document is already active.\nasync function hasDocument() {\n// Check all windows controlled by the service worker to see if one\n// of them is the offscreen document with the given path\nconst matchedClients = await clients.matchAll();\nreturn matchedClients.some(\n(c) => c.url === chrome.runtime.getURL(OFFSCREEN_DOCUMENT_PATH)\n);\n}\n\nasync function setupOffscreenDocument(path) {\n// If we do not have a document, we are already setup and can skip\nif (!(await hasDocument())) {\n// create offscreen document\nif (creating) {\nawait creating;\n} else {\ncreating = chrome.offscreen.createDocument({\nurl: path,\nreasons: [\nchrome.offscreen.Reason.DOM_SCRAPING\n],\njustification: 'authentication'\n});\nawait creating;\ncreating = null;\n}\n}\n}\n\nasync function closeOffscreenDocument() {\nif (!(await hasDocument())) {\nreturn;\n}\nawait chrome.offscreen.closeDocument();\n}""
 'Accesses the NoSQL document database built for automatic scaling, high performance, and ease of application development.\n\nService: firestore.googleapis.com\nTo call this service, we recommend that you use the Google-provided client libraries [https://cloud.google.com/apis/docs/client-libraries-explained]. If your application needs to use your own libraries to call this service, use the following information when you make the API requests.\n\nDiscovery document\nA Discovery Document [https://developers.google.com/discovery/v1/reference/apis] is a machine-readable specification for describing and consuming REST APIs. It is used to build client libraries, IDE plugins, and other tools that interact with Google APIs. One service may provide multiple discovery documents. This service provides the following discovery documents:'
 ""let callback = null;\nlet metadataRef = null;\nfirebase.auth().onAuthStateChanged(user => {\n// Remove previous listener.\nif (callback) {\nmetadataRef.off('value', callback);\n}\n// On user login add new listener.\nif (user) {\n// Check if refresh is required.\nmetadataRef = firebase.database().ref('metadata/' + user.uid + '/refreshTime');\ncallback = (snapshot) => {\n// Force refresh to pick up the latest custom claims changes.\n// Note this is always triggered on first call. Further optimization could be\n// added to avoid the initial trigger when the token is issued and already contains\n// the latest claims.\nuser.getIdToken(true);\n};\n// Subscribe new listener to changes on that node.\nmetadataRef.on('value', callback);\n}\n});\n\nCloud Functions 로직\n\n읽기/쓰기 권한이 인증된 사용자로 제한된 새 데이터베이스 노드(metadata/($uid)}가\n추가됩니다.\nconst functions = require('firebase-functions');\nconst { initializeApp } = require('firebase-admin/app');\nconst { getAuth } = require('firebase-admin/auth');\nconst { getDatabase } = require('firebase-admin/database');\n\ninitializeApp();""
 "". You'll learn first hand how Firebase's Firestore and Storage streamline data management and mediaYouTubeNon-relational databases design patterns: How Shopify leverages them to power their businessWhen your data outgrows the confines of traditional relational models, Google Cloud's databases offer the solution. This session will explore how to harness the power of distributed architectures and flexible schemas to handle massive datasets. We'llYouTubeCloud SQL, Cloud Spanner, or Firestore?Be a Cloud Digital Leader! https://goo.gle/CDL What's the difference between Cloud SQL, Cloud Spanner, and Firestore, and how do you know when to choose one over the other? This video breaks it down to help you on your journey to become Cloud DigitalYouTubeBuilding a next-generation scalable gaming platform using FirestoreGaming innovators rely on Firestore for its flexibility, simplified scalability and hands-free serverless management""
 ""// Confirm the link is a sign-in with email link.\nconst auth = getAuth();\nif (isSignInWithEmailLink(auth, window.location.href)) {\n// Additional state parameters can also be passed via URL.\n// This can be used to continue the user's intended action before triggering\n// the sign-in operation.\n// Get the email if available. This should be available if the user completes\n// the flow on the same device where they started it.\nlet email = window.localStorage.getItem('emailForSignIn');\nif (!email) {\n// User opened the link on a different device. To prevent session fixation\n// attacks, ask the user to provide the associated email again. For example:\nemail = window.prompt('Please provide your email for confirmation');\n}\n// The client SDK will parse the code from the link for you.\nsignInWithEmailLink(auth, email, window.location.href)\n.then((result) => {\n// Clear email from storage.\nwindow.localStorage.removeItem('emailForSignIn');\n// You can access the new user by importing getAdditionalUserInfo\n// and calling it with result:\n// getAdditionalUserInfo(result)\n// You can access the user's profile via:\n// getAdditionalUserInfo(result)?.profile\n// You can check if the user is new or existing:""
 'Q: Node.js에서 Cloud Firestore의 문서가 업데이트될 때 실행되는 함수를 정의하는 방법은 무엇인가요?\nA: 다음은 사용자가 프로필을 변경하면 실행되는 함수의 예시입니다.\n\n```javascript\nconst {\nonDocumentUpdated,\nChange,\nFirestoreEvent\n} = require(\'firebase-functions/v2/firestore\');\n\nexports.updateuser = onDocumentUpdated(""users/{userId}"", (event) => {\n// Get an object representing the document\n// e.g. {\'name\': \'Marie\', \'age\': 66}\nconst newValue = event.data.after.data();\n\n// access a particular field as you would any JS property\nconst name = newValue.name;\n\n// perform more operations ...\n});\n```'
 'Q: Cloud Firestore에서 문서의 모든 변경사항에 대해 트리거되는 함수를 Python으로 작성하는 방법은 무엇인가요?\nA: 다음은 사용자가 생성, 업데이트 또는 삭제될 때 실행되는 함수의 예시입니다.\n\n```python\nfrom firebase_functions.firestore_fn import (\non_document_written,\nEvent,\nChange,\nDocumentSnapshot,\n)\n\n@on_document_written(document=""users/{userId}"")\ndef myfunction(event: Event[Change[DocumentSnapshot | None]]) -> None:\n# Get an object with the current document values.\n# If the document does not exist, it was deleted.\ndocument = (event.data.after.to_dict()\nif event.data.after is not None else None)\n\n# Get an object with the previous document values.\n# If the document does not exist, it was newly created.\nprevious_values = (event.data.before.to_dict()\nif event.data.before is not None else None)\n\n# Perform more operations ...\n```'
 'Q: Node.js에서 Cloud Firestore의 문서의 모든 변경사항에 대해 트리거되는 함수를 작성하는 방법은 무엇인가요?\nA: 다음은 사용자가 생성, 업데이트 또는 삭제될 때 실행되는 함수의 예시입니다.\n\n```javascript\nconst {\nonDocumentWritten,\nChange,\nFirestoreEvent\n} = require(\'firebase-functions/v2/firestore\');\n\nexports.modifyuser = onDocumentWritten(""users/{userId}"", (event) => {\n// Get an object with the current document values.\n// If the document does not exist, it was deleted\nconst document =  event.data.after.data();\n\n// Get an object with the previous document values\nconst previousValues =  event.data.before.data();\n\n// perform more operations ...\n});\n```'
 'Q: Python에서 Cloud Firestore의 문서가 업데이트될 때 트리거되는 함수를 작성하는 방법은 무엇인가요?\nA: 다음은 사용자가 프로필을 변경하면 실행되는 함수의 예시입니다.\n\n```python\nfrom firebase_functions.firestore_fn import (\non_document_updated,\nEvent,\nChange,\nDocumentSnapshot,\n)\n\n@on_document_updated(document=""users/{userId}"")\ndef myfunction(event: Event[Change[DocumentSnapshot]]) -> None:\n# Get a dictionary representing the document\n# e.g. {\'name\': \'Marie\', \'age\': 66}\nnew_value = event.data.after.to_dict()\n\n# Access a particular field as you would any dictionary\nname = new_value[""name""]\n\n# Perform more operations ...\n```'
 'Q: Python에서 Cloud Firestore의 문서의 모든 변경사항에 대해 트리거되는 함수를 작성하는 방법은 무엇인가요?\nA: 다음은 사용자가 생성, 업데이트 또는 삭제될 때 실행되는 함수의 예시입니다.\n\n```python\nfrom firebase_functions.firestore_fn import (\non_document_written,\nEvent,\nChange,\nDocumentSnapshot,\n)\n\n@on_document_written(document=""users/{userId}"")\ndef myfunction(event: Event[Change[DocumentSnapshot | None]]) -> None:\n# Get an object with the current document values.\n# If the document does not exist, it was deleted.\ndocument = (event.data.after.to_dict()\nif event.data.after is not None else None)\n\n# Get an object with the previous document values.\n# If the document does not exist, it was newly created.\nprevious_values = (event.data.before.to_dict()\nif event.data.before is not None else None)\n\n# Perform more operations ...\n```'
 'Q: Firebase Realtime Database와 Cloud Storage에서 로그인한 사용자의 고유 사용자 ID를 가져오는 방법은 무엇인가요?\nA: Firebase Realtime Database와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.'
 'Q: Cloud Firestore에서 접속 상태를 구현하기 위해 어떤 Firebase 제품을 사용해야 하나요?\nA: Cloud Firestore는 기본적으로 접속 상태를 지원하지 않지만, Firebase 실시간 데이터베이스(Realtime Database)와 Cloud Functions를 활용하여 접속 상태 시스템을 빌드할 수 있습니다.'
 'Q: Firebase Authentication에서 사용자의 로그인 상태가 변경될 때 어떤 정보를 가져올 수 있나요?\nA: 사용자의 로그인 상태가 변경될 때, 이벤트 핸들러에서 사용자의 DisplayName, UserId, Email, PhotoUrl 등의 정보를 가져올 수 있습니다. 아래는 관련 코드입니다.\n\n```csharp\nif (signedIn) {\nDebugLog(""Signed in "" + user.UserId);\ndisplayName = user.DisplayName ?? """";\nemailAddress = user.Email ?? """";\nphotoUrl = user.PhotoUrl ?? """";\n}\n```'
 'Q: Firebase Hosting에서 Cloud Functions를 제공하기 위한 firebase.json 설정 방법은 무엇인가요?\nA: 다음과 같이 firebase.json 파일을 수정하여 Cloud Functions를 제공할 수 있습니다:\n\n```json\n{\n  ""hosting"": {\n    ""rewrites"": [{\n      ""source"": ""/createBundle"",\n      ""function"": ""createBundle""\n    }]\n  }\n}\n```'
 'Q: Firebase 인증 상태 변경사항을 수신 대기하는 방법에는 어떤 것들이 있나요?\nA: Firebase 인증 상태 변경사항을 수신 대기하는 방법에는 세 가지가 있습니다:\n1. `authStateChanges()` 메서드\n2. `idTokenChanges()` 메서드\n3. `userChanges()` 메서드\n\n각 메서드는 사용자의 인증 상태가 변경될 때마다 이벤트를 제공합니다.'
 'Q: Firebase Firestore의 IAM 관련 문서가 없을 경우, 어떤 지원을 받을 수 있나요?\nA: Firebase 지원 페이지 [https://firebase.google.com/support/]를 통해 추가 지원을 받을 수 있습니다.'
 'Q: 사용자가 Apple로 로그인한 후 신규 사용자 계정을 생성하는 방법은 무엇인가요?\nA: 사용자가 Apple로 로그인한 후 신규 사용자 계정은 자동으로 생성됩니다. 이 신규 계정은 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. Firebase 프로젝트에 저장되며, 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.'
 'Q: Firebase Firestore의 샘플 코드를 어디서 찾을 수 있나요?\nA: Firebase Firestore의 샘플 코드는 [https://firebase.google.com/docs/samples/]에서 확인할 수 있습니다.'
 'Q: 전화번호 인증을 사용할 때 보안 문제를 어떻게 해결할 수 있나요?\nA: 전화번호만 사용하는 인증은 보안성이 떨어질 수 있으므로, 앱에서 전화번호 기반 로그인을 사용하는 경우 더 안전한 로그인 방법을 함께 제공해야 합니다. 또한, 전화번호 로그인을 사용하면 보안이 약화된다는 점을 사용자에게 알려야 합니다.'
 'Q: Firebase Firestore API 문서가 없을 때, 사용자가 샘플 코드를 찾을 수 있는 링크는 무엇인가요?\nA: 사용자가 샘플 코드를 찾을 수 있는 링크는 [https://firebase.google.com/docs/samples/]입니다.'
 'Q: Firebase에서 사용자 활동 및 감사 로깅을 설정하는 방법은 무엇인가요?\nA: 사용자 활동 및 감사 로깅을 설정하려면 Firebase Console의 인증 설정 페이지에서 사용자 활동 로깅을 사용 설정하면 됩니다. 또한, 프로젝트를 업그레이드하면 Cloud Logging에서 관리자 활동 감사 로그가 자동으로 사용 설정됩니다.'
 'Q: Cloud Functions를 디버깅할 때 유용한 방법은 무엇인가요?\nA: Cloud Functions를 디버깅할 때는 Function Frameworks를 사용하여 실행할 수 있습니다. 더 많은 정보는 [여기](https://goo.gle/3yaKLZW)에서 확인할 수 있습니다.'
 'Q: Firebase Authentication에서 멀티테넌시를 사용하는 방법은 무엇인가요?\nA: Firebase Authentication에서 멀티테넌시를 사용하려면 Cloud Identity Platform 문서에서 멀티테넌시 시작하기를 참조하여 단일 프로젝트 내에 사용자 및 구성의 고유한 사일로를 여러 개 만들 수 있습니다.'
 'Q: 비정규화된 데이터에서 벡터 임베딩을 사용할 때 어떤 거리 측정을 사용하는 것이 좋나요?\nA: 비정규화된 데이터에서 벡터 임베딩을 사용할 때는 COSINE 또는 EUCLIDEAN 거리 측정을 사용하는 것이 좋습니다. 이는 임베딩이 생성된 방법과 원하는 검색 유형에 따라 주관적으로 더 나은 검색 결과를 생성할 수 있습니다.'
 'Q: Chrome 확장 프로그램에서 오프스크린 문서가 이미 활성화되어 있는지 확인하는 방법은 무엇인가요?\nA: 오프스크린 문서가 이미 활성화되어 있는지 확인하려면 다음과 같은 함수를 사용할 수 있습니다:\n\n```javascript\nasync function hasDocument() {\n  const matchedClients = await clients.matchAll();\n  return matchedClients.some(\n    (c) => c.url === chrome.runtime.getURL(OFFSCREEN_DOCUMENT_PATH)\n  );\n}\n```'
 'Q: Cloud Firestore에서 컬렉션(collection)을 생성하는 방법은 무엇인가요?\nA: 컬렉션은 문서가 생성될 때 자동으로 생성됩니다. 즉, 컬렉션에 첫 번째 문서를 만들면 컬렉션이 생성되며, 모든 문서를 삭제하면 컬렉션도 삭제됩니다.'
 'Q: OpenID Connect(OIDC) 제공업체를 사용하여 Firebase에 사용자를 인증하기 위해 필요한 정보는 무엇인가요?\nA: OIDC 제공업체를 사용하여 사용자를 로그인하도록 하려면 다음 정보를 수집해야 합니다:\n\n1. 클라이언트 ID: 앱을 식별하는 제공업체의 고유한 문자열입니다. 이 값은 제공업체에서 발급한 ID 토큰의 aud 클레임 값 중 하나입니다.\n2. 클라이언트 보안 비밀번호: 제공업체가 클라이언트 ID의 소유권을 확인하는 데 사용하는 보안 비밀 문자열입니다. 인증 코드 흐름을 사용하는 경우에만 필요합니다.\n3. 발급기관: 제공업체를 식별하는 문자열로, 이 값은 /.well-known/openid-configuration이 추가될 때 제공업체의 OIDC 탐색 문서가 위치하는 URL이어야 합니다.'
 'Q: Firestore에서 문서의 메타데이터가 변경될 때 리스너를 어떻게 설정하나요?\nA: Firestore에서 문서의 메타데이터가 변경될 때 리스너를 설정하려면, 리스너를 연결할 때 메타데이터 변경 사항을 수신하도록 옵션을 전달해야 합니다. 기본적으로 메타데이터에만 영향을 미치는 변경 사항은 리스너에 통보되지 않습니다.'
 'Q: 자동 정리 기능을 사용하면 어떤 이점이 있나요?\nA: 자동 정리를 사용 설정하면 30일이 지난 익명 계정은 자동으로 삭제됩니다. 자동 정리가 사용 설정된 프로젝트에서는 익명 인증이 더 이상 사용량 한도 또는 결제 할당량에 포함되지 않습니다.'
 'Q: Cloud Firestore에서 클라이언트의 접속 상태를 어떻게 알 수 있나요?\nA: Cloud Firestore는 기본적으로 클라이언트의 접속 상태를 지원하지 않지만, Cloud Functions를 사용하여 Cloud Firestore와 Realtime Database를 동기화하여 Realtime Database의 접속 상태 지원을 활용할 수 있습니다.'
 'Q: Firebase에서 익명 계정의 자동 정리 기능을 사용 설정하면 어떤 효과가 있나요?\nA: 자동 정리를 사용 설정하면 Firebase에서 30일이 지난 익명 계정을 자동으로 삭제할 수 있습니다. 이 기능이 사용 설정된 프로젝트에서는 익명 인증이 사용량 한도 또는 결제 할당량에 포함되지 않습니다.'
 'Q: Firebase 확장 프로그램을 사용하여 Firestore 문서를 자동으로 삽입하고 쿼리하는 방법은 무엇인가요?\nA: Firebase 확장 프로그램을 사용하면 벡터 검색 기능으로 Firestore 문서를 자동으로 삽입하고 쿼리할 수 있습니다. 이 기능은 Firebase 프로젝트에서 자동 벡터 검색을 수행하는 데 유용합니다.'
 'Q: Firebase JavaScript SDK에서 Twitter 인증을 위한 리디렉션 방식을 사용하는 방법은 무엇인가요?\nA: Twitter 인증을 위한 리디렉션 방식을 사용하려면 `signInWithRedirect` 메서드를 호출합니다. 아래는 예시 코드입니다.\n\n```javascript\nimport { getAuth, signInWithRedirect } from ""firebase/auth"";\n\nconst auth = getAuth();\nsignInWithRedirect(auth, provider);\n```'
 'Q: Cloud Functions를 사용하여 접속 상태를 동기화할 때 주의해야 할 점은 무엇인가요?\nA: Cloud Functions를 사용하여 접속 상태를 동기화할 때, 인터넷 연결이 끊기면 데이터를 동기화할 방법이 없으므로 동일한 데이터를 동일한 위치에 써야 합니다. 이렇게 해야 모든 기기가 온라인 상태일 때 변경사항을 수신할 수 있습니다.'
 'Q: 서비스 워커를 사용할 수 없는 브라우저에 대한 대체 방법은 무엇인가요?\nA: 서비스 워커를 사용할 수 없는 브라우저에서는 ID 토큰을 서버에 전달하기 위한 대체 방법이 필요할 수 있습니다. 이 경우, 서비스 워커를 지원하는 브라우저에서만 실행되도록 앱을 제한할 수 있습니다.'
 'Q: Cloud Functions를 사용하여 데이터베이스를 일치시키려면 어떤 주의사항이 있나요?\nA: Cloud Functions를 사용하여 데이터베이스를 일치시키려는 경우 루프 내에서 두 데이터베이스의 쓰기 작업이 중복되지 않도록 주의합니다. 단일 데이터베이스에 쓰도록 함수를 전환하거나, 함수를 완전히 삭제하고 아직 Realtime Database에 연결된 앱의 마이그레이션된 데이터에 대한 쓰기 기능을 단계적으로 종료할 수도 있습니다.'
 'Q: OpenID Connect(OIDC) 제공업체를 Firebase에 설정하기 위해 필요한 정보는 무엇인가요?\nA: OpenID Connect(OIDC) 제공업체를 Firebase에 설정하기 위해 필요한 정보는 다음과 같습니다:\n1. 클라이언트 ID (client ID): 앱을 식별하는 제공업체의 고유한 문자열입니다.\n2. 클라이언트 보안 비밀번호 (client secret): 제공업체가 클라이언트 ID의 소유권을 확인하는 데 사용하는 보안 비밀 문자열입니다.\n3. 발급기관 (issuer): 제공업체를 식별하는 문자열로, OIDC 탐색 문서가 위치하는 URL이어야 합니다.'
 'Q: Firebase Firestore Eventarc 문서가 없는 경우, 다른 리소스를 어떻게 찾을 수 있나요?\nA: 다른 리소스를 찾기 위해 Firebase의 홈페이지([https://firebase.google.com/])나 Docs 및 API([https://firebase.google.com/docs/])를 방문하여 필요한 정보를 검색할 수 있습니다.'
 'Q: Firebase Firestore의 Eventarc에 대한 문서가 없을 때 어떻게 해야 하나요?\nA: 문서가 없을 경우, Firebase의 홈페이지([https://firebase.google.com/])나 Docs 및 API([https://firebase.google.com/docs/])를 확인해 보세요.'
 'Q: Cloud Firestore에서 문서를 삭제할 때 하위 컬렉션의 문서는 어떻게 처리되나요?\nA: 문서를 삭제해도 Cloud Firestore는 하위 컬렉션 내 문서를 자동으로 삭제하지 않습니다. 따라서 참조를 통해 하위 컬렉션 문서에 액세스할 수 있습니다. 예를 들어 /mycoll/mydoc에 상위 문서가 없어도 /mycoll/mydoc/mysubcoll/mysubdoc 경로에 있는 문서에 액세스할 수 있습니다.'
 'Q: 트랜잭션이 실패했을 때 Firestore에서 자동으로 수행되는 작업은 무엇인가요?\nA: 트랜잭션이 실패했을 때 Firestore에서 자동으로 수행되는 작업은 트랜잭션을 롤백할 필요가 없다는 것입니다. Firestore는 실패한 트랜잭션을 자동으로 롤백합니다.'
 'Q: Cloud Firestore에 접속 상태를 동기화하기 위해 어떤 절차를 따라야 하나요?\nA: Cloud Firestore에 접속 상태를 동기화하려면, 먼저 실시간 데이터베이스의 코드를 사용한 후 Cloud Functions를 통해 실시간 데이터베이스와 Cloud Firestore를 동기화해야 합니다.'
 'Q: Firebase Realtime Database와 Cloud Storage에서 로그인한 사용자의 고유 사용자 ID를 가져오는 방법은 무엇인가요?\nA: Firebase Realtime Database와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후, 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.'
 'Q: Android 앱에서 Firestore 라이브러리를 추가하기 위해 필요한 Gradle 설정은 무엇인가요?\nA: Android용 Firestore 라이브러리의 종속 항목을 선언하려면, `app/build.gradle` 파일에 다음 코드를 추가합니다.\n\n```gradle\nimplementation(""com.google.firebase:firebase-firestore:26.0.0"")\n```\n앱에서 여러 Firebase 라이브러리를 사용하는 경우, Firebase Android BoM을 사용하는 것이 좋습니다.'
 'Q: Firebase Realtime Database와 Cloud Storage에서 로그인한 사용자의 고유 사용자 ID를 가져오는 방법은 무엇인가요?\nA: Firebase Realtime Database와 Cloud Storage 보안 규칙의 auth 변수를 사용하여 로그인한 사용자의 고유 사용자 ID를 가져올 수 있습니다. 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.'
 ""Q: documents.list 메서드에서 'showMissing' 파라미터를 사용하면 어떤 결과를 얻을 수 있나요?\nA: 'showMissing' 파라미터가 true로 설정되면, 존재하지 않지만 하위 문서가 있는 문서가 반환됩니다. 이러한 문서는 키는 포함되지만 필드, createTime 또는 updateTime은 설정되지 않습니다. 'showMissing'을 사용하는 요청은 'where' 또는 'orderBy'를 지정할 수 없습니다.""
 'Q: Firebase Realtime Database와 Cloud Storage 보안 규칙에서 로그인한 사용자의 고유 사용자 ID를 어떻게 가져오나요?\nA: Firebase Realtime Database와 Cloud Storage 보안 규칙의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.'
 'Q: RunQueryResponse에서 쿼리 결과를 어떻게 확인할 수 있나요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Can only be set in the first response, and only if RunQueryRequest.new_transaction was set in the request. If set, no other fields will be set in this response. |\n| document | Document A query result, not set when reporting partial progress. |\n| read_time | Timestamp The time at which the document was read. This may be monotonically increasing; in this case, the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no document will be sent, and this represents the time at which the query was run. |\n| skipped_results | int32 The number of results that have been skipped due to an offset between the last response and the current response. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |\n| Union field continuation_selector. The continuation mode for the query. If present, it indicates the current query response stream has finished. This can be set with or without a document present, but when set, no more results are returned. continuation_selector can be only one of the following: |\n| done | bool If present, Firestore has completely finished the request and no more documents will be returned. |'
 'Q: Apple 계정과 Facebook 계정을 연결하기 위해 필요한 절차는 무엇인가요?\nA: // Initialize a Facebook credential with Firebase.\nlet credential = FacebookAuthProvider.credential(\n    withAccessToken: AccessToken.current!.tokenString\n)\n// Assuming the current user is an Apple user linking a Facebook provider.\nAuth.auth().currentUser.link(with: credential) { (authResult, error) in\n    // Facebook credential is linked to the current Apple user.\n    // The user can now sign in with Facebook or Apple to the same Firebase\n    // account.\n    // ...\n}'
 'Q: Firestore에서 RunQueryResponse를 통해 어떤 정보를 받을 수 있나요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Can only be set in the first response, and only if RunQueryRequest.new_transaction was set in the request. If set, no other fields will be set in this response. |\n| document | Document A query result, not set when reporting partial progress. |\n| read_time | Timestamp The time at which the document was read. This may be monotonically increasing; in this case, the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no document will be sent, and this represents the time at which the query was run. |\n| skipped_results | int32 The number of results that have been skipped due to an offset between the last response and the current response. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |\n| Union field continuation_selector. The continuation mode for the query. If present, it indicates the current query response stream has finished. This can be set with or without a document present, but when set, no more results are returned. continuation_selector can be only one of the following: |\n| done | bool If present, Firestore has completely finished the request and no more documents will be returned. |'
 ""Q: Chrome 확장 프로그램에서 오프스크린 문서를 설정하는 방법은 무엇인가요?\nA: 오프스크린 문서를 설정하기 위해 background.js 서비스 워커에서 아래와 같은 코드를 사용합니다. 이 코드는 오프스크린 문서가 이미 활성화되어 있는지 확인하고, 활성화되어 있지 않다면 새 문서를 생성합니다.\n\n```javascript\nasync function setupOffscreenDocument(path) {\n// If we do not have a document, we are already setup and can skip\nif (!(await hasDocument())) {\n// create offscreen document\nif (creating) {\nawait creating;\n} else {\ncreating = chrome.offscreen.createDocument({\nurl: path,\nreasons: [\nchrome.offscreen.Reason.DOM_SCRAPING\n],\njustification: 'authentication'\n});\nawait creating;\ncreating = null;\n}\n}\n}\n```""
 'Q: RunQueryResponse에서 쿼리 결과를 확인할 때 어떤 필드를 확인해야 하나요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Can only be set in the first response, and only if RunQueryRequest.new_transaction was set in the request. If set, no other fields will be set in this response. |\n| document | Document A query result, not set when reporting partial progress. |\n| read_time | Timestamp The time at which the document was read. This may be monotonically increasing; in this case, the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no document will be sent, and this represents the time at which the query was run. |\n| skipped_results | int32 The number of results that have been skipped due to an offset between the last response and the current response. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |\n| Union field continuation_selector. The continuation mode for the query. If present, it indicates the current query response stream has finished. This can be set with or without a document present, but when set, no more results are returned. continuation_selector can be only one of the following: |\n| done | bool If present, Firestore has completely finished the request and no more documents will be returned. |'
 'Q: Firebase에서 GitHub 인증을 통해 사용자를 재인증하는 방법은 무엇인가요?\nA: Firebase에서 GitHub 인증을 통해 사용자를 재인증하려면 Auth().currentUser.reauthenticateWithCredential(withCredential: credential) 메서드를 사용합니다. 이 메서드는 다음과 같이 사용할 수 있습니다.\n\n```swift\nAuth().currentUser.reauthenticateWithCredential(withCredential: credential) { authResult, error in\n    if error != nil {\n        // Handle error.\n    }\n    // User is re-authenticated with fresh tokens minted and\n    // should be able to perform sensitive operations like account\n    // deletion and email or password update.\n    // IdP data available in result.additionalUserInfo.profile.\n    // Additional OAuth access token is can also be retrieved by:\n    // (authResult.credential as? OAuthCredential)?.accessToken\n    // GitHub OAuth ID token can be retrieved by calling:\n    // (authResult.credential as? OAuthCredential)?.idToken\n}\n```\n\nObjective-C에서는 다음과 같이 사용할 수 있습니다.\n\n```objective-c\n[[FIRAuth auth].currentUser\nreauthenticateWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\n    if (error) {\n        // Handle error.\n    }\n    // User is re-authenticated with fresh tokens minted and\n    // should be able to perform sensitive operations like account\n    // deletion and email or password update.\n    // IdP data available in result.additionalUserInfo.profile.\n    // Additional OAuth access token is can also be retrieved by:\n    // ((FIROAuthCredential *)authResult.credential).accessToken\n    // GitHub OAuth ID token can be retrieved by calling\n}];\n```'
 'Q: RunQueryResponse에서 쿼리 결과를 확인할 때 포함될 수 있는 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Can only be set in the first response, and only if RunQueryRequest.new_transaction was set in the request. If set, no other fields will be set in this response. |\n| document | Document A query result, not set when reporting partial progress. |\n| read_time | Timestamp The time at which the document was read. This may be monotonically increasing; in this case, the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no document will be sent, and this represents the time at which the query was run. |\n| skipped_results | int32 The number of results that have been skipped due to an offset between the last response and the current response. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |\n| Union field continuation_selector. The continuation mode for the query. If present, it indicates the current query response stream has finished. This can be set with or without a document present, but when set, no more results are returned. continuation_selector can be only one of the following: |\n| done | bool If present, Firestore has completely finished the request and no more documents will be returned. |'
 'Q: Swift에서 사용자가 재인증을 수행하는 방법은 무엇인가요?\nA: Swift에서 사용자가 재인증을 수행하려면 `reauthenticateWithCredential(withCredential:)` 메서드를 사용합니다. 다음은 예시입니다:\n```swift\nAuth().currentUser.reauthenticateWithCredential(withCredential: credential) { authResult, error in\nif error != nil {\n// Handle error.\n}\n// User is re-authenticated with fresh tokens minted and\n// should be able to perform sensitive operations like account\n// deletion and email or password update.\n// IdP data available in result.additionalUserInfo.profile.\n// Additional OAuth access token can also be retrieved:\n// (authResult.credential as? OAuthCredential)?.accessToken\n// OAuth ID token can also be retrieved:\n// (authResult.credential as? OAuthCredential)?.idToken\n}\n```'
 'Q: Geohash 도우미 라이브러리를 설치하는 방법은 무엇인가요?\nA: // Install from NPM. If you prefer to use a static .js file visit\n// https://github.com/firebase/geofire-js/releases and download\n// geofire-common.min.js from the latest version\nnpm install --save geofire-common'
 'Q: Swift에서 Microsoft OAuthProvider의 인스턴스를 사용하여 사용자를 재인증하는 방법은 무엇인가요?\nA: 다음 코드를 사용하여 사용자를 재인증할 수 있습니다.\n\n```swift\nAuth().currentUser.reauthenticateWithCredential(withCredential: credential) { authResult, error in\n    if error != nil {\n        // Handle error.\n    }\n    // User is re-authenticated with fresh tokens minted and\n    // should be able to perform sensitive operations like account\n    // deletion and email or password update.\n    // IdP data available in result.additionalUserInfo.profile.\n    // Additional OAuth access token can also be retrieved:\n    // (authResult.credential as? OAuthCredential)?.accessToken\n    // OAuth ID token can also be retrieved:\n    // (authResult.credential as? OAuthCredential)?.idToken\n}\n```'
 ""Q: Node.js에서 Cloud Firestore의 'regions' 배열 필드에 여러 지역을 원자적으로 추가하는 방법은 무엇인가요?\nA: Node.js에서 Cloud Firestore의 'regions' 배열 필드에 여러 지역을 원자적으로 추가하는 방법은 다음과 같습니다.\n\n```javascript\nconst multipleUnionRes = await washingtonRef.update({\n  regions: FieldValue.arrayUnion('south_carolina', 'texas')\n  // Alternatively, you can use spread operator in ES6 syntax\n  // const newRegions = ['south_carolina', 'texas']\n  // regions: FieldValue.arrayUnion(...newRegions)\n});\n```""
 'Q: Swift에서 사용자를 재인증하는 방법은 무엇인가요?\nA: 다음과 같이 `reauthenticateWithCredential(withCredential:)` 메서드를 사용하여 사용자를 재인증할 수 있습니다.\n\n```swift\nAuth().currentUser.reauthenticateWithCredential(withCredential: credential) { authResult, error in\n    if error != nil {\n        // Handle error.\n    }\n    // User is re-authenticated with fresh tokens minted and\n    // should be able to perform sensitive operations like account\n    // deletion and email or password update.\n    // IdP data available in result.additionalUserInfo.profile.\n    // Additional OAuth access token is can also be retrieved by:\n    // (authResult.credential as? OAuthCredential)?.accessToken\n    // GitHub OAuth ID token can be retrieved by calling:\n    // (authResult.credential as? OAuthCredential)?.idToken\n}\n```'
 'Q: Node.js에서 Cloud Firestore의 \'regions\' 배열 필드에 여러 지역을 원자적으로 추가하는 방법은 무엇인가요?\nA: // ...\nconst washingtonRef = db.collection(\'cities\').doc(\'DC\');\n\n// Atomically add a new region to the ""regions"" array field.\nconst unionRes = await washingtonRef.update({\nregions: FieldValue.arrayUnion(\'greater_virginia\')\n});\n// Atomically remove a region from the ""regions"" array field.\nconst removeRes = await washingtonRef.update({\nregions: FieldValue.arrayRemove(\'east_coast\')\n});\n// To add or remove multiple items, pass multiple arguments to arrayUnion/arrayRemove\nconst multipleUnionRes = await washingtonRef.update({\nregions: FieldValue.arrayUnion(\'south_carolina\', \'texas\')\n// Alternatively, you can use spread operator in ES6 syntax\n// const newRegions = [\'south_carolina\', \'texas\']\n// regions: FieldValue.arrayUnion(...newRegions)\n});'
 'Q: Objective-C에서 Microsoft OAuthProvider의 인스턴스를 사용하여 사용자를 재인증하는 코드는 무엇인가요?\nA: [[FIRAuth auth].currentUser\nreauthenticateWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\nif (error) {\n// Handle error.\n}\n// User is re-authenticated with fresh tokens minted and\n// should be able to perform sensitive operations like account\n// deletion and email or password update.\n// IdP data available in authResult.additionalUserInfo.profile.\n// Additional OAuth access token can also be retrieved:\n// ((FIROAuthCredential *)authResult.credential).accessToken\n// OAuth ID token can also be retrieved:\n// ((FIROAuthCredential *)authResult.credential).idToken\n}];'
 'Q: FirestoreAdmin API에서 인덱스의 밀도 구성(Density) 값은 무엇이 있나요?\nA: | Enums |\n| --- |\n| DENSITY_UNSPECIFIED | Unspecified. It will use database default setting. This value is input only. |\n| SPARSE_ALL | In order for an index entry to be added, the document must contain all fields specified in the index. This is the only allowed value for indexes having ApiScope ANY_API and DATASTORE_MODE_API. |\n| SPARSE_ANY | In order for an index entry to be added, the document must contain at least one of the fields specified in the index. Non-existent fields are treated as having a NULL value when generating index entries. |\n| DENSE | An index entry will be added regardless of whether the document contains any of the fields specified in the index. Non-existent fields are treated as having a NULL value when generating index entries.'
 ""Q: Firebase JavaScript SDK에서 Microsoft 계정으로 재인증하기 위해 reauthenticateWithPopup 메서드를 사용하는 방법은 무엇인가요?\nA: 다음 코드를 사용하여 Firebase JavaScript SDK에서 Microsoft 계정으로 재인증할 수 있습니다:\n\n```javascript\nvar provider = new firebase.auth.OAuthProvider('microsoft.com');\nfirebase.auth().currentUser.reauthenticateWithPopup(provider)\n.then((result) => {\n// User is re-authenticated with fresh tokens minted and\n// should be able to perform sensitive operations like account\n// deletion and email or password update.\n// IdP data available in result.additionalUserInfo.profile.\n// OAuth access token can also be retrieved:\n// result.credential.accessToken\n// OAuth ID token can also be retrieved:\n// result.credential.idToken\n})\n.catch((error) => {\n// Handle error.\n});\n```""
 'Q: BatchGetDocumentsResponse에서 반환되는 필드에는 어떤 것들이 있나요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Will only be set in the first response, and only if BatchGetDocumentsRequest.new_transaction was set in the request. |\n| read_time | Timestamp The time at which the document was read. This may be monotically increasing, in this case the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. |\n| Union field result. A single result. This can be empty if the server is just returning a transaction. result can be only one of the following: |\n| found | Document A document that was requested. |\n| missing | string A document name that was requested but does not exist. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}.'
 'Q: Objective-C에서 사용자를 재인증하기 위해 필요한 코드는 무엇인가요?\nA: [[FIRAuth auth].currentUser\nreauthenticateWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\nif (error) {\n// Handle error.\n}\n// User is re-authenticated with fresh tokens minted and\n// should be able to perform sensitive operations like account\n// deletion and email or password update.\n// IdP data available in result.additionalUserInfo.profile.\n// Additional OAuth access token is can also be retrieved by:\n// ((FIROAuthCredential *)authResult.credential).accessToken\n// GitHub OAuth ID token can be retrieved by calling:\n// ((FIROAuthCredential *)authResult.credential).idToken\n}];'
 'Q: Firestore에서 Target을 설정할 때 어떤 필드를 제공해야 하나요?\nA: | Fields |\n| --- |\n| target_id | int32 The target ID that identifies the target on the stream. Must be a positive number and non-zero. If target_id is 0 (or unspecified), the server will assign an ID for this target and return that in a TargetChange::ADD event. Once a target with target_id=0 is added, all subsequent targets must also have target_id=0. If an AddTarget request with target_id != 0 is sent to the server after a target with target_id=0 is added, the server will immediately send a response with a TargetChange::Remove event. Note that if the client sends multiple AddTarget requests without an ID, the order of IDs returned in TargetChange.target_ids are undefined. Therefore, clients should provide a target ID instead of relying on the server to assign one. If target_id is non-zero, there must not be an existing active target on this stream with the same ID. |\n| once | bool If the target should be removed once it is current and consistent. |\n| expected_count | Int32Value The number of documents that last matched the query at the resume token or read time. This value is only relevant when a resume_type is provided. This value being present and greater than zero signals that the client wants ExistenceFilter.unchanged_names to be included in the response. |\n| Union field target_type. The type of target to listen to. target_type can be only one of the following: |\n| query | QueryTarget A target specified by a query. |\n| documents | DocumentsTarget A target specified by a set of document names. |'
 'Q: Firebase에서 Apple 계정과 Facebook 계정을 연결하는 방법은 무엇인가요?\nA: Swift에서 Apple 계정과 Facebook 계정을 연결하려면 다음 코드를 사용하세요:\n```swift\n// Initialize a Facebook credential with Firebase.\nlet credential = FacebookAuthProvider.credential(\n    withAccessToken: AccessToken.current!.tokenString\n)\n// Assuming the current user is an Apple user linking a Facebook provider.\nAuth.auth().currentUser.link(with: credential) { (authResult, error) in\n    // Facebook credential is linked to the current Apple user.\n    // The user can now sign in with Facebook or Apple to the same Firebase\n    // account.\n    // ...\n}\n```'
 'Q: GetDocumentRequest를 사용하여 Firestore에서 문서를 가져올 때 필요한 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to get. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| mask | DocumentMask The fields to return. If not set, returns all fields. If the document has a field that is not present in this mask, that field will not be returned in the response. |\n| Union field consistency_selector. The consistency mode for this transaction. If not set, defaults to strong consistency. consistency_selector can be only one of the following: |\n| transaction | bytes Reads the document in a transaction. |\n| read_time | Timestamp Reads the version of the document at the given time. This must be a microsecond precision timestamp within the past one hour, or if Point-in-Time Recovery is enabled, can additionally be a whole minute timestamp within the past 7 days.'
 'Q: Google 로그인 후 리디렉션 결과를 처리하는 방법은 무엇인가요?\nA: Google 로그인 후 리디렉션 결과를 처리하려면 `getRedirectResult` 메서드를 호출합니다. 아래는 사용 예시입니다.\n\n```javascript\nimport { getAuth, getRedirectResult, GoogleAuthProvider } from ""firebase/auth"";\n\nconst auth = getAuth();\ngetRedirectResult(auth)\n.then((result) => {\n// This gives you a Google Access Token. You can use it to access Google APIs.\nconst credential = GoogleAuthProvider.credentialFromResult(result);\nconst token = credential.accessToken;\n// The signed-in user info.\nconst user = result.user;\n// IdP data available using getAdditionalUserInfo(result)\n// ...\n}).catch((error) => {\n// Handle Errors here.\nconst errorCode = error.code;\n// ...\n});\n```'
 'Q: GetDocumentRequest를 사용하여 Firestore에서 문서를 가져올 때 필요한 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to get. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| mask | DocumentMask The fields to return. If not set, returns all fields. If the document has a field that is not present in this mask, that field will not be returned in the response. |\n| Union field consistency_selector. The consistency mode for this transaction. If not set, defaults to strong consistency. consistency_selector can be only one of the following: |\n| transaction | bytes Reads the document in a transaction. |\n| read_time | Timestamp Reads the version of the document at the given time. This must be a microsecond precision timestamp within the past one hour, or if Point-in-Time Recovery is enabled, can additionally be a whole minute timestamp within the past 7 days. |'
 'Q: 전화번호 인증을 위해 SMS 인증 코드를 전송하는 메서드는 무엇인가요?\nA: 전화번호 인증을 위해 SMS 인증 코드를 전송하려면 PhoneAuthProvider.VerifyPhoneNumber을 호출해야 합니다. 아래는 해당 메서드를 사용하는 예시입니다.\n\n```csharp\nPhoneAuthProvider provider = PhoneAuthProvider.GetInstance(firebaseAuth);\nprovider.VerifyPhoneNumber(\nnew Firebase.Auth.PhoneAuthOptions {\nPhoneNumber = phoneNumber,\nTimeoutInMilliseconds = phoneAuthTimeoutMs,\nForceResendingToken = null\n},\nverificationCompleted: (credential) =&gt {\n// Auto-sms-retrieval or instant validation has succeeded (Android only).\n// There is no need to input the verification code.\n// `credential` can be used instead of calling GetCredential().\n},\nverificationFailed: (error) =&gt {\n// The verification code was not sent.\n// `error` contains a human readable explanation of the problem.\n},\ncodeSent: (id, token) =&gt {\n// Verification code was successfully sent via SMS.\n// `id` contains the verification id that will need to passed in with\n// the code from the user when calling GetCredential().\n// `token` can be used if the user requests the code be sent again, to\n// tie the two requests together.\n},\ncodeAutoRetrievalTimeout: (id) =&gt {\n// Called when the auto-sms-retrieval has timed out, based on the given\n// timeout parameter.\n// `id` contains the verification id of the request that timed out.\n});\n```'
 'Q: readTime 필드에 사용되는 타임스탬프 형식은 무엇인가요?\nA: This must be a microsecond precision timestamp within the past one hour, or if Point-in-Time Recovery is enabled, can additionally be a whole minute timestamp within the past 7 days. Uses RFC 3339, where generated output will always be Z-normalized and use 0, 3, 6 or 9 fractional digits.'
 ""Q: Firebase JavaScript SDK에서 Google 로그인 시 발생할 수 있는 오류를 처리하는 방법은 무엇인가요?\nA: 오류를 처리하려면 `catch` 블록을 사용하여 오류 정보를 확인합니다. 아래는 그 예시입니다.\n\n```javascript\nfirebase.auth()\n.signInWithPopup(provider)\n.then((result) => {\n/** @type {firebase.auth.OAuthCredential} */\nvar credential = result.credential;\n\n// This gives you a Google Access Token. You can use it to access the Google API.\nvar token = credential.accessToken;\n// The signed-in user info.\nvar user = result.user;\n// IdP data available in result.additionalUserInfo.profile.\n// ...\n}).catch((error) => {\n// Handle Errors here.\nvar errorCode = error.code;\nvar errorMessage = error.message;\n// The email of the user's account used.\nvar email = error.email;\n// The firebase.auth.AuthCredential type that was used.\nvar credential = error.credential;\n// ...\n});\n```""
 'Q: Firestore에서 GetDocumentRequest를 사용하여 문서를 가져올 때 어떤 필드를 제공해야 하나요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to get. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| mask | DocumentMask The fields to return. If not set, returns all fields. If the document has a field that is not present in this mask, that field will not be returned in the response. |\n| Union field consistency_selector. The consistency mode for this transaction. If not set, defaults to strong consistency. consistency_selector can be only one of the following: |\n| transaction | bytes Reads the document in a transaction. |\n| read_time | Timestamp Reads the version of the document at the given time. This must be a microsecond precision timestamp within the past one hour, or if Point-in-Time Recovery is enabled, can additionally be a whole minute timestamp within the past 7 days. |'
 'Q: Firebase에서 `linkWithCredential` 메서드를 사용하여 계정을 연결하는 방법은 무엇인가요?\nA: 다음과 같이 `linkWithCredential` 메서드를 사용하여 계정을 연결할 수 있습니다.\n\n```javascript\nimport { getAuth, signInWithCredential, linkWithCredential, OAuthProvider } from ""firebase/auth"";\n\n// The implementation of how you store your user data depends on your application\nconst repo = new MyUserDataRepo();\n\n// Get reference to the currently signed-in user\nconst auth = getAuth();\nconst prevUser = auth.currentUser;\n\n// Get the data which you will want to merge. This should be done now\n// while the app is still signed in as this user.\nconst prevUserData = repo.get(prevUser);\n\n// Delete the user\'s data now, we will restore it if the merge fails\nrepo.delete(prevUser);\n\n// Sign in user with the account you want to link to\nsignInWithCredential(auth, newCredential).then((result) => {\nconsole.log(""Sign In Success"", result);\nconst currentUser = result.user;\nconst currentUserData = repo.get(currentUser);\n\n// Merge prevUser and currentUser data stored in Firebase.\n// Note: How you handle this is specific to your application\nconst mergedData = repo.merge(prevUserData, currentUserData);\n\nconst credential = OAuthProvider.credentialFromResult(result);\nreturn linkWithCredential(prevUser, credential)\n.then((linkResult) => {\n// Sign in with the newly linked credential\nconst linkCredential = OAuthProvider.credentialFromResult(linkResult);\nreturn signInWithCredential(auth, linkCredential);\n})\n.then((signInResult) => {\n// Save the merged data to the new user\nrepo.set(signInResult.user, mergedData);\n});\n}).catch((error) => {\n// If there are errors we want to undo the data merge/deletion\nconsole.log(""Sign In Error"", error);\nrepo.set(prevUser, prevUserData);\n});\n```'
 'Q: GetDocumentRequest를 사용하여 Firestore에서 문서를 가져올 때 필요한 필드는 무엇인가요?\nA: GetDocumentRequest에서 필요한 필드는 다음과 같습니다:\n\n| Fields |\n| --- |\n| name | string Required. The resource name of the Document to get. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| mask | DocumentMask The fields to return. If not set, returns all fields. If the document has a field that is not present in this mask, that field will not be returned in the response. |\n| Union field consistency_selector. The consistency mode for this transaction. If not set, defaults to strong consistency. consistency_selector can be only one of the following: |\n| transaction | bytes Reads the document in a transaction. |\n| read_time | Timestamp Reads the version of the document at the given time. This must be a microsecond precision timestamp within the past one hour, or if Point-in-Time Recovery is enabled, can additionally be a whole minute timestamp within the past 7 days.'
 'Q: Objective-C에서 사용자가 재인증을 수행하는 방법은 무엇인가요?\nA: Objective-C에서 사용자가 재인증을 수행하려면 `reauthenticateWithCredential:completion:` 메서드를 사용합니다. 다음은 예시입니다:\n```objective-c\n[[FIRAuth auth].currentUser\nreauthenticateWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\nif (error) {\n// Handle error.\n}\n// User is re-authenticated with fresh tokens minted and\n// should be able to perform sensitive operations like account\n// deletion and email or password update.\n// IdP data available in result.additionalUserInfo.profile.\n// Additional OAuth access token can also be retrieved:\n// ((FIROAuthCredential *)authResult.credential).accessToken\n// OAuth ID token can also be retrieved:\n// ((FIROAuthCredential *)authResult.credential).idToken\n}];\n```'
 ""Q: Cloud Functions for Firebase가 사용 설정된 프로젝트가 없을 때 어떻게 시작하나요?\nA: Cloud Functions for Firebase가 사용 설정된 프로젝트가 없으면 'Cloud Functions for Firebase(2세대) 시작하기' 문서를 읽고 Cloud Functions for Firebase 프로젝트를 구성 및 설정해야 합니다.""
 'Q: 전화번호 로그인을 시작하기 위해 사용자가 전화번호를 제공하도록 요청하는 방법은 무엇인가요?\nA: 전화번호 로그인을 시작하려면 사용자에게 전화번호를 제공하도록 요청하는 인터페이스를 제시한 다음, PhoneAuthProvider.VerifyPhoneNumber을 호출하여 Firebase가 사용자의 전화에 SMS 인증 코드를 전송하도록 요청합니다. 다음은 코드 예시입니다:\n\n```csharp\nPhoneAuthProvider provider = PhoneAuthProvider.GetInstance(firebaseAuth);\nprovider.VerifyPhoneNumber(\n    new Firebase.Auth.PhoneAuthOptions {\n        PhoneNumber = phoneNumber,\n        TimeoutInMilliseconds = phoneAuthTimeoutMs,\n        ForceResendingToken = null\n    },\n    verificationCompleted: (credential) => {\n        // Auto-sms-retrieval or instant validation has succeeded (Android only).\n        // There is no need to input the verification code.\n        // `credential` can be used instead of calling GetCredential().\n    },\n    verificationFailed: (error) => {\n        // The verification code was not sent.\n        // `error` contains a human readable explanation of the problem.\n    },\n    codeSent: (id, token) => {\n        // Verification code was successfully sent via SMS.\n        // `id` contains the verification id that will need to passed in with\n        // the code from the user when calling GetCredential().\n        // `token` can be used if the user requests the code be sent again, to\n        // tie the two requests together.\n    },\n    codeAutoRetrievalTimeout: (id) => {\n        // Called when the auto-sms-retrieval has timed out, based on the given\n        // timeout parameter.\n        // `id` contains the verification id of the request that timed out.\n    });\n```'
 ""Q: 실시간 데이터베이스에서 접속 상태를 사용하기 위한 기본 코드는 어떻게 되나요?\nA: // Fetch the current user's ID from Firebase Authentication.\nvar uid = firebase.auth().currentUser.uid;\n\n// Create a reference to this user's specific status node.\n// This is where we will store data about being online/offline.\nvar userStatusDatabaseRef = firebase.database().ref('/status/' + uid);\n\n// We'll create two constants which we will write to\n// the Realtime database when this device is offline\n// or online.\nvar isOfflineForDatabase = {\nstate: 'offline',\nlast_changed: firebase.database.ServerValue.TIMESTAMP,\n};\n\nvar isOnlineForDatabase = {\nstate: 'online',\nlast_changed: firebase.database.ServerValue.TIMESTAMP,\n};\n\n// Create a reference to the special '.info/connected' path in\n// Realtime Database. This path returns `true` when connected\n// and `false` when disconnected.""
 'Q: Objective-C에서 Microsoft OAuthProvider의 인스턴스를 사용하여 사용자를 재인증하는 방법은 무엇인가요?\nA: 다음 코드를 사용하여 사용자를 재인증할 수 있습니다.\n\n```objective-c\n[[FIRAuth auth].currentUser\n reauthenticateWithCredential:credential\n completion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\n    if (error) {\n        // Handle error.\n    }\n    // User is re-authenticated with fresh tokens minted and\n    // should be able to perform sensitive operations like account\n    // deletion and email or password update.\n    // IdP data available in result.additionalUserInfo.profile.\n    // Additional OAuth access token can also be retrieved:\n    // ((FIROAuthCredential *)authResult.credential).accessToken\n    // OAuth ID token can also be retrieved:\n    // ((FIROAuthCredential *)authResult.credential).idToken\n}];\n```'
 'Q: BulkDeleteDocumentsMetadata의 snapshotTime 필드는 어떤 형식으로 제공되나요?\nA: snapshotTime | string (Timestamp format) The timestamp that corresponds to the version of the database that is being read to get the list of documents to delete. This time can also be used as the timestamp of PITR in case of disaster recovery (subject to PITR window limit). Uses RFC 3339, where generated output will always be Z-normalized and use 0, 3, 6 or 9 fractional digits. Offsets other than ""Z"" are also accepted. Examples: ""2014-10-02T15:01:23Z"", ""2014-10-02T15:01:23.045123456Z"" or ""2014-10-02T15:01:23+05:30"".'
 'Q: Objective-C에서 사용자를 재인증하는 방법은 무엇인가요?\nA: 다음과 같이 `reauthenticateWithCredential:completion:` 메서드를 사용하여 사용자를 재인증할 수 있습니다.\n\n```objective-c\n[[FIRAuth auth].currentUser reauthenticateWithCredential:credential completion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\n    if (error) {\n        // Handle error.\n    }\n    // User is re-authenticated with fresh tokens minted and\n    // should be able to perform sensitive operations like account\n    // deletion and email or password update.\n    // IdP data available in result.additionalUserInfo.profile.\n    // Additional OAuth access token is can also be retrieved by:\n    // ((FIROAuthCredential *)authResult.credential).accessToken\n    // GitHub OAuth ID token can be retrieved by calling:\n    // ((FIROAuthCredential *)authResult.credential).idToken\n}];\n```'
 'Q: Python에서 Firestore 문서의 실시간 업데이트를 리슨하는 코드는 어떻게 작성하나요?\nA: # Create an Event for notifying main thread.\ncallback_done = threading.Event()\n\n# Create a callback on_snapshot function to capture changes\ndef on_snapshot(doc_snapshot, changes, read_time):\n    for doc in doc_snapshot:\n        print(f""Received document snapshot: {doc.id}"")\n        callback_done.set()\n\ndoc_ref = db.collection(""cities"").document(""SF"")\n\n# Watch the document\ndoc_watch = doc_ref.on_snapshot(on_snapshot)'
 ""Q: Firebase에서 Yahoo 계정으로 재인증을 수행할 때 사용하는 메서드는 무엇인가요?\nA: Firebase에서 Yahoo 계정으로 재인증을 수행할 때는 `reauthenticateWithPopup(provider)` 메서드를 사용합니다. 아래는 예시 코드입니다.\n\n```javascript\nvar provider = new firebase.auth.OAuthProvider('yahoo.com');\nfirebase.auth().currentUser.reauthenticateWithPopup(provider)\n.then((result) => {\n// User is re-authenticated with fresh tokens minted and\n// should be able to perform sensitive operations like account\n// deletion and email or password update.\n// IdP data available in result.additionalUserInfo.profile.\n// Yahoo OAuth access token can be retrieved by calling:\n// result.credential.accessToken\n// Yahoo OAuth ID token can be retrieved by calling:\n// result.credential.idToken\n})\n.catch((error) => {\n// Handle error.\n});\n```""
 'Q: RunAggregationQueryResponse에서 어떤 정보를 확인할 수 있나요?\nA: | Fields |\n| --- |\n| result | AggregationResult A single aggregation result. Not present when reporting partial progress. |\n| transaction | bytes The transaction that was started as part of this request. Only present on the first response when the request requested to start a new transaction. |\n| read_time | Timestamp The time at which the aggregate result was computed. This is always monotonically increasing; in this case, the previous AggregationResult in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no result will be sent, and this represents the time at which the query was run. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunAggregationQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |'
 'Q: 인증 코드가 성공적으로 전송되었는지 확인하는 방법은 무엇인가요?\nA: 인증 코드가 성공적으로 전송되었는지 확인하려면 codeSent 콜백을 사용해야 합니다. 이 콜백이 호출되면 인증 코드가 SMS로 성공적으로 전송된 것입니다. 아래는 해당 콜백의 예시입니다.\n\n```csharp\ncodeSent: (id, token) =&gt {\n// Verification code was successfully sent via SMS.\n// `id` contains the verification id that will need to passed in with\n// the code from the user when calling GetCredential().\n// `token` can be used if the user requests the code be sent again, to\n// tie the two requests together.\n},\n```']","Cloud Firestore에서 문서가 변경될 때마다 자동으로 실행되는 함수를 작성하려면 `firebase-functions` 라이브러리를 사용하여 Firestore 이벤트 트리거를 설정할 수 있습니다. 다음은 Node.js와 Python에서 문서의 모든 변경사항에 대해 트리거되는 함수의 예시입니다.

### Node.js 예시
```javascript
const {
  onDocumentWritten,
  Change,
  FirestoreEvent
} = require('firebase-functions/v2/firestore');

exports.modifyuser = onDocumentWritten(""users/{userId}"", (event) => {
  // Get an object with the current document values.
  // If the document does not exist, it was deleted
  const document = event.data.after.data();

  // Get an object with the previous document values
  const previousValues = event.data.before.data();

  // perform more operations ...
});
```

### Python 예시
```python
from firebase_functions.firestore_fn import (
  on_document_written,
  Event,
  Change,
  DocumentSnapshot,
)

@on_document_written(document=""users/{userId}"")
def myfunction(event: Event[Change[DocumentSnapshot | None]]) -> None:
  # Get an object with the current document values.
  # If the document does not exist, it was deleted.
  document = (event.data.after.to_dict()
              if event.data.after is not None else None)

  # Get an object with the previous document values.
  # If the document does not exist, it was newly created.
  previous_values = (event.data.before.to_dict()
                     if event.data.before is not None else None)

  # Perform more operations ...
```

이 예시들은 Firestore의 특정 문서 경로에서 문서가 생성, 업데이트 또는 삭제될 때마다 함수를 트리거합니다. `onDocumentWritten` 또는 `on_document_written` 함수를 사용하여 이러한 이벤트를 처리할 수 있습니다.","Cloud Firestore에서 특정 문서의 모든 변경에 이벤트를 트리거하려면 onDocumentWritten 함수를 사용해야 합니다. 예시는 다음과 같습니다.

from firebase_functions.firestore_fn import (
    on_document_written,
    Event,
    Change,
    DocumentSnapshot,
)

@on_document_written(document=""users/marie"")
def myfunction(event: Event[Change[DocumentSnapshot]]) -> None:
    # Get an object with the current document values.
    # If the document does not exist, it was deleted.
    document = (event.data.after.to_dict()
                if event.data.after is not None else None)

    # Get an object with the previous document values.
    # If the document does not exist, it was newly created.
    previous_values = (event.data.before.to_dict()
                       if event.data.before is not None else None)

    # Perform more operations ..."
"Firebase에서 다단계 인증(MFA)을 사용할 때 Objective-C로 사용자 인증을 완료하는 방법과 관련된 코드 예시가 궁금합니다. 어떤 방식으로 인증 정보를 가져오고, Objective-C에서는 어떻게 구현하나요?","['Firebase Authentication with Identity Platform으로 업그레이드했다면 웹 앱에 SMS 다중 인증(MFA)을 추가할 수 있습니다.\n\n다중 인증(MFA)을 통해 앱의 보안이 강화됩니다. 공격자는 종종 비밀번호와 소셜 미디어 계정을 유출시키지만 문자 메시지를 가로채는 것은 더 어렵습니다.\n\n시작하기 전에\n\n다중 인증(MFA)을 지원하는 제공업체를 하나 이상 사용 설정합니다.\n전화 인증, 익명 인증, Apple Game Center를 제외한 모든 제공업체는 MFA를 지원합니다.\nSMS 인증을 사용할 리전을 사용 설정합니다.\nFirebase는 기본적으로 더 안전한 상태로 프로젝트를 만드는 데 도움이 되는 SMS 완전 차단 리전 정책을 사용합니다.\n앱이 사용자 이메일을 확인하고 있는지 확인합니다. MFA를 사용하려면 이메일 인증이 필요합니다.\n이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일에 서비스를 등록한 후 두 번째 단계를 추가하여 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.\n\n멀티테넌시 사용\n\n멀티 테넌트 [https://cloud.google.com/identity-platform/docs/multi-tenancy?hl=ko] 환경에서 사용하기 위해 다단계 인증을 사용 설정하는 경우 이 도움말의 나머지 안내와 함께 다음 단계를 완료해야 합니다.\n\nGoogle Cloud 콘솔에서 작업할 테넌트를 선택합니다.\n코드에서 Auth 인스턴스의 tenantId 필드를 테넌트의 ID로 설정합니다. 예를 들면 다음과 같습니다.\n\n--- 탭: Web [https://firebase.google.com/docs/auth/web/multi-factor?hl=ko#web-modular-api] ---\n```\nimport { getAuth } from ""firebase/auth"";\n\nconst auth = getAuth(app);\nauth.tenantId = ""myTenantId1"";\n```\n\n--- 탭: Web [https://firebase.google.com/docs/auth/web/multi-factor?hl=ko#web-namespaced-api] ---\n```\nfirebase.auth().tenantId = \'myTenantId1\';\n```\n\n다중 인증(MFA) 사용 설정'
 '--- 탭: Objective-C [https://firebase.google.com/docs/auth/ios/google-signin?hl=ko#objective-c] ---\n[[FIRAuth auth] signInWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult,\nNSError * _Nullable error) {\nif (isMFAEnabled && error && error.code == FIRAuthErrorCodeSecondFactorRequired) {\nFIRMultiFactorResolver *resolver = error.userInfo[FIRAuthErrorUserInfoMultiFactorResolverKey];\nNSMutableString *displayNameString = [NSMutableString string];\nfor (FIRMultiFactorInfo *tmpFactorInfo in resolver.hints) {\n[displayNameString appendString:tmpFactorInfo.displayName];\n[displayNameString appendString:@"" ""];\n}\n[self showTextInputPromptWithMessage:[NSString stringWithFormat:@""Select factor to sign in\\n%@"", displayNameString]\ncompletionBlock:^(BOOL userPressedOK, NSString *_Nullable displayName) {\nFIRPhoneMultiFactorInfo* selectedHint;\nfor (FIRMultiFactorInfo *tmpFactorInfo in resolver.hints) {\nif ([displayName isEqualToString:tmpFactorInfo.displayName]) {\nselectedHint = (FIRPhoneMultiFactorInfo *)tmpFactorInfo;\n}\n}\n[FIRPhoneAuthProvider.provider\nverifyPhoneNumberWithMultiFactorInfo:selectedHint\nUIDelegate:nil\nmultiFactorSession:resolver.session'
 ""Firebase Authentication with Identity Platform으로 업그레이드했다면 시간 기반 일회용 비밀번호(TOTP) 다중 인증(MFA)을 앱에 추가할 수 있습니다.\n\nFirebase Authentication with Identity Platform을 사용하면 TOTP를 MFA의 추가 요소로 사용할 수 있습니다. 이 기능을 사용 설정하면 앱에 로그인하려는 사용자에게 TOTP 요청이 표시됩니다. 이를 생성하려면 Google OTP [https://support.google.com/accounts/answer/1066447?hl=ko]와 같이 유효한 TOTP 코드를 생성할 수 있는 OTP 앱을 사용해야 합니다.\n\n시작하기 전에\n\nMFA를 지원하는 하나 이상의 제공업체를 사용 설정하세요. 다음을 제외한 모든 제공업체는 MFA를 지원합니다.\n\n전화 인증\n익명 인증\n커스텀 인증 토큰\nApple Game Center\n\n앱에서 사용자 이메일 주소를 인증해야 합니다. MFA를 사용하려면 이메일 인증이 필요합니다. 이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일 주소에 서비스를 등록한 후 두 번째 단계를 추가하여 이메일 주소의 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.\n\n아직 설치하지 않았다면 Firebase JavaScript SDK [https://firebase.google.com/docs/web/setup?hl=ko]를 설치합니다.\n\nTOTP MFA는 모듈식 웹 SDK 버전 v9.19.1 이상에서만 지원됩니다.\n\nTOTP MFA 사용 설정\n\nTOTP를 두 번째 단계로 사용 설정하려면 Admin SDK를 사용하거나 프로젝트 구성 REST 엔드포인트를 호출합니다.\n\nAdmin SDK를 사용하려면 다음 단계를 따르세요.\n\n아직 설치하지 않았다면 Firebase Admin Node.js SDK [https://firebase.google.com/docs/admin/setup?hl=ko]를 설치합니다.\n\nTOTP MFA는 Firebase Admin Node.js SDK 버전 11.6.0 이상에서만 지원됩니다.\n다음을 실행합니다.\nimport { getAuth } from 'firebase-admin/auth';""
 ""Firebase Authentication with Identity Platform으로 업그레이드했다면 시간 기반 일회용 비밀번호(TOTP) 다중 인증(MFA)을 앱에 추가할 수 있습니다.\n\nFirebase Authentication with Identity Platform을 사용하면 TOTP를 MFA의 추가 요소로 사용할 수 있습니다. 이 기능을 사용 설정하면 앱에 로그인하려는 사용자에게 TOTP 요청이 표시됩니다. 이를 생성하려면 Google OTP [https://support.google.com/accounts/answer/1066447?hl=ko]와 같이 유효한 TOTP 코드를 생성할 수 있는 OTP 앱을 사용해야 합니다.\n\n시작하기 전에\n\nMFA를 지원하는 하나 이상의 제공업체를 사용 설정하세요. 다음을 제외한 모든 제공업체는 MFA를 지원합니다.\n\n전화 인증\n익명 인증\n커스텀 인증 토큰\nApple Game Center\n\n앱에서 사용자 이메일 주소를 인증해야 합니다. MFA를 사용하려면 이메일 인증이 필요합니다. 이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일 주소에 서비스를 등록한 후 두 번째 단계를 추가하여 이메일 주소의 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.\n\n아직 설치하지 않았다면 Firebase Apple SDK [https://firebase.google.com/docs/ios/setup?hl=ko]를 설치합니다.\n\nTOTP MFA는 Apple SDK 버전 v10.12.0 [https://firebase.google.com/support/release-notes/ios?hl=ko#authentication_5] 이상 및 iOS에서만 지원됩니다.\n\nTOTP MFA 사용 설정\n\nTOTP를 두 번째 단계로 사용 설정하려면 Admin SDK를 사용하거나 프로젝트 구성 REST 엔드포인트를 호출합니다.\n\nAdmin SDK를 사용하려면 다음 단계를 따르세요.\n\n아직 설치하지 않았다면 Firebase Admin Node.js SDK [https://firebase.google.com/docs/admin/setup?hl=ko]를 설치합니다.\n\nTOTP MFA는 Firebase Admin Node.js SDK 버전 11.6.0 이상에서만 지원됩니다.\n다음을 실행합니다.\nimport { getAuth } from 'firebase-admin/auth';""
 ""Firebase Authentication with Identity Platform으로 업그레이드했다면 시간 기반 일회용 비밀번호(TOTP) 다중 인증(MFA)을 앱에 추가할 수 있습니다.\n\nFirebase Authentication with Identity Platform을 사용하면 TOTP를 MFA의 추가 요소로 사용할 수 있습니다. 이 기능을 사용 설정하면 앱에 로그인하려는 사용자에게 TOTP 요청이 표시됩니다. 이를 생성하려면 Google OTP [https://support.google.com/accounts/answer/1066447?hl=ko]와 같이 유효한 TOTP 코드를 생성할 수 있는 OTP 앱을 사용해야 합니다.\n\n시작하기 전에\n\nMFA를 지원하는 하나 이상의 제공업체를 사용 설정하세요. 다음을 제외한 모든 제공업체는 MFA를 지원합니다.\n\n전화 인증\n익명 인증\n커스텀 인증 토큰\nApple Game Center\n\n앱에서 사용자 이메일 주소를 인증해야 합니다. MFA를 사용하려면 이메일 인증이 필요합니다. 이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일 주소에 서비스를 등록한 후 두 번째 단계를 추가하여 이메일 주소의 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.\n\n아직 설치하지 않았다면 Firebase Android SDK [https://firebase.google.com/docs/android/setup?hl=ko]를 설치합니다.\n\nTOTP MFA는 Android SDK 버전 v22.1.0 [https://firebase.google.com/support/release-notes/android?hl=ko#auth_v22-1-0] 이상에서만 지원됩니다.\n\nTOTP MFA 사용 설정\n\nTOTP를 두 번째 단계로 사용 설정하려면 Admin SDK를 사용하거나 프로젝트 구성 REST 엔드포인트를 호출합니다.\n\nAdmin SDK를 사용하려면 다음 단계를 따르세요.\n\n아직 설치하지 않았다면 Firebase Admin Node.js SDK [https://firebase.google.com/docs/admin/setup?hl=ko]를 설치합니다.\n\nTOTP MFA는 Firebase Admin Node.js SDK 버전 11.6.0 이상에서만 지원됩니다.\n다음을 실행합니다.\nimport { getAuth } from 'firebase-admin/auth';""
 'Source URL: https://firebase.google.com/docs/auth/web/manage-users?hl=ko\nTitle: Firebase에서 사용자 관리하기\nbookmark_border\n\n의견 보내기\n\nFirebase에서 사용자 관리하기\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지의 내용사용자 생성현재 로그인한 사용자 가져오기사용자 프로필 가져오기제공업체별 사용자 프로필 정보 가져오기사용자 프로필 업데이트사용자 이메일 주소 설정사용자에게 인증 메일 보내기사용자 비밀번호 설정비밀번호 재설정 이메일 보내기사용자 삭제하기사용자 재인증하기사용자 계정 가져오기\n\n사용자 생성\n\nFirebase 프로젝트에서 신규 사용자를 생성할 때는 createUserWithEmailAndPassword [https://firebase.google.com/docs/auth/web/password-auth?hl=ko#create_a_password-based_account] 메서드를 호출하는 방법과 Google 로그인 [https://firebase.google.com/docs/auth/web/google-signin?hl=ko] 또는 Facebook 로그인 [https://firebase.google.com/docs/auth/web/facebook-login?hl=ko]과 같은 제휴 ID 공급업체를 이용해 사용자의 최초 로그인을 처리하는 방법이 있습니다.\n\n또한 Firebase Console [https://console.firebase.google.com/?hl=ko] \'인증\' 섹션의 \'사용자\' 페이지에서 또는 Admin SDK [https://firebase.google.com/docs/auth/admin/manage-users?hl=ko#create_a_user]를 활용하여 비밀번호 인증을 사용하는 신규 사용자를 생성할 수 있습니다.\n\n현재 로그인한 사용자 가져오기\n\n현재 사용자를 가져올 때 권장하는 방법은 다음과 같이 Auth 개체에 관찰자를 설정하는 것입니다.\n\n--- 탭: Web ---\nimport { getAuth, onAuthStateChanged } from ""firebase/auth"";'
 ""시작하기 전에\n\nNode.js Admin SDK를 설치합니다 [https://firebase.google.com/docs/admin/setup?hl=ko]. 다른 Admin SDK 언어는 현재 지원되지 않습니다.\n\n사용자 가져오기\n\nUserRecord 객체에서 등록된 두 번째 단계 목록과 같은 사용자의 다단계 관련 데이터를 검색할 수 있습니다. 사용자 레코드를 가져오려면 getUser() 또는 getUserByEmail()을 호출합니다.\n\n아래 예시는 다단계 등록 사용자를 보여줍니다.\n// console.log(userRecord.toJSON());\n{\nuid: 'some-uid',\ndisplayName: 'John Doe',\nemail: 'johndoe@gmail.com',\nphotoURL: 'http://www.example.com/12345678/photo.png',\nemailVerified: true,\nphoneNumber: '+11234567890',\n// Set this user as admin.\ncustomClaims: {admin: true},\n// User with Google provider.\nproviderData: [{\nuid: 'google-uid',\nemail: 'johndoe@gmail.com',\ndisplayName: 'John Doe',\nphotoURL: 'http://www.example.com/12345678/photo.png',\nproviderId: 'google.com'\n}],\nmultiFactor: {\nenrolledFactors: [\n// 2FA with SMS as 2nd factor.\n{\nuid: '53HG4HG45HG8G04GJ40J4G3J',\nphoneNumber: '+16505551234',\ndisplayName: 'Work phone',\nenrollmentTime: 'Fri, 22 Sep 2017 01:49:58 GMT',\nfactorId: 'phone',\n},\n],\n},\n};\n\n사용자 나열""
 '다음을 바꿉니다.\n\nPROJECT_ID: 프로젝트 ID\nNUM_ADJ_INTERVALS: 기간 간격(0~10). 기본값은 5입니다.\n\nTOTP는 두 당사자(증명자 및 검사자)가 동일한 기간(일반적으로 30초) 내에 OTP를 생성할 때 동일한 비밀번호를 생성하도록 하는 방식으로 작동합니다. 그러나 당사자 간의 클럭 드리프트와 사람의 응답 시간을 수용하기 위해 TOTP 서비스가 인접한 기간의 TOTP도 허용하도록 구성할 수 있습니다.\n\n등록 패턴 선택\n\n앱에 다중 인증(MFA)이 필요한지 여부 및 사용자 등록 방법과 시기를 선택할 수 있습니다. 몇몇 일반적인 패턴은 다음과 같습니다.\n\n등록 시 사용자의 두 번째 단계를 등록합니다. 앱이 모든 사용자에게 다중 인증(MFA)을 요구한다면 이 방법을 사용하세요.\n등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공하세요. 앱에서 다중 인증(MFA)을 권장하지만 필수가 아니라면 이 방법을 사용할 수 있습니다.\n가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다. 이렇게 하면 등록 프로세스 중에 발생하는 마찰을 최소화하면서도 보안에 민감한 사용자에게 다중 인증(MFA)을 제공할 수 있습니다.\n사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 두 번째 단계를 점진적으로 추가하도록 합니다.\n\nTOTP MFA에 사용자 등록\n\n앱의 두 번째 단계로 TOTP MFA를 사용 설정한 후 사용자를 TOTP MFA에 등록하도록 클라이언트 측 로직을 구현합니다.\n\n사용자를 다시 인증합니다.\n인증된 사용자의 TOTP 보안 비밀을 생성합니다.\n// Generate a TOTP secret.\nFirebase.auth.currentUser.multiFactor.session\n.addOnSuccessListener { multiFactorSession ->\nTotpMultiFactorGenerator.generateSecret(multiFactorSession)\n.addOnSuccessListener { totpSecret ->\n// Display the secret to the user and prompt them to\n// enter it into their authenticator app. (See the next\n// step.)\n}\n}'
 '다음을 바꿉니다.\n\nPROJECT_ID: 프로젝트 ID\nNUM_ADJ_INTERVALS: 기간 간격(0~10). 기본값은 5입니다.\n\nTOTP는 두 당사자(증명자 및 검사자)가 동일한 기간(일반적으로 30초) 내에 OTP를 생성할 때 동일한 비밀번호를 생성하도록 하는 방식으로 작동합니다. 그러나 당사자 간의 클럭 드리프트와 사람의 응답 시간을 수용하기 위해 TOTP 서비스가 인접한 기간의 TOTP도 허용하도록 구성할 수 있습니다.\n\n등록 패턴 선택\n\n앱에 다중 인증(MFA)이 필요한지 여부 및 사용자 등록 방법과 시기를 선택할 수 있습니다. 몇몇 일반적인 패턴은 다음과 같습니다.\n\n등록 시 사용자의 두 번째 단계를 등록합니다. 앱이 모든 사용자에게 다중 인증(MFA)을 요구한다면 이 방법을 사용하세요.\n등록 시 건너뛸 수 있는 옵션으로 두 번째 단계를 등록하는 옵션을 제공하세요. 앱에서 다중 인증(MFA)을 권장하지만 필수가 아니라면 이 방법을 사용할 수 있습니다.\n가입 화면이 아닌 사용자의 계정 또는 프로필 관리 페이지에서 두 번째 단계를 추가할 수 있도록 합니다. 이렇게 하면 등록 프로세스 중에 발생하는 마찰을 최소화하면서도 보안에 민감한 사용자에게 다중 인증(MFA)을 제공할 수 있습니다.\n사용자가 보안 요구사항이 향상된 기능에 액세스하려고 할 때 두 번째 단계를 점진적으로 추가하도록 합니다.\n\nTOTP MFA에 사용자 등록\n\n앱의 두 번째 단계로 TOTP MFA를 사용 설정한 후 사용자를 TOTP MFA에 등록하도록 클라이언트 측 로직을 구현합니다.\n\n필요한 MFA 클래스와 함수를 가져옵니다.\nimport {\nmultiFactor,\nTotpMultiFactorGenerator,\nTotpSecret,\ngetAuth,\n} from ""firebase/auth"";\n\n사용자를 다시 인증합니다.\n인증된 사용자의 TOTP 보안 비밀을 생성합니다.\n// Generate a TOTP secret.\nconst multiFactorSession = await multiFactor(currentUser).getSession();\nconst totpSecret = await TotpMultiFactorGenerator.generateSecret(\nmultiFactorSession\n);\n\n보안 비밀을 사용자에게 표시하고 OTP 앱에 입력하라는 메시지를 표시합니다.'
 'FirebaseUI 인증 SDK에는 Firebase SDK 및 Google Play 서비스 SDK의 임시\n종속 항목이 있습니다.\nFirebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고 지원할 로그인 방법을 사용 설정합니다. 일부 로그인 방법은 추가 정보가 필요하며 대개 해당 서비스의 개발자 콘솔에서 확인할 수 있습니다.\nGoogle 로그인을 사용 설정한 경우:\n\n콘솔에 메시지가 표시되면 업데이트된 Firebase 구성 파일(google-services.json)을 다운로드합니다. 여기에 Google 로그인에 필요한 OAuth 클라이언트 정보가 들어 있습니다.\n업데이트된 구성 파일을 Android 스튜디오 프로젝트로 이동하여 기존의 오래된 구성 파일을 교체합니다.\n(Android 프로젝트에 Firebase 추가 [https://firebase.google.com/docs/android/setup?hl=ko#add-config-file]를 참조하세요.)\n아직 앱의 SHA-1 디지털 지문을 지정하지 않았다면 Firebase Console의 설정 페이지 [https://console.firebase.google.com/project/_/settings/general/?hl=ko]에서 지정합니다.\n앱의 SHA 지문을 가져오는 자세한 방법은 클라이언트 인증 [https://developers.google.com/android/guides/client-auth?hl=ko]을 참조하세요.\n\nFacebook 또는 트위터 로그인을 지원하는 경우 strings.xml에 각 제공업체에서 요구하는 식별 정보를 지정하는 문자열 리소스를 추가합니다.\n\n<resources>\n<!-- Facebook application ID and custom URL scheme (app ID prefixed by \'fb\'). -->\n<string name=""facebook_application_id"" translatable=""false"">YOUR_APP_ID</string>\n<string name=""facebook_login_protocol_scheme"" translatable=""false"">fbYOUR_APP_ID</string>\n</resources>\n\n로그인\n\nFirebaseUI 활동 결과 계약의 콜백을 등록하는 ActivityResultLauncher를 만듭니다.'
 'Source URL: https://firebase.google.com/docs/auth/web/multi-factor?hl=ko\nTitle: 웹 앱에 다중 인증(MFA) 추가\nbookmark_border\n\n의견 보내기\n\n웹 앱에 다중 인증(MFA) 추가\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.'
 '시작하기 전에\n참고: Windows 플랫폼은 다중 인증(MFA)을 지원하지 않습니다. 어떤 플랫폼에서든 여러 테넌트 [https://cloud.google.com/identity-platform/docs/multi-tenancy?hl=ko]에서 다중 인증(MFA) 사용은 Flutter에서 지원되지 않습니다.\n\n다중 인증(MFA)을 지원하는 제공업체를 하나 이상 사용 설정합니다.\n전화 인증, 익명 인증, Apple Game Center를 제외한 모든 제공업체는 MFA를 지원합니다.\n앱이 사용자 이메일을 확인하고 있는지 확인합니다. MFA를 사용하려면 이메일 인증이 필요합니다.\n이를 통해 악의적인 행위자가 자신이 소유하지 않은 이메일에 서비스를 등록한 후 두 번째 단계를 추가하여 실제 소유자의 접근을 막는 일을 방지할 수 있습니다.\nAndroid: Firebase Console [https://console.firebase.google.com/?hl=ko]에서 앱의 SHA-256 해시를 아직 설정하지 않았다면 지금 설정합니다. 앱의 SHA-256 해시를 찾는 방법은 클라이언트 인증 [https://developers.google.com/android/guides/client-auth?hl=ko]을 참조하세요.\niOS: Xcode에서 프로젝트에 푸시 알림을 사용 설정 [http://help.apple.com/xcode/mac/current/#/devdfd3d04a1]하고 APN 인증 키가 Firebase 클라우드 메시징(FCM)으로 구성 [https://firebase.google.com/docs/cloud-messaging/ios/certs?hl=ko]되었는지 확인합니다. 또한 원격 알림에 백그라운드 모드를 사용 설정 [https://help.apple.com/xcode/mac/current/#/deve49d0ba96]해야 합니다.\n이 단계에 대한 자세한 설명은 Firebase iOS 전화 인증 [https://firebase.google.com/docs/auth/ios/phone-auth?hl=ko] 문서를 참조하세요.\n웹: Firebase Console [https://console.firebase.google.com/?hl=ko]의 OAuth 리디렉션 도메인에서 애플리케이션 도메인을 추가했는지 확인합니다.\n\n다중 인증(MFA) 사용 설정'
 'Source URL: https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko\nTitle: 다단계 사용자 관리\nbookmark_border\n\n의견 보내기\n\n다단계 사용자 관리\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지의 내용시작하기 전에 [https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko#before_you_begin]사용자 가져오기 [https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko#getting_users]사용자 나열 [https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko#listing_users]사용자 만들기 [https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko#creating_a_user]사용자 업데이트 [https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko#updating_a_user]새 보조 단계 추가 [https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko#adding_a_new_secondary_factor]보조 단계 삭제 [https://firebase.google.com/docs/auth/admin/manage-mfa-users?hl=ko#removing_a_secondary_factor]\n\n이 문서에서는 Firebase Admin SDK를 사용하여 다중 인증 사용자를 프로그래매틱 방식으로 관리하는 방법을 보여줍니다. 다중 인증 사용자를 관리할 때는 1단계 사용자 [https://firebase.google.com/docs/auth/admin/manage-users?hl=ko]에 비해 더 많은 사용자 속성에 액세스할 수 있습니다.\n\n시작하기 전에\n\nNode.js Admin SDK를 설치합니다 [https://firebase.google.com/docs/admin/setup?hl=ko]. 다른 Admin SDK 언어는 현재 지원되지 않습니다.'
 'Source URL: https://firebase.google.com/docs/auth/android/multi-factor?hl=ko\nTitle: Android 앱에 다중 인증(MFA) 추가\nbookmark_border\n\n의견 보내기\n\nAndroid 앱에 다중 인증(MFA) 추가\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지의 내용시작하기 전에 [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#before_you_begin]다중 인증(MFA) 사용 설정 [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#enabling_multi-factor_authentication]등록 패턴 선택 [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#choosing_an_enrollment_pattern]두 번째 단계 등록 [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#enrolling_a_second_factor]두 번째 단계 인증으로 사용자 로그인 처리 [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#signing_users_in_with_a_second_factor]다음 단계 [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#whats_next]\n\nFirebase Authentication with Identity Platform으로 업그레이드했다면 Android 앱에 SMS 다중 인증(MFA)을 추가할 수 있습니다.\n\n다중 인증(MFA)을 통해 앱의 보안이 강화됩니다. 공격자는 종종 비밀번호와 소셜 미디어 계정을 유출시키지만 문자 메시지를 가로채는 것은 더 어렵습니다.'
 'function handleIframeMessage({data}) {\ntry {\nif (data.startsWith(\'!_{\')) {\n// Other parts of the Firebase library send messages using postMessage.\n// You don\'t care about them in this context, so return early.\nreturn;\n}\ndata = JSON.parse(data);\nself.removeEventListener(\'message\', handleIframeMessage);\n\nsendResponse(data);\n} catch (e) {\nconsole.log(`json parse failed - ${e.message}`);\n}\n}\n\nglobalThis.addEventListener(\'message\', handleIframeMessage, false);\n\n// Initialize the authentication flow in the iframed document. You must set the\n// second argument (targetOrigin) of the message in order for it to be successfully\n// delivered.\niframe.contentWindow.postMessage({""initAuth"": true}, new URL(_URL).origin);\nreturn true;\n}\n\nbackground.js 서비스 워커에서 오프스크린 문서를 설정합니다.\n\nconst OFFSCREEN_DOCUMENT_PATH = \'/offscreen.html\';\n\n// A global promise to avoid concurrency issues\nlet creatingOffscreenDocument;'
 ""기본적으로 이메일 주소당 계정 1개가 사용 설정되어 있으면 Firebase는 이메일 및 이름 범위를 요청합니다. 이 설정을 이메일 주소당 여러 계정으로 변경하면 별도로 지정하지 않는 한 Firebase는 Apple에 범위를 요청하지 않습니다.\n선택사항: Apple의 로그인 화면을 영어가 아닌 다른 언어로 표시하려면 locale 매개변수를 설정하세요. 지원되는 언어는 Apple로 로그인 문서 [https://developer.apple.com/documentation/signinwithapplejs/incorporating_sign_in_with_apple_into_other_platforms#3332112]를 참조하세요.\n\n--- 탭: Web [https://firebase.google.com/docs/auth/web/apple?hl=ko#web-modular-api] ---\nprovider.setCustomParameters({\n// Localize the Apple authentication screen in French.\nlocale: 'fr'\n});\nauth_apple_provider_params.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/snippets/auth-next/apple/auth_apple_provider_params.js#L8-L11]\n\n--- 탭: Web [https://firebase.google.com/docs/auth/web/apple?hl=ko#web-namespaced-api] ---\nprovider.setCustomParameters({\n// Localize the Apple authentication screen in French.\nlocale: 'fr'\n});\napple.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/auth/apple.js#L20-L23]\n\nOAuth 제공업체 객체를 사용해 Firebase로 인증합니다. 팝업 창을 띄우거나 로그인 페이지로 리디렉션하여 사용자가 Apple 계정에 로그인하도록 유도할 수 있습니다. 휴대기기의 경우 리디렉션을 사용할 것을 권장합니다.""
 'override fun onVerificationFailed(e: FirebaseException) {\n// This callback is invoked in response to invalid requests for\n// verification, like an incorrect phone number.\nif (e is FirebaseAuthInvalidCredentialsException) {\n// Invalid request\n// ...\n} else if (e is FirebaseTooManyRequestsException) {\n// The SMS quota for the project has been exceeded\n// ...\n}\n// Show a message and update the UI\n// ...\n}\n\noverride fun onCodeSent(\nverificationId: String, forceResendingToken: ForceResendingToken\n) {\n// The SMS verification code has been sent to the provided phone number.\n// We now need to ask the user to enter the code and then construct a\n// credential by combining the code with a verification ID.\n// Save the verification ID and resending token for later use.\nthis@MainActivity.verificationId = verificationId\nthis@MainActivity.forceResendingToken = forceResendingToken\n// ...\n}\n}\n```'
 '--- 탭: Java [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#java-android] ---\n```\nFirebaseAuth.getInstance()\n.signInWithEmailAndPassword(email, password)\n.addOnCompleteListener(\nnew OnCompleteListener<AuthResult>() {\n@Override\npublic void onComplete(@NonNull Task<AuthResult> task) {\nif (task.isSuccessful()) {\n// User is not enrolled with a second factor and is successfully\n// signed in.\n// ...\nreturn;\n}\nif (task.getException() instanceof FirebaseAuthMultiFactorException) {\n// The user is a multi-factor user. Second factor challenge is\n// required.\nMultiFactorResolver multiFactorResolver = task.getException().getResolver();\n// ...\n} else {\n// Handle other errors such as wrong password.\n}\n}\n});\n```\n사용자의 첫 번째 단계가 OAuth와 같은 제휴 공급업체인 경우 startActivityForSignInWithProvider() 호출 후 오류를 포착합니다.\n사용자가 보조 단계를 여러 개 등록한 경우 어떤 단계를 사용할지 질문합니다.\n\n--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/multi-factor?hl=ko#kotlin-android] ---\n```\n// Ask user which second factor to use.\n// You can get the list of enrolled second factors using\n//   multiFactorResolver.hints'
 ""아래 코드는 다중 인증 사용자를 위한 전체 로그인 예시를 보여줍니다.\ntry {\nawait _auth.signInWithEmailAndPassword(\nemail: emailController.text,\npassword: passwordController.text,\n);\n} on FirebaseAuthMultiFactorException catch (e) {\nsetState(() {\nerror = '${e.message}';\n});\nfinal firstHint = e.resolver.hints.first;\nif (firstHint is! PhoneMultiFactorInfo) {\nreturn;\n}\nawait FirebaseAuth.instance.verifyPhoneNumber(\nmultiFactorSession: e.resolver.session,\nmultiFactorInfo: firstHint,\nverificationCompleted: (_) {},\nverificationFailed: (_) {},\ncodeSent: (String verificationId, int? resendToken) async {\n// See `firebase_auth` example app for a method of retrieving user's sms code:\n// https://github.com/firebase/flutterfire/blob/main/packages/firebase_auth/firebase_auth/example/lib/auth.dart#L591\nfinal smsCode = await getSmsCodeFromUser(context);\n\nif (smsCode != null) {\n// Create a PhoneAuthCredential with the code\nfinal credential = PhoneAuthProvider.credential(\nverificationId: verificationId,\nsmsCode: smsCode,\n);""
 '--- 탭: Objective-C [https://firebase.google.com/docs/auth/ios/microsoft-oauth?hl=ko#objective-c] ---\n[[FIRAuth auth].currentUser\nreauthenticateWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {\nif (error) {\n// Handle error.\n}\n// User is re-authenticated with fresh tokens minted and\n// should be able to perform sensitive operations like account\n// deletion and email or password update.\n// IdP data available in result.additionalUserInfo.profile.\n// Additional OAuth access token can also be retrieved:\n// ((FIROAuthCredential *)authResult.credential).accessToken\n// OAuth ID token can also be retrieved:\n// ((FIROAuthCredential *)authResult.credential).idToken\n}];\n\naccount-exists-with-different-credential 오류 처리\n\nFirebase Console [https://console.firebase.google.com/?hl=ko]에서 이메일 주소당 계정 1개를 사용 설정한 경우 다른 Firebase 사용자의 제공업체(예: Google)에 이미 존재하는 이메일을 사용하여 Microsoft와 같은 제공업체에 로그인을 시도하면 임시 FIRAuthCredential 객체(Microsoft 사용자 인증 정보)와 함께 FIRAuthErrorCodeAccountExistsWithDifferentCredential 오류가 발생합니다. 사용자가 원하는 제공업체에 로그인하려면 먼저 기존 제공업체(예: Google)에 로그인한 다음 신규 제공업체의 FIRAuthCredential(Microsoft 사용자 인증 정보)에 연결해야 합니다. 그 방법은 아래와 같습니다.'
 '// Create and launch sign-in intent\nval signInIntent = AuthUI.getInstance()\n.createSignInIntentBuilder()\n.setAvailableProviders(providers)\n.build()\nsignInLauncher.launch(signInIntent)\nFirebaseUIActivity.kt [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/auth/app/src/main/java/com/google/firebase/quickstart/auth/kotlin/FirebaseUIActivity.kt#L32-L46]\n\n--- 탭: Java [https://firebase.google.com/docs/auth/android/firebaseui?hl=ko#java-android] ---\n// Choose authentication providers\nList<AuthUI.IdpConfig> providers = Arrays.asList(\nnew AuthUI.IdpConfig.EmailBuilder().build(),\nnew AuthUI.IdpConfig.PhoneBuilder().build(),\nnew AuthUI.IdpConfig.GoogleBuilder().build(),\nnew AuthUI.IdpConfig.FacebookBuilder().build(),\nnew AuthUI.IdpConfig.TwitterBuilder().build());'
 '--- 탭: Java [https://firebase.google.com/docs/auth/android/firebaseui?hl=ko#java-android] ---\n// See: https://developer.android.com/training/basics/intents/result\nprivate final ActivityResultLauncher<Intent> signInLauncher = registerForActivityResult(\nnew FirebaseAuthUIActivityResultContract(),\nnew ActivityResultCallback<FirebaseAuthUIAuthenticationResult>() {\n@Override\npublic void onActivityResult(FirebaseAuthUIAuthenticationResult result) {\nonSignInResult(result);\n}\n}\n);\nFirebaseUIActivity.java [https://github.com/firebase/snippets-android/blob/b694d4dbd411d31be39655f47691c3e9f3529b03/auth/app/src/main/java/com/google/firebase/quickstart/auth/FirebaseUIActivity.java#L29-L38]\n\nFirebaseUI 로그인 과정을 시작하려면 원하는 로그인 방법으로 로그인 인텐트를 만듭니다.\n\n--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/firebaseui?hl=ko#kotlin-android] ---\n// Choose authentication providers\nval providers = arrayListOf(\nAuthUI.IdpConfig.EmailBuilder().build(),\nAuthUI.IdpConfig.PhoneBuilder().build(),\nAuthUI.IdpConfig.GoogleBuilder().build(),\nAuthUI.IdpConfig.FacebookBuilder().build(),\nAuthUI.IdpConfig.TwitterBuilder().build(),\n)'
 '--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/apple?hl=ko#kotlin-android] ---\n```\nprovider.setScopes(arrayOf(""email"", ""name""))\n```\n\n--- 탭: Java [https://firebase.google.com/docs/auth/android/apple?hl=ko#java-android] ---\n```\nList<String> scopes =\nnew ArrayList<String>() {\n{\nadd(""email"");\nadd(""name"");\n}\n};\nprovider.setScopes(scopes);\n```\n기본적으로 이메일 주소당 계정 1개가 사용 설정되어 있으면 Firebase는 이메일 및 이름 범위를 요청합니다. 이 설정을 이메일 주소당 여러 계정으로 변경하면 별도로 지정하지 않는 한 Firebase는 Apple에 범위를 요청하지 않습니다.\n선택사항: Apple의 로그인 화면을 영어가 아닌 다른 언어로 표시하려면 locale 매개변수를 설정하세요. 지원되는 언어는 Apple로 로그인 문서 [https://developer.apple.com/documentation/signinwithapplejs/incorporating_sign_in_with_apple_into_other_platforms#3332112]를 참조하세요.\n\n--- 탭: Kotlin [https://firebase.google.com/docs/auth/android/apple?hl=ko#kotlin-android] ---\n```\n// Localize the Apple authentication screen in French.\nprovider.addCustomParameter(""locale"", ""fr"")\n```'
 'Q: Objective-C에서 다중 인증(MFA) 사용자 로그인 처리를 위한 코드 예시는 어떻게 되나요?\nA: 다음은 Objective-C에서 다중 인증(MFA) 사용자 로그인 처리를 위한 코드 예시입니다.\n\n```objective-c\n[FIRAuth.auth signInWithEmail:email\npassword:password\ncompletion:^(FIRAuthDataResult * _Nullable authResult,\nNSError * _Nullable error) {\nif (error == nil || error.code != FIRAuthErrorCodeSecondFactorRequired) {\n// User is not enrolled with a second factor and is successfully signed in.\n// ...\n} else {\n// The user is a multi-factor user. Second factor challenge is required.\n}\n}];\n```'
 'Q: Objective-C에서 Firebase 인증을 완료하는 코드는 어떻게 되나요?\nA: 다음 코드를 사용하여 Firebase 로그인 프로세스를 완료합니다.\n\n```objective-c\n[[FIRAuth auth] signInWithCredential:credential\ncompletion:^(FIRAuthDataResult * _Nullable authResult,\nNSError * _Nullable error) {\n    // User successfully signed in. Get user data from the FIRUser object\n    if (authResult == nil) { return; }\n    FIRUser *user = authResult.user;\n    // ...\n}];\n```'
 'Q: Firebase에서 다중 인증(MFA) 사용자가 로그인할 때 처리하는 방법은 무엇인가요?\nA: 다중 인증(MFA) 사용자가 로그인할 때는 `FIRMultiFactorResolver`를 사용하여 추가 인증 단계를 처리합니다. 예를 들어, 다음과 같은 코드를 사용할 수 있습니다:\n\n```objective-c\nif (isMFAEnabled && error && error.code == FIRAuthErrorCodeSecondFactorRequired) {\n    FIRMultiFactorResolver *resolver = error.userInfo[FIRAuthErrorUserInfoMultiFactorResolverKey];\n    // 추가 인증 처리 로직\n}\n```'
 'Q: Objective-C에서 다중 인증(MFA) 로그인 처리를 완료하는 방법은 무엇인가요?\nA: Objective-C에서 다중 인증(MFA) 로그인 처리를 완료하려면 다음 코드를 사용합니다.\n\n```objective-c\n[resolver resolveSignInWithAssertion:assertion\ncompletion:^(FIRAuthDataResult * _Nullable authResult,\nNSError * _Nullable error) {\nif (error != nil) {\n// User successfully signed in with the second factor phone number.\n}\n}];\n```'
 'Q: Objective-C에서 Microsoft OAuthProvider의 인스턴스를 사용하여 Firebase에 인증하는 방법은 무엇인가요?\nA: Objective-C에서 Microsoft OAuthProvider의 인스턴스를 사용하여 Firebase에 인증하려면 다음과 같이 코드를 작성합니다.\n\n```objective-c\n[provider getCredentialWithUIDelegate:nil\n    completion:^(FIRAuthCredential *_Nullable credential, NSError *_Nullable error) {\n        if (error) {\n            // Handle error.\n        }\n        if (credential) {\n            [[FIRAuth auth] signInWithCredential:credential\n                completion:^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {\n                    if (error) {\n                        // Handle error.\n                    }\n                    // User is signed in.\n                    // IdP data available in authResult.additionalUserInfo.profile.\n                    // OAuth access token can also be retrieved:\n                    // ((FIROAuthCredential *)authResult.credential).accessToken\n                    // OAuth ID token can also be retrieved:\n                    // ((FIROAuthCredential *)authResult.credential).idToken\n                }];\n        }\n    }];\n```'
 'Q: Firebase에서 사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?\nA: 사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.'
 'Q: Firebase에서 다중 인증(MFA)을 사용 설정하기 위해 필요한 사전 조건은 무엇인가요?\nA: 다중 인증(MFA)을 사용 설정하기 위해서는 다음과 같은 사전 조건이 필요합니다: 1) 다중 인증(MFA)을 지원하는 제공업체를 하나 이상 사용 설정해야 합니다. 2) 전화 인증, 익명 인증, Apple Game Center를 제외한 모든 제공업체는 MFA를 지원합니다. 3) SMS 인증을 사용할 리전을 사용 설정해야 합니다. 4) 앱이 사용자 이메일을 확인하고 있어야 합니다.'
 'Q: Firebase에서 사용자의 전화번호 및 다단계 세션을 사용하여 PhoneInfoOptions 객체를 초기화하는 방법은 무엇인가요?\nA: 사용자의 전화번호 및 다단계 세션을 사용하여 PhoneInfoOptions 객체를 초기화하려면 다음과 같은 코드를 사용할 수 있습니다.\n\n```javascript\nconst phoneInfoOptions = {\nmultiFactorHint: resolver.hints[selectedIndex],\nsession: resolver.session\n};\n```'
 'Q: signInWithPopup()을 사용하여 인증을 처리할 때의 코드 예시는 무엇인가요?\nA: // After\n// ==============\nconst userCred = await signInWithPopup(auth, new GoogleAuthProvider());'
 'Q: Firebase에서 Yahoo OAuth를 사용할 때, 지원되지 않는 환경에서 인증을 처리하는 방법은 무엇인가요?\nA: Firebase에서 Yahoo OAuth를 사용할 때 지원되지 않는 환경에서 인증을 처리하려면 서드 파티 OAuth 라이브러리와 Firebase 커스텀 인증을 사용해야 합니다. 서드 파티 라이브러리는 제공업체 인증에 필요하고, Firebase 커스텀 인증은 제공업체의 사용자 인증 정보를 커스텀 토큰으로 교환할 때 필요합니다.'
 'Q: signInWithRedirect() 대신 signInWithPopup()을 사용할 때의 코드 예시는 무엇인가요?\nA: // After\n// ==============\nvar userCred = await firebase.auth().signInWithPopup(\nnew firebase.auth.GoogleAuthProvider());'
 'Q: Firebase에서 `linkWithCredential` 메서드를 사용하여 사용자 계정에 인증 정보를 연결할 때의 기본적인 코드 예시는 무엇인가요?\nA: Firebase에서 `linkWithCredential` 메서드를 사용하여 사용자 계정에 인증 정보를 연결하는 기본적인 코드 예시는 다음과 같습니다.\n\n예시 코드:\n```javascript\nimport { getAuth, linkWithCredential } from ""firebase/auth"";\n\nconst auth = getAuth();\nlinkWithCredential(auth.currentUser, credential)\n.then((usercred) => {\nconst user = usercred.user;\nconsole.log(""Account linking success"", user);\n}).catch((error) => {\nconsole.log(""Account linking error"", error);\n});\n```'
 'Q: FirebaseUI에서 사용자 맞춤형 로그인 화면을 만들기 위한 Swift 코드 예시는 무엇인가요?\nA: 사용자 맞춤형 로그인 화면을 만들기 위해 다음과 같은 Swift 코드를 사용할 수 있습니다.\n```swift\nfunc authPickerViewController(forAuthUI authUI: FUIAuth) -> FUIAuthPickerViewController {\n    return FUICustomAuthPickerViewController(nibName: ""FUICustomAuthPickerViewController"",\n                                              bundle: Bundle.main,\n                                              authUI: authUI)\n}\n```'
 'Q: FirebaseUI에서 로그아웃을 수행하기 위한 Objective-C 코드 예시는 무엇인가요?\nA: 로그아웃을 수행하기 위해 다음과 같은 Objective-C 코드를 사용할 수 있습니다.\n```objective-c\n[authUI signOut];\n```'
 'Q: Firebase에서 사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?\nA: 사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고, 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며, 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자를 식별하는 데 사용할 수 있습니다.'
 'Q: Firebase에서 신규 사용자 계정이 생성되는 과정은 어떻게 되나요?\nA: 사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.'
 'Q: 사용자가 Apple로 로그인한 후 신규 사용자 계정을 생성하는 방법은 무엇인가요?\nA: 사용자가 Apple로 로그인한 후 신규 사용자 계정은 자동으로 생성됩니다. 이 신규 계정은 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. Firebase 프로젝트에 저장되며, 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.'
 'Q: FirebaseUI에서 서비스 약관 URL을 설정하기 위한 Objective-C 코드 예시는 무엇인가요?\nA: 서비스 약관 URL을 설정하기 위해 다음과 같은 Objective-C 코드를 사용할 수 있습니다.\n```objective-c\nauthUI.TOSURL = [NSURL URLWithString:@""https://example.com/terms""];\n```'
 'Q: Firebase에서 Twitter 인증 후 사용자 계정이 생성되는 과정은 어떻게 되나요?\nA: 사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고, 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며, 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.'
 'Q: FirebaseUI에서 전화번호 로그인을 처리하기 위한 Swift 코드 예시는 무엇인가요?\nA: 전화번호 로그인을 처리하기 위해 다음과 같은 Swift 코드를 사용할 수 있습니다.\n```swift\nlet phoneProvider = FUIPhoneAuth(authUI: authUI)\nphoneProvider.signIn(withPresenting: currentlyVisibleController, phoneNumber: nil)\n```'
 'Q: FirebaseUI에서 사용자에게 표시되는 메시지를 맞춤설정하기 위한 Swift 코드 예시는 무엇인가요?\nA: 사용자에게 표시되는 메시지를 맞춤설정하기 위해 다음과 같은 Swift 코드를 사용할 수 있습니다.\n```swift\nauthUI.customStringsBundle = Bundle.main // Or any custom bundle.\n```'
 'Q: 사용자가 처음으로 로그인할 때 어떤 일이 발생하나요?\nA: 사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.'
 'Q: 사용자가 Firebase에 처음 로그인할 때 어떤 일이 발생하나요?\nA: 사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고, 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며, 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.'
 'Q: 사용자가 Firebase에 처음 로그인할 때 어떤 일이 발생하나요?\nA: 사용자가 Firebase에 처음 로그인하면 신규 사용자 계정이 생성되고, 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트에 저장되며, 사용자의 로그인 방법과 무관하게 프로젝트 내의 모든 앱에서 사용자 본인 확인에 사용할 수 있습니다.'
 'Q: Firebase에서 다중 인증(MFA) 세션을 가져오는 방법은 무엇인가요?\nA: 다중 인증(MFA) 세션을 가져오려면 다음과 같이 코드를 작성합니다:\n```javascript\nimport { multiFactor } from ""firebase/auth"";\n\nmultiFactor(user).getSession().then(function (multiFactorSession) {\n// ...\n});\n```'
 'Q: Firebase에서 다중 인증(MFA) 세션을 가져오는 방법은 무엇인가요?\nA: 다중 인증(MFA) 세션을 가져오려면 다음 코드를 사용하세요:\n```javascript\nmultiFactor(user).getSession()\n.then(function (multiFactorSession) {\n  // 세션을 사용하여 추가 작업 수행\n});\n```'
 'Q: Firebase에서 다중 인증(MFA) 등록을 완료하는 방법은 무엇인가요?\nA: 다중 인증(MFA) 등록을 완료하려면 다음 코드를 사용하세요:\n```javascript\nmultiFactor(user).enroll(multiFactorAssertion, mfaDisplayName);\n```'
 'Q: Objective-C에서 Facebook 로그인 인증 정보를 가져오는 방법은 무엇인가요?\nA: 다음과 같이 새로운 인증 제공업체의 FIRAuthCredential을 가져옵니다.\n\n```objective-c\nFIRAuthCredential *credential = [FIRFacebookAuthProvider\ncredentialWithAccessToken:[FBSDKAccessToken currentAccessToken].tokenString];\n```'
 'Q: Objective-C에서 Yahoo OAuthProvider를 사용하여 사용자의 프로필 정보를 가져오는 방법은 무엇인가요?\nA: 기본 프로필 정보를 가져오려면 Authorization 헤더에 액세스 토큰을 전달하여 REST API를 호출하면 됩니다.\n\n```\nhttps://social.yahooapis.com/v1/user/YAHOO_USER_UID/profile?format=json\n```\n여기서 YAHOO_USER_UID는 [[FIRAuth auth].currentUser.providerData[0] uid] 필드 또는 authResult.additionalUserInfo.profile에서 검색할 수 있는 Yahoo 사용자의 ID입니다.'
 'Q: Firebase 프로젝트에서 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?\nA: 앱의 User 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다.'
 'Q: Objective-C에서 사용자에게 연결된 로그인 제공업체의 프로필 정보를 가져오는 방법은 무엇인가요?\nA: 사용자에게 연결된 로그인 제공업체로부터 프로필 정보를 가져오려면 providerData 속성을 사용합니다. 예를 들면 다음과 같습니다.\n\n```objective-c\nid<FIRUserInfo> userInfo = [FIRAuth auth].currentUser.providerData[indexPath.row];\ncell.textLabel.text = [userInfo providerID];\n// Provider-specific UID\ncell.detailTextLabel.text = [userInfo uid];\n```'
 'Q: Objective-C에서 사용자의 다중 세션을 가져오는 방법은 무엇인가요?\nA: Objective-C에서 사용자의 다중 세션을 가져오려면 다음 코드를 사용하세요.\n\n```objective-c\n[authResult.user.multiFactor\ngetSessionWithCompletion:^(FIRMultiFactorSession * _Nullable session,\nNSError * _Nullable error) {\n// ...\n}];\n```'
 'Q: Firebase에서 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?\nA: 앱의 User 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리 문서를 참조하세요.'
 'Q: Firebase에서 로그인한 사용자의 정보를 가져오는 방법은 무엇인가요?\nA: 로그인한 사용자의 정보를 가져오기 위해 `onAuthStateChanged` 메서드 내에서 `user` 객체를 사용합니다. 사용자가 로그인되면 `user` 객체에서 필요한 정보를 가져올 수 있습니다.'
 'Q: Firebase에서 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?\nA: Firebase에서 사용자의 기본 프로필 정보를 가져오려면 앱의 User 객체를 사용하세요. 자세한 내용은 사용자 관리 문서를 참조하세요.'
 'Q: Objective-C에서 익명 사용자의 계정 데이터를 가져오는 방법은 무엇인가요?\nA: Objective-C에서 익명 사용자의 계정 데이터를 가져오려면 다음과 같은 코드를 사용합니다:\n\n```objective-c\nFIRUser *user = authResult.user;\nBOOL isAnonymous = user.anonymous;  // YES\nNSString *uid = user.uid;\n```'
 'Q: Firebase에서 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?\nA: Firebase에서 사용자의 기본 프로필 정보를 가져오려면 앱의 User 객체를 사용합니다. 사용자의 기본 프로필 정보는 authResult?.additionalUserInfo?.profile에서 확인할 수 있습니다.'
 'Q: Objective-C에서 Facebook 인증 정보를 사용하여 사용자 계정을 연결하는 방법은 무엇인가요?\nA: Objective-C에서 Facebook 인증 정보를 사용하여 사용자 계정을 연결하려면, 다음과 같이 `linkWithCredential:completion:` 메서드를 사용하여 `FIRAuthCredential` 객체를 전달합니다.\n\n```objective-c\nFIRAuthCredential *credential = [FIRFacebookAuthProvider\ncredentialWithAccessToken:[FBSDKAccessToken currentAccessToken].tokenString];\n\n[[FIRAuth auth].currentUser linkWithCredential:credential\ncompletion:^(FIRAuthDataResult *result, NSError *_Nullable error) {\n// ...\n}];\n```'
 'Q: Firebase에서 사용자의 기본 프로필 정보를 가져오는 방법은 무엇인가요?\nA: 앱의 `User` 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자의 프로필 정보는 Firebase 프로젝트의 일부로 저장되며, 사용자가 로그인할 때 사용한 인증 정보에 연결됩니다. 자세한 내용은 사용자 관리 문서를 참조하세요.'
 'Q: Swift에서 이메일-비밀번호 로그인 인증 정보를 가져오는 방법은 무엇인가요?\nA: 다음과 같이 새로운 인증 제공업체의 FIRAuthCredential을 가져옵니다.\n\n```swift\nlet credential = EmailAuthProvider.credential(withEmail: email, password: password)\n```'
 'Q: 다중 인증(MFA) 등록을 완료하는 방법은 무엇인가요?\nA: 다중 인증(MFA) 등록을 완료하려면 다음과 같이 코드를 작성합니다:\n```javascript\n// Complete enrollment. This will update the underlying tokens\n// and trigger ID token change listener.\nmultiFactor(user).enroll(multiFactorAssertion, ""My personal phone number"");\n```'
 'Q: Microsoft Graph API를 호출하여 기본 프로필 정보를 가져오는 방법은 무엇인가요?\nA: Microsoft Graph API를 호출하여 기본 프로필 정보를 가져오려면 REST API를 호출하고 Authorization 헤더에 OAuth 액세스 토큰을 전달해야 합니다. 예를 들어, 다음과 같은 URL을 사용합니다:\n\n```\nhttps://graph.microsoft.com/v1.0/me\n```'
 ""Q: Firebase에서 다중 인증(MFA) 사용자가 로그인할 때 처리해야 할 오류는 무엇인가요?\nA: 다중 인증(MFA) 사용자가 로그인할 때 'auth/multi-factor-auth-required' 오류를 포착해야 합니다. 이 오류는 사용자가 다중 인증 사용자임을 나타내며, 두 번째 단계의 챌린지가 필요합니다. 예를 들어:\n```javascript\nif (error.code == 'auth/multi-factor-auth-required') {\n  resolver = getMultiFactorResolver(auth, error);\n  // 추가 처리\n}\n```""
 'Q: TOTP MFA 등록을 완료하기 위해 사용자가 입력해야 하는 코드는 무엇인가요?\nA: // Ask the user for a verification code from the authenticator app.\nconst verificationCode = // Code from user input.'
 ""Q: Apple 로그인 화면의 언어를 프랑스어로 설정하는 방법은 무엇인가요?\nA: Apple 로그인 화면을 프랑스어로 표시하려면 locale 매개변수를 설정해야 합니다. 다음과 같이 설정할 수 있습니다:\n\n```javascript\nprovider.setCustomParameters({\n  // Localize the Apple authentication screen in French.\n  locale: 'fr'\n});\n```""
 ""Q: Apple 로그인 화면의 언어를 변경하려면 어떻게 해야 하나요?\nA: Apple 로그인 화면의 언어를 변경하려면 `setCustomParameters()` 메서드를 사용하여 `locale` 매개변수를 설정합니다. 아래는 그 예시입니다.\n\n```javascript\nprovider.setCustomParameters({\n// Localize the Apple authentication screen in French.\nlocale: 'fr'\n});\n```""
 'Q: Apple 계정과 Facebook 계정을 연결하기 위해 필요한 절차는 무엇인가요?\nA: // Initialize a Facebook credential with Firebase.\nlet credential = FacebookAuthProvider.credential(\n    withAccessToken: AccessToken.current!.tokenString\n)\n// Assuming the current user is an Apple user linking a Facebook provider.\nAuth.auth().currentUser.link(with: credential) { (authResult, error) in\n    // Facebook credential is linked to the current Apple user.\n    // The user can now sign in with Facebook or Apple to the same Firebase\n    // account.\n    // ...\n}'
 'Q: Firebase에서 Apple 계정과 Facebook 계정을 연결하는 방법은 무엇인가요?\nA: Swift에서 Apple 계정과 Facebook 계정을 연결하려면 다음 코드를 사용하세요:\n```swift\n// Initialize a Facebook credential with Firebase.\nlet credential = FacebookAuthProvider.credential(\n    withAccessToken: AccessToken.current!.tokenString\n)\n// Assuming the current user is an Apple user linking a Facebook provider.\nAuth.auth().currentUser.link(with: credential) { (authResult, error) in\n    // Facebook credential is linked to the current Apple user.\n    // The user can now sign in with Facebook or Apple to the same Firebase\n    // account.\n    // ...\n}\n```'
 ""Q: Firebase에서 SMS 코드가 전송된 후 사용자에게 코드를 입력하라는 메시지를 표시하는 방법은 무엇인가요?\nA: SMS 코드가 전송된 후 사용자에게 코드를 입력하라는 메시지를 표시하려면 codeSent 콜백을 사용하여 UI를 업데이트해야 합니다. 예시는 다음과 같습니다:\n\n```dart\nawait auth.verifyPhoneNumber(\n  phoneNumber: '+44 7123 123 456',\n  codeSent: (String verificationId, int? resendToken) async {\n    // Update the UI - wait for the user to enter the SMS code\n    String smsCode = 'xxxx';\n\n    // Create a PhoneAuthCredential with the code\n    PhoneAuthCredential credential = PhoneAuthProvider.credential(verificationId: verificationId, smsCode: smsCode);\n\n    // Sign the user in (or link) with the credential\n    await auth.signInWithCredential(credential);\n  },\n);\n```""
 'Q: Swift에서 Google 로그인 인증 정보를 가져오는 방법은 무엇인가요?\nA: 다음과 같이 새로운 인증 제공업체의 FIRAuthCredential을 가져옵니다.\n\n```swift\nguard\nlet authentication = user?.authentication,\nlet idToken = authentication.idToken\nelse {\nreturn\n}\n\nlet credential = GoogleAuthProvider.credential(withIDToken: idToken,\naccessToken: authentication.accessToken)\n```'
 'Q: 전화번호 인증을 위해 SMS 인증 코드를 전송하는 메서드는 무엇인가요?\nA: 전화번호 인증을 위해 SMS 인증 코드를 전송하려면 PhoneAuthProvider.VerifyPhoneNumber을 호출해야 합니다. 아래는 해당 메서드를 사용하는 예시입니다.\n\n```csharp\nPhoneAuthProvider provider = PhoneAuthProvider.GetInstance(firebaseAuth);\nprovider.VerifyPhoneNumber(\nnew Firebase.Auth.PhoneAuthOptions {\nPhoneNumber = phoneNumber,\nTimeoutInMilliseconds = phoneAuthTimeoutMs,\nForceResendingToken = null\n},\nverificationCompleted: (credential) =&gt {\n// Auto-sms-retrieval or instant validation has succeeded (Android only).\n// There is no need to input the verification code.\n// `credential` can be used instead of calling GetCredential().\n},\nverificationFailed: (error) =&gt {\n// The verification code was not sent.\n// `error` contains a human readable explanation of the problem.\n},\ncodeSent: (id, token) =&gt {\n// Verification code was successfully sent via SMS.\n// `id` contains the verification id that will need to passed in with\n// the code from the user when calling GetCredential().\n// `token` can be used if the user requests the code be sent again, to\n// tie the two requests together.\n},\ncodeAutoRetrievalTimeout: (id) =&gt {\n// Called when the auto-sms-retrieval has timed out, based on the given\n// timeout parameter.\n// `id` contains the verification id of the request that timed out.\n});\n```'
 'Q: 특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 어떻게 해야 하나요?\nA: 다음과 같이 커스텀 매개변수 객체의 \'tenant\' 필드를 지정하여 특정 Azure AD 테넌트의 사용자만 로그인하도록 설정할 수 있습니다.\n\n```javascript\nprovider.setCustomParameters({\n// Optional ""tenant"" parameter in case you are using an Azure AD tenant.\n// eg. \'8eaef023-2b34-4da1-9baa-8bc8c9d6a490\' or \'contoso.onmicrosoft.com\'\n// or ""common"" for tenant-independent tokens.\n// The default value is ""common"".\ntenant: \'TENANT_ID\'\n});\n```'
 ""Q: Firebase에서 SMS 코드가 전송된 후 사용자에게 코드를 입력하라는 메시지를 표시하는 방법은 무엇인가요?\nA: Firebase에서 SMS 코드가 기기로 전송되면 codeSent 핸들러가 호출됩니다. 이 핸들러를 사용하여 사용자에게 올바른 SMS 코드를 입력하라는 메시지를 표시하도록 애플리케이션 UI를 업데이트할 수 있습니다. 다음은 그 예시입니다.\n\n```dart\nFirebaseAuth auth = FirebaseAuth.instance;\n\nawait auth.verifyPhoneNumber(\n  phoneNumber: '+44 7123 123 456',\n  codeSent: (String verificationId, int? resendToken) async {\n    // Update the UI - wait for the user to enter the SMS code\n    String smsCode = 'xxxx';\n\n    // Create a PhoneAuthCredential with the code\n    PhoneAuthCredential credential = PhoneAuthProvider.credential(verificationId: verificationId, smsCode: smsCode);\n\n    // Sign the user in (or link) with the credential\n    await auth.signInWithCredential(credential);\n  },\n);\n```""
 ""Q: 웹에서 Firebase 전화번호 인증을 위해 사용해야 하는 메서드는 무엇인가요?\nA: 웹 플랫폼에서 전화번호 인증을 위해 사용해야 하는 메서드는 signInWithPhoneNumber입니다. 이 메서드를 호출하면 사용자는 제공된 전화번호로 전송된 SMS 코드를 입력하여 로그인할 수 있습니다. 다음은 그 예시입니다.\n\n```dart\nFirebaseAuth auth = FirebaseAuth.instance;\n\n// Wait for the user to complete the reCAPTCHA & for an SMS code to be sent.\nConfirmationResult confirmationResult = await auth.signInWithPhoneNumber('+44 7123 123 456');\n```""
 'Q: 전화번호 로그인을 시작하기 위해 사용자가 전화번호를 제공하도록 요청하는 방법은 무엇인가요?\nA: 전화번호 로그인을 시작하려면 사용자에게 전화번호를 제공하도록 요청하는 인터페이스를 제시한 다음, PhoneAuthProvider.VerifyPhoneNumber을 호출하여 Firebase가 사용자의 전화에 SMS 인증 코드를 전송하도록 요청합니다. 다음은 코드 예시입니다:\n\n```csharp\nPhoneAuthProvider provider = PhoneAuthProvider.GetInstance(firebaseAuth);\nprovider.VerifyPhoneNumber(\n    new Firebase.Auth.PhoneAuthOptions {\n        PhoneNumber = phoneNumber,\n        TimeoutInMilliseconds = phoneAuthTimeoutMs,\n        ForceResendingToken = null\n    },\n    verificationCompleted: (credential) => {\n        // Auto-sms-retrieval or instant validation has succeeded (Android only).\n        // There is no need to input the verification code.\n        // `credential` can be used instead of calling GetCredential().\n    },\n    verificationFailed: (error) => {\n        // The verification code was not sent.\n        // `error` contains a human readable explanation of the problem.\n    },\n    codeSent: (id, token) => {\n        // Verification code was successfully sent via SMS.\n        // `id` contains the verification id that will need to passed in with\n        // the code from the user when calling GetCredential().\n        // `token` can be used if the user requests the code be sent again, to\n        // tie the two requests together.\n    },\n    codeAutoRetrievalTimeout: (id) => {\n        // Called when the auto-sms-retrieval has timed out, based on the given\n        // timeout parameter.\n        // `id` contains the verification id of the request that timed out.\n    });\n```'
 'Q: 전화번호 인증 코드 전송을 위한 verifyPhoneNumber 메서드의 사용 예시는 무엇인가요?\nA: --- 탭: Swift ---\nPhoneAuthProvider.provider()\n.verifyPhoneNumber(phoneNumber, uiDelegate: nil) { verificationID, error in\nif let error = error {\nself.showMessagePrompt(error.localizedDescription)\nreturn\n}\n// Sign in using the verificationID and the code sent to the user\n// ...\n}\n\n--- 탭: Objective-C ---\n[[FIRPhoneAuthProvider provider] verifyPhoneNumber:userInput'
 'Q: 특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 어떻게 해야 하나요?\nA: 특정 Azure AD 테넌트의 사용자만 애플리케이션에 로그인하도록 허용하려면 Azure AD 테넌트의 도메인 이름 또는 테넌트의 GUID 식별자를 사용해야 합니다. 이를 위해 커스텀 매개변수 객체의 \'tenant\' 필드를 지정합니다. 예시는 다음과 같습니다.\n\n```javascript\nprovider.setCustomParameters({\n// Optional ""tenant"" parameter in case you are using an Azure AD tenant.\n// eg. \'8eaef023-2b34-4da1-9baa-8bc8c9d6a490\' or \'contoso.onmicrosoft.com\'\n// or ""common"" for tenant-independent tokens.\n// The default value is ""common"".\ntenant: \'TENANT_ID\'\n});\n```'
 'Q: 다중 인증(MFA) 사용자가 로그인할 때 처리하는 방법은 무엇인가요?\nA: if let error = error {\nlet authError = error as NSError\nif isMFAEnabled, authError.code == AuthErrorCode.secondFactorRequired.rawValue {\n// The user is a multi-factor user. Second factor challenge is required.\nlet resolver = authError\n.userInfo[AuthErrorUserInfoMultiFactorResolverKey] as! MultiFactorResolver\n// ...\n}\n}'
 'Q: 인증 코드가 성공적으로 전송되었는지 확인하는 방법은 무엇인가요?\nA: 인증 코드가 성공적으로 전송되었는지 확인하려면 codeSent 콜백을 사용해야 합니다. 이 콜백이 호출되면 인증 코드가 SMS로 성공적으로 전송된 것입니다. 아래는 해당 콜백의 예시입니다.\n\n```csharp\ncodeSent: (id, token) =&gt {\n// Verification code was successfully sent via SMS.\n// `id` contains the verification id that will need to passed in with\n// the code from the user when calling GetCredential().\n// `token` can be used if the user requests the code be sent again, to\n// tie the two requests together.\n},\n```'
 'Q: Firebase에서 전화번호 인증을 위해 사용자의 전화번호를 verifyPhoneNumber 메서드에 전달하는 방법은 무엇인가요?\nA: verifyPhoneNumber(_:uiDelegate:completion:)을 호출하면서 사용자의 전화번호를 전달합니다. 예를 들어, Swift에서는 다음과 같이 사용할 수 있습니다:\n\n```swift\nPhoneAuthProvider.provider()\n.verifyPhoneNumber(phoneNumber, uiDelegate: nil) { verificationID, error in\nif let error = error {\nself.showMessagePrompt(error.localizedDescription)\nreturn\n}\n// Sign in using the verificationID and the code sent to the user\n// ...\n}\n```'
 ""Q: Firebase에서 SMS 코드 전송 후 사용자에게 코드를 입력하라는 메시지를 표시하는 방법은 무엇인가요?\nA: 웹 플랫폼에서 사용자는 제공된 전화번호로 전송된 SMS 코드를 입력하여 로그인할 수 있습니다. 이 과정에서 사용자는 Google reCAPTCHA 위젯을 완료해야 하며, 확인이 완료되면 SMS 코드가 전송됩니다. 아래는 signInWithPhoneNumber 메서드를 호출하는 예시입니다.\n\n```dart\nFirebaseAuth auth = FirebaseAuth.instance;\n\n// Wait for the user to complete the reCAPTCHA & for an SMS code to be sent.\nConfirmationResult confirmationResult = await auth.signInWithPhoneNumber('+44 7123 123 456');\n```""
 'Q: Objective-C에서 사용자가 로그인한 후 사용자 정보를 가져오는 방법은 무엇인가요?\nA: 사용자가 로그인되면 사용자에 대한 정보를 가져올 수 있습니다. 다음은 Objective-C 코드 예시입니다:\n```objective-c\nif (user) {\n// The user\'s ID, unique to the Firebase project.\n// Do NOT use this value to authenticate with your backend server,\n// if you have one. Use getTokenWithCompletion:completion: instead.\nNSString *email = user.email;\nNSString *uid = user.uid;\nNSMutableString *multiFactorString = [NSMutableString stringWithFormat:@""MultiFactor: ""];\nfor (FIRMultiFactorInfo *info in user.multiFactor.enrolledFactors) {\n[multiFactorString appendString:info.displayName];\n[multiFactorString appendString:@"" ""];\n}\nNSURL *photoURL = user.photoURL;\n// ...\n}\n```'
 'Q: Objective-C에서 사용자가 로그인할 때 Firebase Authentication을 사용하는 방법은 무엇인가요?\nA: Objective-C에서 사용자가 로그인할 때는 사용자의 이메일 주소와 비밀번호를 `signInWithEmail:password:completion:` 메서드에 전달합니다. 아래는 그 예시입니다.\n\n```objective-c\n[[FIRAuth auth] signInWithEmail:self->_emailField.text\n    password:self->_passwordField.text\n    completion:^(FIRAuthDataResult * _Nullable authResult,\n                 NSError * _Nullable error) {\n        // ...\n    }];\n```'
 'Q: Firebase JavaScript SDK에서 Microsoft 계정으로 로그인할 때 auth/account-exists-with-different-credential 오류를 처리하는 방법은 무엇인가요?\nA: 다음 코드를 사용하여 Firebase JavaScript SDK에서 Microsoft 계정으로 로그인할 때 auth/account-exists-with-different-credential 오류를 처리할 수 있습니다:\n\n```javascript\nimport {\ngetAuth,\nlinkWithCredential,\nsignInWithPopup,\nOAuthProvider,\n} from ""firebase/auth"";\n\ntry {\n// Step 1: User tries to sign in using Microsoft.\nlet result = await signInWithPopup(getAuth(), new OAuthProvider());\n} catch (error) {\n// Step 2: User\'s email already exists.\nif (error.code === ""auth/account-exists-with-different-credential"") {\n// The pending Microsoft credential.\nlet pendingCred = error.credential;\n\n// Step 3: Save the pending credential in temporary storage,\n\n// Step 4: Let the user know that they already have an account\n// but with a different provider, and let them choose another\n// sign-in method.\n}\n}\n\n// ...\n\ntry {\n// Step 5: Sign the user in using their chosen method.\nlet result = await signInWithPopup(getAuth(), userSelectedProvider);\n\n// Step 6: Link to the Microsoft credential.\n// TODO: implement `retrievePendingCred` for your app.\nlet pendingCred = retrievePendingCred();\n\nif (pendingCred !== null) {\n// As you have access to the pending credential, you can directly call the\n// link method.\nlet user = await linkWithCredential(result.user, pendingCred);\n}\n\n// Step 7: Continue to app.\n} catch (error) {\n// ...\n}\n```'
 'Q: Swift에서 익명 계정을 영구 계정으로 전환하기 위해 필요한 절차는 무엇인가요?\nA: 사용자가 가입하면 해당 사용자가 선택한 인증 제공업체의 로그인 과정을 진행하되 FIRAuth.signInWith 메서드 호출 전까지만 진행합니다. 예를 들어 사용자의 Google ID 토큰, Facebook 액세스 토큰 또는 이메일 주소와 비밀번호를 가져옵니다. 다음과 같이 새로운 인증 제공업체의 FIRAuthCredential을 가져옵니다.\n\nGoogle 로그인\n\n```swift\nguard\nlet authentication = user?.authentication,\nlet idToken = authentication.idToken\nelse {\nreturn\n}\n\nlet credential = GoogleAuthProvider.credential(withIDToken: idToken,\naccessToken: authentication.accessToken)\n```\n\nFacebook 로그인\n\n```swift\nlet credential = FacebookAuthProvider\n.credential(withAccessToken: AccessToken.current!.tokenString)\n```\n\n이메일-비밀번호 로그인\n\n```swift\nlet credential = EmailAuthProvider.credential(withEmail: email, password: password)\n```'
 'Q: Firebase에서 `linkWithCredential` 메서드를 사용하여 계정을 연결하는 방법은 무엇인가요?\nA: 다음과 같이 `linkWithCredential` 메서드를 사용하여 계정을 연결할 수 있습니다.\n\n```javascript\nimport { getAuth, signInWithCredential, linkWithCredential, OAuthProvider } from ""firebase/auth"";\n\n// The implementation of how you store your user data depends on your application\nconst repo = new MyUserDataRepo();\n\n// Get reference to the currently signed-in user\nconst auth = getAuth();\nconst prevUser = auth.currentUser;\n\n// Get the data which you will want to merge. This should be done now\n// while the app is still signed in as this user.\nconst prevUserData = repo.get(prevUser);\n\n// Delete the user\'s data now, we will restore it if the merge fails\nrepo.delete(prevUser);\n\n// Sign in user with the account you want to link to\nsignInWithCredential(auth, newCredential).then((result) => {\nconsole.log(""Sign In Success"", result);\nconst currentUser = result.user;\nconst currentUserData = repo.get(currentUser);\n\n// Merge prevUser and currentUser data stored in Firebase.\n// Note: How you handle this is specific to your application\nconst mergedData = repo.merge(prevUserData, currentUserData);\n\nconst credential = OAuthProvider.credentialFromResult(result);\nreturn linkWithCredential(prevUser, credential)\n.then((linkResult) => {\n// Sign in with the newly linked credential\nconst linkCredential = OAuthProvider.credentialFromResult(linkResult);\nreturn signInWithCredential(auth, linkCredential);\n})\n.then((signInResult) => {\n// Save the merged data to the new user\nrepo.set(signInResult.user, mergedData);\n});\n}).catch((error) => {\n// If there are errors we want to undo the data merge/deletion\nconsole.log(""Sign In Error"", error);\nrepo.set(prevUser, prevUserData);\n});\n```'
 'Q: 이메일 링크를 전송하기 위해 Swift에서 사용하는 메서드는 무엇인가요?\nA: Swift에서 이메일 링크를 전송하기 위해 사용하는 메서드는 다음과 같습니다:\n```swift\nAuth.auth().sendSignInLink(toEmail: email,\nactionCodeSettings: actionCodeSettings) { error in\n// ...\nif let error = error {\nself.showMessagePrompt(error.localizedDescription)\nreturn\n}\n// The link was successfully sent. Inform the user.\n// Save the email locally so you don\'t need to ask the user for it again\n// if they open the link on the same device.\nUserDefaults.standard.set(email, forKey: ""Email"")\nself.showMessagePrompt(""Check your email for link"")\n// ...\n}\n```'
 'Q: Objective-C에서 현재 사용자의 프로필 정보를 가져오는 방법은 무엇인가요?\nA: 사용자의 프로필 정보를 가져오려면 FIRUser 인스턴스의 속성을 사용합니다. 예를 들면 다음과 같습니다.\n\n```objective-c\nFIRUser *user = [FIRAuth auth].currentUser;\nif (user) {\n    // The user\'s ID, unique to the Firebase project.\n    // Do NOT use this value to authenticate with your backend server,\n    // if you have one. Use getTokenWithCompletion:completion: instead.\n    NSString *email = user.email;\n    NSString *uid = user.uid;\n    NSMutableString *multiFactorString = [NSMutableString stringWithFormat:@""MultiFactor: ""];\n    for (FIRMultiFactorInfo *info in user.multiFactor.enrolledFactors) {\n        [multiFactorString appendString:info.displayName];\n        [multiFactorString appendString:@"" ""];\n    }\n    NSURL *photoURL = user.photoURL;\n    // ...\n}\n```'
 'Q: Swift에서 사용자가 로그인한 후 사용자 정보를 가져오는 방법은 무엇인가요?\nA: 사용자가 로그인되면 사용자에 대한 정보를 가져올 수 있습니다. 다음은 Swift 코드 예시입니다:\n```swift\nif let user = user {\n// The user\'s ID, unique to the Firebase project.\n// Do NOT use this value to authenticate with your backend server,\n// if you have one. Use getTokenWithCompletion:completion: instead.\nlet uid = user.uid\nlet email = user.email\nlet photoURL = user.photoURL\nvar multiFactorString = ""MultiFactor: ""\nfor info in user.multiFactor.enrolledFactors {\nmultiFactorString += info.displayName ?? ""[DispayName]""\nmultiFactorString += "" ""\n}\n// ...\n}\n```'
 'Q: Swift에서 현재 사용자의 프로필 정보를 가져오는 방법은 무엇인가요?\nA: 사용자의 프로필 정보를 가져오려면 FIRUser 인스턴스의 속성을 사용합니다. 예를 들면 다음과 같습니다.\n\n```swift\nlet user = Auth.auth().currentUser\nif let user = user {\n    // The user\'s ID, unique to the Firebase project.\n    // Do NOT use this value to authenticate with your backend server,\n    // if you have one. Use getTokenWithCompletion:completion: instead.\n    let uid = user.uid\n    let email = user.email\n    let photoURL = user.photoURL\n    var multiFactorString = ""MultiFactor: ""\n    for info in user.multiFactor.enrolledFactors {\n        multiFactorString += info.displayName ?? ""[DispayName]""\n        multiFactorString += "" ""\n    }\n    // ...\n}\n```'
 'Q: TOTP MFA에서 사용자가 OTP를 입력하고 MFA 등록을 완료하는 방법은 무엇인가요?\nA: // Ask the user for a verification code from the authenticator app.\nlet verificationCode = // Code from user input.\n\n// Finalize the enrollment.\nlet multiFactorAssertion = TOTPMultiFactorGenerator.assertionForEnrollment(\nwith: totpSecret,\noneTimePassword: verificationCode)\ndo {\ntry await currentUser.multiFactor.enroll(\nwith: multiFactorAssertion,\ndisplayName: ""TOTP"")\n} catch {\n// Wrong or expired OTP. Re-prompt the user.\n}'
 'Q: Swift에서 다중 인증(MFA) 사용자 로그인 처리를 위한 코드 예시는 어떻게 되나요?\nA: 다음은 Swift에서 다중 인증(MFA) 사용자 로그인 처리를 위한 코드 예시입니다.\n\n```swift\nAuth.auth().signIn(\nwithEmail: email,\npassword: password\n) { (result, error) in\nlet authError = error as NSError\nif authError?.code == AuthErrorCode.secondFactorRequired.rawValue {\n// The user is a multi-factor user. Second factor challenge is required.\nlet resolver =\nauthError!.userInfo[AuthErrorUserInfoMultiFactorResolverKey] as! MultiFactorResolver\n// ...\n} else {\n// Handle other errors such as wrong password.\n}\n}\n```'
 'Q: Firebase JavaScript SDK에서 Google 로그인 시 발생할 수 있는 \'account-exists-with-different-credential\' 오류를 처리하는 방법은 무엇인가요?\nA: Firebase JavaScript SDK에서 \'account-exists-with-different-credential\' 오류를 처리하려면 다음과 같은 코드를 사용할 수 있습니다.\n\n```javascript\nimport {\ngetAuth,\nlinkWithCredential,\nsignInWithPopup,\nGoogleAuthProvider,\n} from ""firebase/auth"";\n\ntry {\n// Step 1: User tries to sign in using Google.\nlet result = await signInWithPopup(getAuth(), new GoogleAuthProvider());\n} catch (error) {\n// Step 2: User\'s email already exists.\nif (error.code === ""auth/account-exists-with-different-credential"") {\n// The pending Google credential.\nlet pendingCred = error.credential;\n\n// Step 3: Save the pending credential in temporary storage,\n\n// Step 4: Let the user know that they already have an account\n// but with a different provider, and let them choose another\n// sign-in method.\n}\n}\n\n// ...\n\ntry {\n// Step 5: Sign the user in using their chosen method.\nlet result = await signInWithPopup(getAuth(), userSelectedProvider);\n\n// Step 6: Link to the Google credential.\n// TODO: implement `retrievePendingCred` for your app.\nlet pendingCred = retrievePendingCred();\n\nif (pendingCred !== null) {\n// As you have access to the pending credential, you can directly call the\n// link method.\nlet user = await linkWithCredential(result.user, pendingCred);\n}\n\n// Step 7: Continue to app.\n} catch (error) {\n// ...\n}\n```'
 'Q: Apple 로그인 페이지에서 해시된 난스를 설정하는 방법은 무엇인가요?\nA: Apple 로그인 페이지에서 해시된 난스를 설정하려면 다음과 같은 코드를 사용하여 `nonce` 값을 설정해야 합니다.\n\n```html\n<script src=""https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js""></script>\n<div id=""appleid-signin"" data-color=""black"" data-border=""true"" data-type=""sign in""></div>\n<script>\nAppleID.auth.init({\nclientId: YOUR_APPLE_CLIENT_ID,\nscope: \'name email\',\nredirectURI: URL_TO_YOUR_REDIRECT_HANDLER,  // See the next step.\nstate: \'[STATE]\',  // Optional value that Apple will send back to you\nnonce: HASHED_NONCE  // The hashed nonce you generated in the previous step.\n});\n</script>\n```'
 'Q: Firebase JavaScript SDK에서 Facebook 로그인 시 \'auth/account-exists-with-different-credential\' 오류를 처리하는 방법은 무엇인가요?\nA: signInWithPopup을 사용하는 경우 다음 예시와 같은 코드를 사용해 auth/account-exists-with-different-credential 오류를 처리할 수 있습니다.\n\n```javascript\nimport {\ngetAuth,\nlinkWithCredential,\nsignInWithPopup,\nFacebookAuthProvider,\n} from ""firebase/auth"";\n\ntry {\n// Step 1: User tries to sign in using Facebook.\nlet result = await signInWithPopup(getAuth(), new FacebookAuthProvider());\n} catch (error) {\n// Step 2: User\'s email already exists.\nif (error.code === ""auth/account-exists-with-different-credential"") {\n// The pending Facebook credential.\nlet pendingCred = error.credential;\n\n// Step 3: Save the pending credential in temporary storage,\n\n// Step 4: Let the user know that they already have an account\n// but with a different provider, and let them choose another\n// sign-in method.\n}\n}\n\n// ...\n\ntry {\n// Step 5: Sign the user in using their chosen method.\nlet result = await signInWithPopup(getAuth(), userSelectedProvider);\n\n// Step 6: Link to the Facebook credential.\n// TODO: implement `retrievePendingCred` for your app.\nlet pendingCred = retrievePendingCred();\n\nif (pendingCred !== null) {\n// As you have access to the pending credential, you can directly call the\n// link method.\nlet user = await linkWithCredential(result.user, pendingCred);\n}\n\n// Step 7: Continue to app.\n} catch (error) {\n// ...\n}\n```'
 'Q: Apple로 로그인 시 해시된 난스를 지정하는 방법은 무엇인가요?\nA: 로그인 페이지의 Apple로 로그인 구성에서 해시된 난스를 지정하기 위해, AppleID.auth.init() 메서드의 nonce 필드에 HASHED_NONCE를 설정합니다.\n\n```html\n<script src=""https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js""></script>\n<div id=""appleid-signin"" data-color=""black"" data-border=""true"" data-type=""sign in""></div>\n<script>\nAppleID.auth.init({\n  clientId: YOUR_APPLE_CLIENT_ID,\n  scope: \'name email\',\n  redirectURI: URL_TO_YOUR_REDIRECT_HANDLER,  // See the next step.\n  state: \'[STATE]\',  // Optional value that Apple will send back to you\n  nonce: HASHED_NONCE  // The hashed nonce you generated in the previous step.\n});\n</script>\n```']","Objective-C에서 Firebase 다단계 인증(MFA) 사용자를 인증하는 방법은 다음과 같습니다. 사용자가 다단계 인증을 완료하기 위해 추가 인증 정보를 제공해야 할 때, `FIRMultiFactorResolver`를 사용하여 추가 인증 단계를 처리할 수 있습니다. 아래는 관련 코드 예시입니다:

1. 사용자가 로그인할 때 다단계 인증이 필요한 경우를 처리합니다.

```objective-c
[[FIRAuth auth] signInWithEmail:email
    password:password
    completion:^(FIRAuthDataResult * _Nullable authResult,
                 NSError * _Nullable error) {
        if (error == nil || error.code != FIRAuthErrorCodeSecondFactorRequired) {
            // User is not enrolled with a second factor and is successfully signed in.
            // ...
        } else {
            // The user is a multi-factor user. Second factor challenge is required.
            FIRMultiFactorResolver *resolver = error.userInfo[FIRAuthErrorUserInfoMultiFactorResolverKey];
            // 추가 인증 처리 로직
        }
    }];
```

2. 다단계 인증을 완료하기 위해 사용자가 제공한 인증 정보를 사용하여 인증을 완료합니다.

```objective-c
[resolver resolveSignInWithAssertion:assertion
    completion:^(FIRAuthDataResult * _Nullable authResult,
                 NSError * _Nullable error) {
        if (error != nil) {
            // User successfully signed in with the second factor phone number.
        }
    }];
```

이 코드는 사용자가 다단계 인증을 요구받았을 때, `FIRMultiFactorResolver`를 사용하여 추가 인증 단계를 처리하는 방법을 보여줍니다. 사용자가 제공한 인증 정보를 사용하여 `resolveSignInWithAssertion` 메서드를 호출하여 인증을 완료합니다.","다단계 인증(MFA) 사용 시 Firebase에서 사용자 인증을 완료하는 방법은 FIRMultiFactorResolver를 통해 다단계 인증 정보를 가져온 후, 선택한 인증 방법으로 인증을 완료해야 합니다. Objective-C에서는 다음과 같이 작성합니다: 
FIRMultiFactorAssertion *assertion = [FIRPhoneMultiFactorGenerator assertionWithCredential:credential];
[resolver resolveSignInWithAssertion:assertion completion:^(FIRAuthDataResult * _Nullable authResult, NSError * _Nullable error) {
if (error) {
[self showMessagePrompt:error.localizedDescription];
NSLog(@""Multi factor finanlize sign in succeeded."");
FIRUser *user = authResult.user;"
Java를 사용해서 Firestore에 문서를 추가할 때 어떤 코드를 사용하나요?,"['Firestore는 컬렉션에 저장되는 문서에 데이터를 저장합니다.\n문서에 데이터를 처음 추가할 때 Firestore는 암시적으로 컬렉션과 문서를 만듭니다. 컬렉션이나 문서를 명시적으로 만들 필요가 없습니다.\n\n다음 예시 코드를 사용해 새 컬렉션과 문서를 만듭니다.\n\n--- 탭: 웹 버전 9 [https://cloud.google.com/firestore/native/docs/create-database-web-mobile-client-library?hl=ko#%EC%9B%B9-%EB%B2%84%EC%A0%84-9-modular] ---\nimport { collection, addDoc } from ""firebase/firestore"";\n\ntry {\nconst docRef = await addDoc(collection(db, ""users""), {\nfirst: ""Ada"",\nlast: ""Lovelace"",\nborn: 1815\n});\nconsole.log(""Document written with ID: "", docRef.id);\n} catch (e) {\nconsole.error(""Error adding document: "", e);\n}\nadd_ada_lovelace.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/snippets/firestore-next/test-firestore/add_ada_lovelace.js#L8-L19]'
 'Firestore는 컬렉션에 저장되는 문서에 데이터를 저장합니다.\n문서에 데이터를 처음 추가할 때 Firestore는 암시적으로 컬렉션과 문서를 만듭니다. 컬렉션이나 문서를 명시적으로 만들 필요가 없습니다.\n\n다음 예시 코드를 사용해 새 컬렉션과 문서를 만듭니다.\n\n--- 탭: Java [https://cloud.google.com/firestore/native/docs/create-database-server-client-library?hl=ko#java] ---\n```\nDocumentReference docRef = db.collection(""users"").document(""alovelace"");\n// Add document data  with id ""alovelace"" using a hashmap\nMap<String, Object> data = new HashMap<>();\ndata.put(""first"", ""Ada"");\ndata.put(""last"", ""Lovelace"");\ndata.put(""born"", 1815);\n//asynchronously write data\nApiFuture<WriteResult> result = docRef.set(data);\n// ...\n// result.get() blocks on response\nSystem.out.println(""Update time : "" + result.get().getUpdateTime());\n```\n\n--- 탭: Python [https://cloud.google.com/firestore/native/docs/create-database-server-client-library?hl=ko#python] ---\n```\ndoc_ref = db.collection(""users"").document(""alovelace"")\ndoc_ref.set({""first"": ""Ada"", ""last"": ""Lovelace"", ""born"": 1815})\n```'
 'Gradle을 사용하거나 BOM 없이 설정하는 경우 자바용 Firestore 클라이언트 README [https://github.com/googleapis/java-firestore/tree/main#quickstart]를 참조하세요.\n\nIDE 사용:\nVS Code, IntelliJ, Eclipse를 사용하는 경우 다음과 같은 IDE 플러그인을 사용하여 클라이언트 라이브러리를 프로젝트에 추가할 수 있습니다.\n\nVS Code용 Cloud Code [https://cloud.google.com/code/docs/vscode/client-libraries?hl=ko]\nIntelliJ용 Cloud Code [https://cloud.google.com/code/docs/intellij/client-libraries?hl=ko]\nEclipse용 Cloud Tools [https://cloud.google.com/eclipse/docs/libraries?hl=ko]\n\n이 플러그인은 서비스 계정의 키 관리와 같은 추가 기능을 제공합니다. 자세한 내용은 각 플러그인의 문서를 참조하세요.\n\nPython\n\n앱에 Firestore Python 라이브러리를 추가합니다.\n참고: 가상 Python 환경 [https://virtualenv.pypa.io/en/stable/]을 사용하여 Firestore Python 라이브러리를 설치하는 것이 좋습니다.\npip install virtualenv\nvirtualenv env\nsource env/bin/activate\n\npip install --upgrade google-cloud-firestore\n\nNode.js\n앱에 Firestore Node.js 라이브러리를 추가합니다.\nnpm install --save @google-cloud/firestore\n\nGo\nFirestore Go 라이브러리를 설치합니다.\ngo get cloud.google.com/go/firestore\n앱에 Firestore Go 라이브러리를 추가합니다.\nimport ""cloud.google.com/go/firestore""\n\nPHP\n\n클라이언트 라이브러리를 사용하는 데 필요한 PHP용 gRPC 확장 프로그램 [https://cloud.google.com/php/grpc?hl=ko]을 설치하고 사용 설정합니다.'
 '이 문서에서는 프로그래매틱 방식으로 Firestore에 인증하는 방법을 설명합니다. Firestore 인증 방법은 API에 액세스하는 데 사용하는 인터페이스와 코드가 실행되는 환경에 따라 다릅니다.\n\n이 페이지의 정보는 서버 클라이언트 라이브러리, REST 및 RPC API를 사용할 때 적용됩니다. 모바일 또는 웹 클라이언트용 클라이언트 라이브러리를 사용하는 경우 인증은 Firestore 보안 규칙과 Firebase 인증의 조합으로 관리됩니다. 자세한 내용은 모바일 및 웹 클라이언트의 데이터 보안 [https://cloud.google.com/firestore/docs/security/get-started?hl=ko]을 참고하세요.\n\nGoogle Cloud 인증에 대한 자세한 내용은 인증 메서드 [https://cloud.google.com/docs/authentication?hl=ko]를 참조하세요.\n\nAPI 액세스\n\nFirestore는 프로그래매틱 액세스를 지원합니다. 다음 방법으로 API에 액세스할 수 있습니다.\n\n클라이언트 라이브러리 [https://cloud.google.com/firestore/native/docs/authentication?hl=ko#client-libraries]\n\nGoogle Cloud CLI [https://cloud.google.com/firestore/native/docs/authentication?hl=ko#gcloud]\n\n클라이언트 라이브러리\n\nFirestore 클라이언트 라이브러리 [https://cloud.google.com/firestore/native/docs/reference/libraries?hl=ko]는 프로그래매틱 방식으로 Firestore에 인증하기 위한 고급 언어 지원을 제공합니다.\n\nGoogle Cloud API 호출을 인증하기 위해 클라이언트 라이브러리는 애플리케이션 기본 사용자 인증 정보(ADC) [https://cloud.google.com/docs/authentication/application-default-credentials?hl=ko]를 지원합니다. 라이브러리는 정의된 위치 집합에서 사용자 인증 정보를 찾고 이러한 사용자 인증 정보를 사용해서 API에 대한 요청을 인증합니다. ADC를 사용하면 애플리케이션 코드를 수정할 필요 없이 로컬 개발 또는 프로덕션과 같은 다양한 환경에서 애플리케이션에 사용자 인증 정보를 제공할 수 있습니다.'
 '실시간 데이터베이스를 사용하여 Cloud Firestore 앱에 접속 상태를 추가하는 방법은 확장 가능하고 효율적이지만 몇 가지 제한사항이 있습니다.\n\n디바운싱 - Cloud Firestore에서 실시간 변경사항을 리슨하는 경우 이 솔루션은 여러 변경사항을 트리거할 수 있습니다. 이러한 변경사항으로 인해 이벤트가 너무 많이 트리거되면 Cloud Firestore 이벤트를 수동으로 디바운싱합니다.\n연결 - 이 구현에서는 Cloud Firestore가 아닌 실시간 데이터베이스에 대한 연결을 측정합니다. 각 데이터베이스에 대한 연결 상태가 동일하지 않으면 이 솔루션은 정확하지 않은 접속 상태를 보고할 수 있습니다.\nAndroid - Android에서 실시간 데이터베이스는 비활성 상태가 60초간 지속되면 백엔드에서 연결을 끊습니다. 비활성 상태란 열린 상태의 리스너나 대기 중인 작업이 없다는 의미입니다. 연결을 열린 상태로 유지하려면 값 이벤트 리스너를 .info/connected 외의 경로에 추가하는 것이 좋습니다. 예를 들어 각 세션 시작 시 FirebaseDatabase.getInstance().getReference((new Date()).toString()).keepSynced()를 실행하는 방법이 있습니다. 자세한 내용은 연결 상태 감지 [https://firebase.google.com/docs/database/android/offline-capabilities?hl=ko#section-connection-state]를 참조하세요.\n\n의견 보내기'
 ""--- 탭: 웹 [https://firebase.google.com/docs/firestore/solutions/presence?hl=ko#%EC%9B%B9] ---\nfirebase.firestore().collection('status')\n.where('state', '==', 'online')\n.onSnapshot(function(snapshot) {\nsnapshot.docChanges().forEach(function(change) {\nif (change.type === 'added') {\nvar msg = 'User ' + change.doc.id + ' is online.';\nconsole.log(msg);\n// ...\n}\nif (change.type === 'removed') {\nvar msg = 'User ' + change.doc.id + ' is offline.';\nconsole.log(msg);\n// ...\n}\n});\n});\nindex.js [https://github.com/firebase/functions-samples/blob/c4fde45b65fab584715e786ce3264a6932d996ec/Node-1st-gen/presence-firestore/public/index.js#L128-L147]\n제한사항\n\n실시간 데이터베이스를 사용하여 Cloud Firestore 앱에 접속 상태를 추가하는 방법은 확장 가능하고 효율적이지만 몇 가지 제한사항이 있습니다.""
 '$collection = $db->collection(\'samples/php/users\');\n\nUnity\nCollectionReference collectionRef = db.Collection(""users"");\n\nC#\n\nC#\n\nFirestore에 인증하려면 애플리케이션 기본 사용자 인증 정보를 설정합니다.\n자세한 내용은 로컬 개발 환경의 인증 설정 [https://cloud.google.com/docs/authentication/set-up-adc-local-dev-environment?hl=ko]을 참조하세요.\n\nCollectionReference collectionRef = db.Collection(""users"");\n\nRuby\n\ncollection_ref = firestore.col ""users""data_model.rb [https://github.com/googleapis/google-cloud-ruby/blob/17e1723270824384f648d9a49a2edd6f6647ff6f/google-cloud-firestore/samples/data_model.rb#L31-L31]\n\n참고: 컬렉션 참조 및 문서 참조는 서로 구분되는 두 가지 참조 유형으로서 서로 다른 작업을 수행하는 데 사용할 수 있습니다. 예를 들어 컬렉션 참조를 사용하면 컬렉션의 문서를 쿼리할 수 있고, 문서 참조를 사용하면 개별 문서를 읽거나 쓸 수 있습니다.\n편의상 경로 구성요소를 포워드 슬래시(/)로 구분한 문자열로 문서 또는 컬렉션의 경로를 지정해 참조를 만들 수도 있습니다. 예를 들어 alovelace 문서에 대한 참조를 만드는 방법은 다음과 같습니다.\n\n웹 버전 9\nimport { doc } from ""firebase/firestore"";\n\nconst alovelaceDocumentRef = doc(db, \'users/alovelace\');doc_reference_alternative.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/snippets/firestore-next/test-firestore/doc_reference_alternative.js#L8-L10]\n\n웹 버전 8'
 '역할 부여에 대한 자세한 내용은 프로젝트, 폴더, 조직에 대한 액세스 관리 [https://cloud.google.com/iam/docs/granting-changing-revoking-access?hl=ko]를 참조하세요.\n\n커스텀 역할 [https://cloud.google.com/iam/docs/creating-custom-roles?hl=ko]이나 다른 사전 정의된 역할 [https://cloud.google.com/iam/docs/roles-overview?hl=ko#predefined]을 통해 필요한 권한을 얻을 수도 있습니다.\n\n커스텀 제약조건 만들기\n\n커스텀 제약조건은 조직 정책을 적용하는 서비스에서 지원되는 리소스, 메서드, 조건, 작업을 사용하여 YAML 파일에서 정의됩니다. 커스텀 제약조건의 조건은 Common Expression Language(CEL) [https://github.com/google/cel-spec/blob/master/doc/intro.md]를 사용하여 정의됩니다. CEL을 사용해서 커스텀 제약조건에서 조건을 빌드하는 방법은 커스텀 제약조건 만들기 및 관리 [https://cloud.google.com/resource-manager/docs/organization-policy/creating-managing-custom-constraints?hl=ko#common_expression_language]의 CEL 섹션을 참조하세요.\n\n커스텀 제약조건을 만들려면 다음 형식을 사용하여 YAML 파일을 만듭니다.\n\nname: organizations/ORGANIZATION_ID/customConstraints/CONSTRAINT_NAME\nresourceTypes:\n- RESOURCE_NAME\nmethodTypes:\n- CREATE\n- UPDATE\ncondition: ""CONDITION""\nactionType: ACTION\ndisplayName: DISPLAY_NAME\ndescription: DESCRIPTION\n\n다음을 바꿉니다.'
 "". You'll learn first hand how Firebase's Firestore and Storage streamline data management and mediaYouTubeNon-relational databases design patterns: How Shopify leverages them to power their businessWhen your data outgrows the confines of traditional relational models, Google Cloud's databases offer the solution. This session will explore how to harness the power of distributed architectures and flexible schemas to handle massive datasets. We'llYouTubeCloud SQL, Cloud Spanner, or Firestore?Be a Cloud Digital Leader! https://goo.gle/CDL What's the difference between Cloud SQL, Cloud Spanner, and Firestore, and how do you know when to choose one over the other? This video breaks it down to help you on your journey to become Cloud DigitalYouTubeBuilding a next-generation scalable gaming platform using FirestoreGaming innovators rely on Firestore for its flexibility, simplified scalability and hands-free serverless management""
 ""서비스 계정 가장 [https://cloud.google.com/firestore/native/docs/authentication?hl=ko#sa-impersonation]\n\n클라이언트 라이브러리 또는 서드 파티 도구\n\n로컬 환경에서 애플리케이션 기본 사용자 인증 정보(ADC) [https://cloud.google.com/docs/authentication/application-default-credentials?hl=ko]를 설정합니다.\n\nInstall [https://cloud.google.com/sdk/docs/install?hl=ko] the Google Cloud CLI.\n\nAfter installation,\ninitialize [https://cloud.google.com/sdk/docs/initializing?hl=ko] the Google Cloud CLI by running the following command:\n\ngcloud init\n\nIf you're using an external identity provider (IdP), you must first\nsign in to the gcloud CLI with your federated identity [https://cloud.google.com/iam/docs/workforce-log-in-gcloud?hl=ko].\n\nIf you're using a local shell, then create local authentication credentials for your user\naccount:\n\ngcloud auth application-default login\n\nYou don't need to do this if you're using Cloud Shell.\n\nIf an authentication error is returned, and you are using an external identity provider\n(IdP), confirm that you have\nsigned in to the gcloud CLI with your federated identity [https://cloud.google.com/iam/docs/workforce-log-in-gcloud?hl=ko].""
 '참고: 새 프로젝트에서 기본(최신) SDK 버전을 사용해야 하지만, 필요하면 이전 버전을 선택할 수도 있습니다.\nFirestore 라이브러리를 선택합니다.\n완료되면 Xcode가 백그라운드에서 자동으로 종속 항목을 확인하고 다운로드하기 시작합니다.\n\n--- 탭: Android [https://firebase.google.com/docs/firestore/quickstart?hl=ko#android] ---\n```\ndependencies {\n// Import the BoM for the Firebase platform\nimplementation(platform(""com.google.firebase:firebase-bom:34.2.0""))\n\n// Declare the dependency for the Cloud Firestore library\n// When using the BoM, you don\'t specify versions in Firebase library dependencies\nimplementation(""com.google.firebase:firebase-firestore"")\n}\n```\n\n--- 탭: Dart [https://firebase.google.com/docs/firestore/quickstart?hl=ko#dart-flutter] ---\n아직 구성하지 않았다면 Flutter 앱에서 Firebase를 구성하고 초기화 [https://firebase.google.com/docs/flutter/setup?hl=ko]합니다.\nFlutter 프로젝트 루트에서 다음 명령어를 실행하여 플러그인을 설치합니다.\nflutter pub add cloud_firestore\n완료되면 Flutter 애플리케이션을 다시 빌드합니다.\nflutter run\n선택사항: 사전 컴파일된 프레임워크를 포함하여 iOS 및 macOS 빌드 시간을 개선합니다.\n현재 iOS용 Firestore SDK는 Xcode에서 빌드하는 데 5분 이상 걸릴 수 있는 코드를 사용합니다. 빌드 시간을 크게 줄이려면 Podfile의 target \'Runner\' do 블록에 다음 줄을 추가하여 사전 컴파일된 버전을 사용하면 됩니다.\ntarget \'Runner\' do\nuse_frameworks!\nuse_modular_headers!'
 ""BigQuery Sandbox → https://goo.gle/3RHQoZS Did you know there are multiple ways to store data on Google Cloud? In this episode of Google Cloud Platform Essentials, Ryan Matsumoto shows how youYouTubeGet started with FirestoreHere to bring you the latest news in the startup program by Google Cloud is Mirabel Tukiman! Welcome to the second season of the Google Cloud Technical Guides for Startups - the Build Series. Build Series - Episode 3: How to configure Firestore TuneYouTubeAsynchronous operations in UI using Workflows and FirestoreMany app operations take time. Long computations may take minutes or hours, perhaps waiting for limited resources and retrying failures. Connecting to real-world processes like 3D printing or a human approver can take days. When users perform theseYouTubeIntroduction to Google CloudCheckout this architecture in our NEW Architecture Diagramming Tool → https://goo.gle/3GUIztk When it comes to building your organization's app in the cloud you have many options. In this video Priyanka gives the complete overview of various GoogleYouTubeDesigning a serverless finance system on Google CloudIdentity Aware Proxy → https://goo.gle/3DqLybV""
 'August 09, 2018\n\nWe added two new features to help you work with arrays:\n\nArray contains queries [https://cloud.google.com/firestore/docs/query-data/queries#array_membership]: query for documents that contain a particular array value.\nArray transforms [https://cloud.google.com/firestore/docs/manage-data/add-data#update_elements_in_an_array]: the arrayUnion() and arrayRemove() functions allow you to directly modify array field values.\n\nAugust 08, 2018\n\nYou can now create a Cloud Firestore database in Datastore mode [https://cloud.google.com/firestore/docs/firestore-or-datastore#choosing_a_database]. Datastore mode allows you to use Cloud Datastore client libraries with an improved Cloud Firestore storage layer, removing eventual consistency limitations.\n\nCloud Firestore now supports the europe-west3 and us-east1 regions, see Cloud Firestore Locations [https://cloud.google.com/firestore/docs/locations].\n\nYou can now add single-field index exemptions [https://cloud.google.com/firestore/docs/concepts/index-overview#exemptions] to exempt specific fields from automatic indexing.'
 'Q: Java에서 Firestore에 새 문서를 추가하는 방법은 무엇인가요?\nA: 다음 예시 코드를 사용해 Java에서 Firestore에 새 문서를 추가할 수 있습니다.\n\n```java\n// Create a new user with a first and last name\nMap<String, Object> user = new HashMap<>();\nuser.put(""first"", ""Ada"");\nuser.put(""last"", ""Lovelace"");\nuser.put(""born"", 1815);\n\n// Add a new document with a generated ID\ndb.collection(""users"")\n.add(user)\n.addOnSuccessListener(new OnSuccessListener<DocumentReference>() {\n@Override\npublic void onSuccess(DocumentReference documentReference) {\nLog.d(TAG, ""DocumentSnapshot added with ID: "" + documentReference.getId());\n}\n})\n.addOnFailureListener(new OnFailureListener() {\n@Override\npublic void onFailure(@NonNull Exception e) {\nLog.w(TAG, ""Error adding document"", e);\n}\n});\n```'
 'Q: Java에서 Firestore에 문서를 추가하는 방법은 무엇인가요?\nA: Java에서 Firestore에 문서를 추가하려면, CollectionReference를 사용하여 컬렉션을 참조하고, 각 문서에 대해 set 메서드를 호출하여 데이터를 설정합니다. 예를 들어:\n\n```java\nCollectionReference cities = db.collection(""cities"");\n\nMap<String, Object> data1 = new HashMap<>();\ndata1.put(""name"", ""San Francisco"");\ndata1.put(""state"", ""CA"");\ndata1.put(""country"", ""USA"");\ndata1.put(""capital"", false);\ndata1.put(""population"", 860000);\ndata1.put(""regions"", Arrays.asList(""west_coast"", ""norcal""));\ncities.document(""SF"").set(data1);\n// 추가 문서도 같은 방식으로 설정\n```'
 'Q: Java에서 Firestore에 문서를 추가할 때, add() 메서드를 사용하는 방법은 무엇인가요?\nA: Java에서 Firestore에 문서를 추가할 때는 add() 메서드를 사용합니다. 아래는 예제 코드입니다.\n\n```java\nMap<String, Object> data = new HashMap<>();\n\nDocumentReference newCityRef = db.collection(""cities"").document();\n\n// Later...\nnewCityRef.set(data);\n```'
 'Q: Java에서 Firestore에 문서를 추가할 때 merge 옵션을 사용하는 방법은 무엇인가요?\nA: 다음 코드를 사용하여 Firestore에 문서를 추가할 수 있습니다. SetOptions.merge()를 사용하여 기존 문서와 병합됩니다.\n\n```java\nMap<String, Object> data = new HashMap<>();\ndata.put(""capital"", true);\n\ndb.collection(""cities"").document(""BJ"")\n    .set(data, SetOptions.merge());\n```'
 'Q: Java에서 Firestore에 문서를 추가할 때 add() 메서드를 사용하는 방법은 무엇인가요?\nA: 다음은 Java에서 Firestore에 문서를 추가할 때 add() 메서드를 사용하는 예제입니다.\n\n```java\nMap<String, Object> data = new HashMap<>();\ndata.put(""name"", ""Tokyo"");\ndata.put(""country"", ""Japan"");\n\ndb.collection(""cities"")\n    .add(data)\n    .addOnSuccessListener(new OnSuccessListener<DocumentReference>() {\n        @Override\n        public void onSuccess(DocumentReference documentReference) {\n            Log.d(TAG, ""DocumentSnapshot written with ID: "" + documentReference.getId());\n        }\n    })\n    .addOnFailureListener(new OnFailureListener() {\n        @Override\n        public void onFailure(@NonNull Exception e) {\n            Log.w(TAG, ""Error adding document"", e);\n        }\n    });\n```'
 'Q: Python에서 Cloud Firestore에 문서를 추가하는 방법은 무엇인가요?\nA: Python에서 Cloud Firestore에 문서를 추가하는 방법은 다음과 같습니다:\n\n```python\ncity = City(name=""Los Angeles"", state=""CA"", country=""USA"")\ndb.collection(""cities"").document(""LA"").set(city.to_dict())\n```'
 ""Q: PHP에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: 다음은 PHP에서 Cloud Firestore에 문서를 추가하는 코드 예시입니다.\n\n```php\n$db->collection('samples/php/cities')->document('new-city-id')->set($data);\n```""
 'Q: Unity에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: 다음은 Unity에서 Cloud Firestore에 문서를 추가하는 코드 예시입니다.\n\n```csharp\ndb.Collection(""cities"").Document(""new-city-id"").SetAsync(city);\n```'
 'Q: C++에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: 다음은 C++에서 Cloud Firestore에 문서를 추가하는 코드 예시입니다.\n\n```cpp\ndb->Collection(""cities"").Document(""SF"").Set({/*some data*/});\n```'
 'Q: Swift에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Swift에서 Cloud Firestore에 문서를 추가하는 기본적인 코드는 다음과 같습니다.\n\n```swift\ndb.collection(""cities"").document(""new-city-id"").setData(data)\n```'
 'Q: C++에서 Cloud Firestore에 문서를 추가하는 기본적인 방법은 무엇인가요?\nA: db->Collection(""cities"").Add({/*some data*/});'
 'Q: Kotlin에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Kotlin에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 다음과 같습니다.\n\n```kotlin\ndb.collection(""cities"").document(""new-city-id"").set(data)\n```'
 'Q: Swift에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Swift에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 다음과 같습니다.\n\n```swift\ndb.collection(""cities"").document(""new-city-id"").setData(data)\n```'
 'Q: Java에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Java에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 다음과 같습니다.\n\n```java\ndb.collection(""cities"").document(""new-city-id"").set(data);\n```'
 'Q: Java에서 Cloud Firestore에 문서를 추가하는 방법은 무엇인가요?\nA: Java에서 Cloud Firestore에 문서를 추가하는 방법은 다음과 같습니다:\n\n```java\nCity city = new City(""Los Angeles"", ""CA"", ""USA"", false, 5000000L, Arrays.asList(""west_coast"", ""sorcal""));\ndb.collection(""cities"").document(""LA"").set(city);\n```'
 'Q: Unity에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Unity에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 다음과 같습니다.\n\n```csharp\nawait db.Collection(""cities"").Document(""new-city-id"").SetAsync(city);\n```'
 'Q: Dart에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Dart에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 다음과 같습니다.\n\n```dart\ndb.collection(""cities"").doc(""new-city-id"").set({""name"": ""Chicago""});\n```'
 'Q: Kotlin에서 Cloud Firestore에 문서를 추가하는 방법은 무엇인가요?\nA: Kotlin에서 Cloud Firestore에 문서를 추가하는 방법은 다음과 같습니다:\n\n```kotlin\nval city = City(\n    ""Los Angeles"",\n    ""CA"",\n    ""USA"",\n    false,\n    5000000L,\n    listOf(""west_coast"", ""socal""),\n)\ndb.collection(""cities"").document(""LA"").set(city)\n```'
 'Q: Python에서 Cloud Firestore에 문서를 추가하는 비동기 방식의 기본적인 코드 예시는 무엇인가요?\nA: 다음은 Python에서 Cloud Firestore에 문서를 비동기적으로 추가하는 코드 예시입니다.\n\n```python\nawait db.collection(""cities"").document(""new-city-id"").set(data)\n```'
 'Q: C++에서 Cloud Firestore에 문서를 병합하여 추가하는 방법은 무엇인가요?\nA: db->Collection(""cities"").Document(""BJ"").Set(\n{{""capital"", FieldValue::Boolean(true)}}, SetOptions::Merge());'
 'Q: Ruby에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Ruby에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 다음과 같습니다.\n\n```ruby\ncity_ref = firestore.doc ""#{collection_path}/new-city-id""\ncity_ref.set data\n```'
 'Q: Python에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Python에서 Cloud Firestore에 문서를 추가하는 기본적인 코드는 다음과 같습니다.\n\n```python\ncity = City(name=""Los Angeles"", state=""CA"", country=""USA"")\ndb.collection(""cities"").document(""LA"").set(city.to_dict())\n```'
 'Q: Python에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 무엇인가요?\nA: Python에서 Cloud Firestore에 문서를 추가하는 기본적인 코드 예시는 다음과 같습니다.\n\n```python\n# ... (Python 코드 예시가 문서에 포함되어 있지 않음)\n```'
 'Q: Python에서 Firestore에 새 문서를 추가하는 방법은 무엇인가요?\nA: 다음 예시 코드를 사용해 Firestore에 새 문서를 추가할 수 있습니다.\n\n```python\ndoc_ref = db.collection(""users"").document(""alovelace"")\ndoc_ref.set({""first"": ""Ada"", ""last"": ""Lovelace"", ""born"": 1815})\n```'
 'Q: Swift에서 Cloud Firestore에 문서를 병합하여 추가하는 방법은 무엇인가요?\nA: Swift에서 Cloud Firestore에 문서를 병합하여 추가하려면 다음과 같은 코드를 사용할 수 있습니다.\n\n```swift\ndb.collection(""cities"").document(""BJ"").setData([ ""capital"": true ], merge: true)\n```'
 'Q: Java에서 Firestore에 새 문서를 추가하는 방법은 무엇인가요?\nA: // Create a new user with a first and last name\nMap<String, Object> user = new HashMap<>();\nuser.put(""first"", ""Ada"");\nuser.put(""last"", ""Lovelace"");\nuser.put(""born"", 1815);\n\n// Add a new document with a generated ID\ndb.collection(""users"")\n    .add(user)\n    .addOnSuccessListener(new OnSuccessListener<DocumentReference>() {\n        @Override\n        public void onSuccess(DocumentReference documentReference) {\n            Log.d(TAG, ""DocumentSnapshot added with ID: "" + documentReference.getId());\n        }\n    })\n    .addOnFailureListener(new OnFailureListener() {\n        @Override\n        public void onFailure(@NonNull Exception e) {\n            Log.w(TAG, ""Error adding document"", e);\n        }\n    });'
 'Q: Cloud Firestore에서 문서의 특정 필드 값을 가져오는 방법은 무엇인가요?\nA: Node.js\n// Fetch data using standard accessors\nconst age = event.data.after.data().age;\nconst name = event.data.after.data()[\'name\'];\n\n// Fetch data using built in accessor\nconst experience = event.data.after.data.get(\'experience\');\n\nPython\n# Get the value of a single document field.\nage = event.data.after.get(""age"")\n\n# Convert the document to a dictionary.\nage = event.data.after.to_dict()[""age""]'
 'Q: Node.js에서 Cloud Firestore의 \'regions\' 배열 필드에 여러 지역을 원자적으로 추가하는 방법은 무엇인가요?\nA: // ...\nconst washingtonRef = db.collection(\'cities\').doc(\'DC\');\n\n// Atomically add a new region to the ""regions"" array field.\nconst unionRes = await washingtonRef.update({\nregions: FieldValue.arrayUnion(\'greater_virginia\')\n});\n// Atomically remove a region from the ""regions"" array field.\nconst removeRes = await washingtonRef.update({\nregions: FieldValue.arrayRemove(\'east_coast\')\n});\n// To add or remove multiple items, pass multiple arguments to arrayUnion/arrayRemove\nconst multipleUnionRes = await washingtonRef.update({\nregions: FieldValue.arrayUnion(\'south_carolina\', \'texas\')\n// Alternatively, you can use spread operator in ES6 syntax\n// const newRegions = [\'south_carolina\', \'texas\']\n// regions: FieldValue.arrayUnion(...newRegions)\n});'
 ""Q: 샤딩된 타임스탬프를 사용하여 문서에 shard 필드를 추가하는 방법은 무엇인가요?\nA: // Add the new shard field to the document\nconst instruments = [\n{\nshard: randomShard(),  // add the new shard field to the document\nsymbol: 'AAA',\nprice: {\ncurrency: 'USD',\nmicros: 34790000\n},\nexchange: 'EXCHG1',\ninstrumentType: 'commonstock',\ntimestamp: Timestamp.fromMillis(\nDate.parse('2019-01-01T13:45:23.010Z'))\n},\n{\nshard: randomShard(),  // add the new shard field to the document\nsymbol: 'BBB',\nprice: {\ncurrency: 'JPY',\nmicros: 64272000000\n},\nexchange: 'EXCHG2',\ninstrumentType: 'commonstock',\ntimestamp: Timestamp.fromMillis(\nDate.parse('2019-01-01T13:45:23.101Z'))\n}\n];""
 'Q: Java에서 Cloud Firestore에서 특정 주(state)가 \'CA\'인 도시를 쿼리한 후 결과를 비동기적으로 가져오는 방법은 무엇인가요?\nA: // Create a reference to the cities collection\nCollectionReference cities = db.collection(""cities"");\n// Create a query against the collection.\nQuery query = cities.whereEqualTo(""state"", ""CA"");\n// retrieve  query results asynchronously using query.get()\nApiFuture<QuerySnapshot> querySnapshot = query.get();\n\nfor (DocumentSnapshot document : querySnapshot.get().getDocuments()) {\n    System.out.println(document.getId());\n}'
 ""Q: Firestore에서 필드(Field)의 이름(name) 형식은 무엇인가요?\nA: | Fields |\n| --- |\n| name | string A field name of the form projects/{projectId}/databases/{databaseId}/collectionGroups/{collectionId}/fields/{fieldPath} A field path may be a simple field name, e.g. address or a path to fields within mapValue , e.g. address.city, or a special field path. The only valid special field is *, which represents any field. Field paths may be quoted using (backtick). The only character that needs to be escaped within a quoted field path is the backtick character itself, escaped using a backslash. Special characters in field paths that must be quoted include:*,., ``` (backtick),[,]`, as well as any ascii symbolic characters. Examples: (Note: Comments here are written in markdown syntax, so there is an additional layer of backticks to represent a code block) \\address.city`represents a field namedaddress.city, not the map key cityin the fieldaddress. `*`represents a field named*`, not any field. A special Field contains the default indexing settings for all fields. This field's resource name is: projects/{projectId}/databases/{databaseId}/collectionGroups/__default__/fields/* Indexes defined on this Field will be applied to all fields which do not have their own Field index configuration. |""
 'Q: Cloud Firestore를 Android 앱에 추가하는 방법은 무엇인가요?\nA: ```\ndependencies {\n// Import the BoM for the Firebase platform\nimplementation(platform(""com.google.firebase:firebase-bom:34.2.0""))\n\n// Declare the dependency for the Cloud Firestore library\n// When using the BoM, you don\'t specify versions in Firebase library dependencies\nimplementation(""com.google.firebase:firebase-firestore"")\n}\n```'
 'Q: Java에서 Firestore에 쿼리를 생성할 때, \'capital\' 필드가 true인 모든 도시를 반환하는 방법은 무엇인가요?\nA: 다음과 같이 쿼리를 생성할 수 있습니다:\n\n```java\n// Create a reference to the cities collection\nCollectionReference cities = db.collection(""cities"");\n// Create a query against the collection.\nQuery query = cities.whereEqualTo(""capital"", true);\n// retrieve  query results asynchronously using query.get()\nApiFuture<QuerySnapshot> querySnapshot = query.get();\n\nfor (DocumentSnapshot document : querySnapshot.get().getDocuments()) {\n    System.out.println(document.getId());\n}\n```'
 'Q: Cloud Firestore를 Android 앱에 추가하는 방법은 무엇인가요?\nA: 다음과 같이 dependencies 블록에 Cloud Firestore 라이브러리를 추가합니다:\n```\ndependencies {\n// Import the BoM for the Firebase platform\nimplementation(platform(""com.google.firebase:firebase-bom:34.2.0""))\n\n// Declare the dependency for the Cloud Firestore library\n// When using the BoM, you don\'t specify versions in Firebase library dependencies\nimplementation(""com.google.firebase:firebase-firestore"")\n}\n```'
 'Q: Cloud Firestore를 Android 앱에 추가하기 위해 필요한 Gradle 설정은 무엇인가요?\nA: ```\ndependencies {\n// Import the BoM for the Firebase platform\nimplementation(platform(""com.google.firebase:firebase-bom:34.2.0""))\n\n// Declare the dependency for the Cloud Firestore library\n// When using the BoM, you don\'t specify versions in Firebase library dependencies\nimplementation(""com.google.firebase:firebase-firestore"")\n}\n```'
 'Q: Java에서 Cloud Firestore의 \'regions\' 배열 필드에 여러 지역을 원자적으로 추가하는 방법은 무엇인가요?\nA: DocumentReference washingtonRef = db.collection(""cities"").document(""DC"");\n\n// Atomically add a new region to the ""regions"" array field.\nwashingtonRef.update(""regions"", FieldValue.arrayUnion(""greater_virginia""));\n\n// Atomically remove a region from the ""regions"" array field.\nwashingtonRef.update(""regions"", FieldValue.arrayRemove(""east_coast""));'
 'Q: Geohash 도우미 라이브러리를 설치하는 방법은 무엇인가요?\nA: // Install from NPM. If you prefer to use a static .js file visit\n// https://github.com/firebase/geofire-js/releases and download\n// geofire-common.min.js from the latest version\nnpm install --save geofire-common'
 'Q: Python에서 Firestore 문서의 변경에 따라 벡터 임베딩을 계산하고 저장하는 Cloud 함수의 예시는 무엇인가요?\nA: @functions_framework.cloud_event\n\ndef store_embedding(cloud_event) -> None:\n    """"""Triggers by a change to a Firestore document.""\n    firestore_payload = firestore.DocumentEventData()\n    payload = firestore_payload._pb.ParseFromString(cloud_event.data)\n\n    collection_id, doc_id = from_payload(payload)\n    # Call a function to calculate the embedding\n    embedding = calculate_embedding(payload)\n    # Update the document\n    doc = firestore_client.collection(collection_id).document(doc_id)\n    doc.set({""embedding_field"": embedding}, merge=True)'
 'Q: C#에서 Cloud Firestore의 \'regions\' 배열 필드에 여러 지역을 원자적으로 추가하는 방법은 무엇인가요?\nA: DocumentReference washingtonRef = db.Collection(""cities"").Document(""DC"");\n\n// Atomically add a new region to the ""regions"" array field.\nawait washingtonRef.UpdateAsync(""Regions"", FieldValue.ArrayUnion(""greater_virginia""));\n\n// Atomically remove a region from the ""regions"" array field.\nawait washingtonRef.UpdateAsync(""Regions"", FieldValue.ArrayRemove(""east_coast""));'
 'Q: C++에서 Firestore 클라이언트를 생성하는 방법은 무엇인가요?\nA: // Make sure the call to `Create()` happens some time before you call Firestore::GetInstance().\nApp::Create();\nFirestore* db = Firestore::GetInstance();'
 'Q: Node.js에서 gRPC spans를 활성화하려면 어떻게 해야 하나요?\nA: Node.js에서 gRPC spans를 활성화하려면 `GrpcInstrumentation`을 등록해야 합니다. 다음은 이를 위한 코드 예시입니다.\n\n```javascript\nregisterInstrumentations({\n  instrumentations: [\n    new GrpcInstrumentation(\n      // (optional): you can add GrpcInstrumentationConfig here\n    ),\n  ],\n});\n```'
 ""Q: 샤딩된 타임스탬프를 사용하여 문서에 shard 필드를 추가하는 방법은 무엇인가요?\nA: // Define our 'K' shard values\nconst shards = ['x', 'y', 'z'];\n\nasync function insertData() {\nconst instruments = [\n{\nshard: randomShard(),  // add the new shard field to the document\nsymbol: 'AAA',\nprice: {\ncurrency: 'USD',\nmicros: 34790000\n},\nexchange: 'EXCHG1',\ninstrumentType: 'commonstock',\ntimestamp: Timestamp.fromMillis(\nDate.parse('2019-01-01T13:45:23.010Z'))\n},\n{\nshard: randomShard(),  // add the new shard field to the document\nsymbol: 'BBB',\nprice: {\ncurrency: 'JPY',\nmicros: 64272000000\n},\nexchange: 'EXCHG2',\ninstrumentType: 'commonstock',\ntimestamp: Timestamp.fromMillis(\nDate.parse('2019-01-01T13:45:23.101Z'))\n},\n{\nshard: randomShard(),  // add the new shard field to the document\nsymbol: 'Index1 ETF',\nprice: {\ncurrency: 'USD',\nmicros: 473000000\n},\nexchange: 'EXCHG1',\ninstrumentType: 'etf',\ntimestamp: Timestamp.fromMillis(\nDate.parse('2019-01-01T13:45:23.001Z'))\n}\n];\n\nconst batch = fs.batch();\nfor (const inst of instruments) {\nconst ref = fs.collection('instruments').doc();\nbatch.set(ref, inst);\n}\n\nawait batch.commit();""
 'Q: Node.js에서 gRPC spans를 활성화하려면 어떻게 해야 하나요?\nA: Node.js에서 gRPC spans를 활성화하기 위해서는 `registerInstrumentations` 함수를 사용하여 `GrpcInstrumentation`을 추가해야 합니다. 아래는 그 예시입니다:\n\n```javascript\nregisterInstrumentations({\n  instrumentations: [\n    new GrpcInstrumentation(\n      // (optional): you can add GrpcInstrumentationConfig here\n    ),\n  ],\n});\n```'
 'Q: fieldPath 필드의 요구사항은 무엇인가요?\nA: | Fields |\n| --- |\n| fieldPath | string A reference to a field in a document. Requires: MUST be a dot-delimited (.) string of segments, where each segment conforms to document field name limitations. |'
 'Q: Python에서 Firestore 문서의 변경에 따라 벡터 임베딩을 저장하는 함수는 어떻게 정의하나요?\nA: Python에서 Firestore 문서의 변경에 따라 벡터 임베딩을 저장하는 함수는 다음과 같이 정의할 수 있습니다:\n\n```python\n@functions_framework.cloud_event\ndef store_embedding(cloud_event) -> None:\n    """"""Triggers by a change to a Firestore document.""\n    firestore_payload = firestore.DocumentEventData()\n    payload = firestore_payload._pb.ParseFromString(cloud_event.data)\n\n    collection_id, doc_id = from_payload(payload)\n    # Call a function to calculate the embedding\n    embedding = calculate_embedding(payload)\n    # Update the document\n    doc = firestore_client.collection(collection_id).document(doc_id)\n    doc.set({""embedding_field"": embedding}, merge=True)\n```'
 'Q: C++에서 Firestore 인스턴스를 초기화하는 방법은 무엇인가요?\nA: 다음은 C++에서 Firestore 인스턴스를 초기화하는 코드입니다.\n\n```cpp\n// Make sure the call to `Create()` happens some time before you call Firestore::GetInstance().\nApp::Create();\nFirestore* db = Firestore::GetInstance();\n```']","Java를 사용해서 Firestore에 문서를 추가할 때는 다음과 같은 코드를 사용할 수 있습니다:

```java
// Create a new user with a first and last name
Map<String, Object> user = new HashMap<>();
user.put(""first"", ""Ada"");
user.put(""last"", ""Lovelace"");
user.put(""born"", 1815);

// Add a new document with a generated ID
db.collection(""users"")
    .add(user)
    .addOnSuccessListener(new OnSuccessListener<DocumentReference>() {
        @Override
        public void onSuccess(DocumentReference documentReference) {
            Log.d(TAG, ""DocumentSnapshot added with ID: "" + documentReference.getId());
        }
    })
    .addOnFailureListener(new OnFailureListener() {
        @Override
        public void onFailure(@NonNull Exception e) {
            Log.w(TAG, ""Error adding document"", e);
        }
    });
```

이 코드는 Firestore에 새로운 문서를 추가하고, 성공 시 문서 ID를 로그에 출력하며, 실패 시 에러 메시지를 출력합니다.","다음은 Java에서 Firestore에 문서를 추가할 때 사용하는 코드 예시입니다.

```java
Map<String, Object> docData = new HashMap<>();
docData.put(""stringExample"", ""Hello, World"");
docData.put(""booleanExample"", false);
docData.put(""numberExample"", 3.14159265);
docData.put(""nullExample"", null);

ArrayList<Object> arrayExample = new ArrayList<>();
Collections.addAll(arrayExample, 5L, true, ""hello"");
docData.put(""arrayExample"", arrayExample);

Map<String, Object> objectExample = new HashMap<>();
objectExample.put(""a"", 5L);
objectExample.put(""b"", true);

docData.put(""objectExample"", objectExample);
```"
COLUMNS가 Dimension API에서 무슨 뜻인가요?,"['COLUMN_NAME: 임베딩 데이터가 포함된 열의 이름입니다. 이 열은 ARRAY<FLOAT64> 유형이어야 합니다. 열에 하위 필드가 있을 수 없습니다. 배열의 모든 요소는 NULL이 아니어야 하고 열의 모든 값은 배열 차원이 동일해야 합니다.\nSTORED_COLUMN_NAME: 벡터 색인에 저장할 테이블의 최상위 열 이름입니다. 열 유형은 RANGE일 수 없습니다. 테이블에 행 수준 액세스 정책이 있거나 열에 정책 태그가 있는 경우 저장된 열은 사용되지 않습니다. 저장된 열을 사용 설정하는 방법에 관한 자세한 내용은 열 저장 및 사전 필터링 [https://cloud.google.com/bigquery/docs/vector-index?hl=ko#stored-columns]을 참조하세요.\nDISTANCE_TYPE: 이 색인을 사용하여 벡터 검색을 실행할 때 사용할 기본 거리 유형을 지정하는 선택적 인수입니다. 지원되는 값은 EUCLIDEAN [https://en.wikipedia.org/wiki/Euclidean_distance], COSINE [https://en.wikipedia.org/wiki/Cosine_similarity#Cosine_Distance], DOT_PRODUCT [https://en.wikipedia.org/wiki/Dot_product]입니다. 기본값은 EUCLIDEAN입니다.\n색인 생성 자체는 항상 학습에 EUCLIDEAN 거리를 사용하지만 VECTOR_SEARCH 함수에 사용되는 거리는 다를 수 있습니다.\nVECTOR_SEARCH 함수의 distance_type 인수에 값을 지정하면 DISTANCE_TYPE 값 대신 해당 값이 사용됩니다.\nLEAF_NODE_EMBEDDING_COUNT: TreeAH 알고리즘이 생성하는 트리의 각 리프 노드에 있는 대략적인 벡터 수를 지정하는 500보다 크거나 같은 INT64 값입니다. TreeAH 알고리즘은 전체 데이터 공간을 여러 목록으로 나누며 각 목록에는 약 LEAF_NODE_EMBEDDING_COUNT개의 데이터 포인트가 포함됩니다. 값이 낮을수록 데이터 포인트가 적은 목록이 더 많이 생성되고 값이 클수록 데이터 포인트가 많은 목록이 더 적게 생성됩니다. 기본값은 1,000이며 대부분의 데이터 세트에 적합합니다.'
 'This feature is in preview [https://cloud.google.com/products/#product-launch-stages].\nAdding descriptions to the columns of a view is now generally available [https://cloud.google.com/products/#product-launch-stages] (GA). Use the CREATE VIEW [https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_view_statement] or ALTER COLUMN [https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#alter_column_set_options_statement] DDL statements to add descriptions.\nBigQuery is now available in the Dammam (me-central2) [https://cloud.google.com/bigquery/docs/locations#regional-locations] region.\nBigQuery ML is now available in the Dammam (me-central2) [https://cloud.google.com/bigquery-ml/docs/locations#regional-locations] region.\nBigQuery Data Transfer Service is now available in the Dammam (me-central2) [https://cloud.google.com/bigquery-transfer/docs/locations#regional-locations] region.\nOctober 05, 2023'
 'Columns 테이블은 우선순위에 따라 SVV_COLUMNS [https://docs.aws.amazon.com/redshift/latest/dg/r_SVV_COLUMNS.html],INFORMATION_SCHEMA.COLUMNS [https://www.postgresql.org/docs/current/infoschema-columns.html] 또는 PG_TABLE_DEF [https://docs.aws.amazon.com/redshift/latest/dg/r_PG_TABLE_DEF.html] 테이블 중 하나에서 가져옵니다. 도구는 우선순위가 가장 높은 테이블에서 먼저 데이터를 로드하려고 시도합니다. 이 작업이 실패하면 우선순위가 두 번째로 높은 테이블에서 데이터를 로드하려고 시도합니다. 스키마 및 사용에 대한 자세한 내용은 Amazon Redshift 또는 PostgreSQL 문서를 참조하세요.\n\n\n  \n    \n      열\n      유형\n      설명\n    \n  \n  \n    \n      DatabaseName\n      STRING\n      데이터베이스의 이름입니다.\n    \n    \n      SchemaName\n      STRING\n      스키마의 이름입니다.\n    \n    \n      TableName\n      STRING\n      테이블의 이름입니다.\n    \n    \n      ColumnName\n      STRING\n      열의 이름입니다.\n    \n    \n      DefaultValue\n      STRING\n      사용 가능한 경우 기본값입니다.\n    \n    \n      Nullable\n      BOOLEAN\n      열에 null 값이 있을 수 있는지 여부입니다.\n    \n    \n      ColumnType\n      STRING\n      열의 유형입니다(예: VARCHAR).\n    \n    \n      ColumnLength\n      INTEGER\n      열의 크기입니다(예: VARCHAR(30)의 경우 30).\n    \n  \n\n\nCreateAndDropStatistic\n\n이 테이블은 테이블 생성 및 삭제에 관한 정보를 제공합니다.'
 'Source URL: https://developers.google.com/workspace/sheets/api/reference/rest/v4/Dimension?hl=ko\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGoogle Sheets [https://developers.google.com/workspace/sheets?hl=ko]\n참조 [https://developers.google.com/workspace/sheets/api/reference/rest?hl=ko]\n의견 보내기\nDimension\nbookmark_border\n작업을 적용할 측정기준을 나타냅니다.\n열거형\nDIMENSION_UNSPECIFIED 기본값이며 사용할 수 없습니다.\nROWS 시트의 행에서 작동합니다.\nCOLUMNS 시트의 열에서 작동합니다.\n의견 보내기'
 'A string in the format bin_<bucket_index>\nA string in interval notation [https://en.wikipedia.org/wiki/Interval_(mathematics)]\nA JSON-formatted string\nYou can now use the BY NAME and CORRESPONDING modifiers [https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#by_name_or_corresponding] with set operations to match columns by name instead of by position. This feature is generally available [https://cloud.google.com/products#product-launch-stages] (GA).\nJanuary 28, 2025\nYou can now view stored column usage [https://cloud.google.com/bigquery/docs/reference/rest/v2/Job#StoredColumnsUsage] information for a query job that performs vector search using stored columns. This feature is generally available [https://cloud.google.com/products#product-launch-stages] (GA).\nJanuary 27, 2025\nA weekly digest of client library updates from across the Cloud SDK [https://cloud.google.com/sdk].\n--- 탭: Go [https://cloud.google.com/bigquery/docs/release-notes#go] ---\nChanges for bigquery/storage/apiv1beta1 [https://github.com/googleapis/google-cloud-go/tree/main/bigquery/storage/apiv1beta1]'
 'BigQuery [https://cloud.google.com/bigquery?hl=ko]\nDocumentation [https://cloud.google.com/bigquery/docs?hl=ko]\n가이드 [https://cloud.google.com/bigquery/docs/introduction?hl=ko]\n도움이 되었나요?\n의견 보내기\n이 페이지의 내용\n분석 규칙이란 무엇인가요? [https://cloud.google.com/bigquery/docs/analysis-rules?hl=ko#privacy_view]\n지원되는 분석 규칙 [https://cloud.google.com/bigquery/docs/analysis-rules?hl=ko#supported_analysis_rules]\n집계 기준점 분석 규칙 [https://cloud.google.com/bigquery/docs/analysis-rules?hl=ko#agg_analysis_rules]\n뷰의 집계 기준점 분석 규칙 정의 [https://cloud.google.com/bigquery/docs/analysis-rules?hl=ko#define_privacy_view]\n뷰의 집계 기준점 분석 규칙 업데이트 [https://cloud.google.com/bigquery/docs/analysis-rules?hl=ko#update_privacy_view]\n분석 규칙을 사용하여 데이터 액세스 제한\nbookmark_border\n이 문서에서는 BigQuery용 GoogleSQL의 분석 규칙에 대한 일반적인 정보를 제공합니다.\n분석 규칙이란 무엇인가요?'
 '사용 사례에 대한 유용한 정보를 얻으려면 설문지를 만들어 주제 전문가(SME), 최종 사용자, 이해관계자로부터 정보를 수집하면 됩니다. 설문지에는 다음과 같은 정보를 묻는 질문이 포함되어야 합니다.\n사용 사례의 목표는 무엇인가요? 비즈니스 가치는 무엇인가요?\n비기능적 요구사항은 무엇인가요? (데이터 업데이트, 동시 사용 등)\n사용 사례가 더 큰 워크로드의 일부인가요? 다른 사용 사례에 종속되나요?\n사용 사례의 토대가 되는 데이터 세트, 테이블, 스키마는 무엇인가요?\n이러한 데이터 세트에 데이터 파이프라인을 피드하는 방법에 대해 알고 계신가요?\n현재 어떤 BI 도구, 보고서, 대시보드를 사용하고 있나요?\n운영 요구사항, 성능, 인증, 네트워크 대역폭과 관련된 현재 기술 요구사항은 무엇인가요?\n다음 다이어그램은 마이그레이션하기 전 기존 아키텍처를 대략적으로 보여줍니다. 사용 가능한 데이터 소스, 기존 데이터 파이프라인, 이전 운영 파이프라인 및 피드백 루프, 최종 사용자가 액세스하는 기존 BI 보고서 및 대시보드의 카탈로그를 보여줍니다.\n계획\n계획 단계는 준비 및 탐색 단계에서 의견을 받고 평가하여 마이그레이션을 계획하는 단계입니다. 이 단계는 다음 작업으로 나눌 수 있습니다.\n사용 사례 카탈로그 작성 및 우선순위 지정\n마이그레이션 프로세스를 여러 반복 작업으로 나누는 것이 좋습니다. 기존 사용 사례와 새로운 사용 사례를 모두 카탈로그로 작성하고 우선순위를 지정합니다. 자세한 내용은 이 문서의 반복적인 접근법을 사용한 마이그레이션 [https://cloud.google.com/bigquery/docs/migration/migration-overview?hl=ko#migrating-using-an-iterative-approach] 및 사용 사례 우선순위 지정 [https://cloud.google.com/bigquery/docs/migration/migration-overview?hl=ko#prioritizing-use-cases] 섹션을 참조하세요.\n성공의 척도 정의\n마이그레이션하기 전에 핵심성과지표(KPI) [https://wikipedia.org/wiki/Performance_indicator]와 같은 명확한 성공의 척도를 정의하면 유용합니다. 이러한 척도를 사용하면 각 반복 작업에서 마이그레이션의 성공 여부를 평가할 수 있습니다. 그러면 이후 반복 작업에서 마이그레이션 프로세스를 개선할 수 있습니다.'
 'BigQuery [https://cloud.google.com/bigquery?hl=ko]\nDocumentation [https://cloud.google.com/bigquery/docs?hl=ko]\n가이드 [https://cloud.google.com/bigquery/docs/introduction?hl=ko]\n의견 보내기\n이 페이지의 내용\n라벨이란 무엇인가요? [https://cloud.google.com/bigquery/docs/labels-intro?hl=ko#what-are-labels]\n라벨 요구사항 [https://cloud.google.com/bigquery/docs/labels-intro?hl=ko#requirements]\n라벨의 일반적인 사용 사례 [https://cloud.google.com/bigquery/docs/labels-intro?hl=ko#common-uses]\n라벨 및 태그 [https://cloud.google.com/bigquery/docs/labels-intro?hl=ko#labels_and_tags]\n다음 단계 [https://cloud.google.com/bigquery/docs/labels-intro?hl=ko#whats_next]\n라벨 소개\nbookmark_border\nBigQuery 리소스를 체계화하기 위해 데이터세트, 테이블, 예약, 뷰에 라벨을 추가할 수 있습니다. 라벨은 리소스에 연결할 수 있는 키-값 쌍입니다. BigQuery 리소스를 만들 때 라벨은 선택사항입니다.\n리소스에 라벨을 지정하면 라벨 값을 기준으로 리소스를 검색할 수 있습니다. 예를 들어 라벨을 사용하여 용도, 환경, 부서 등을 기준으로 데이터세트를 그룹화할 수 있습니다.\n라벨이란 무엇인가요?'
 '마켓 트렌드 및 사용자 구매 행동을 기반으로 제품 추천\n비행 지연 시간 예측\n사기 활동 감지\n부적절한 콘텐츠 신고\n자신의 앱을 경쟁 제품과 차별화할 수 있는 기타 혁신적인 아이디어\n접근법: 가장 위험성이 낮은 사용 사례에 우선순위 지정\nIT 부서에서 마이그레이션 위험이 가장 낮아서 마이그레이션 초기 단계에서 마이그레이션하면 가장 좋은 사용 사례를 평가할 때 유용한 여러 가지 질문이 있습니다. 예를 들면 다음과 같습니다.\n이 사용 사례의 비즈니스 중요도는 어느 정도인가요?\n다수의 직원이나 고객이 이 사용 사례에 의존하나요?\n사용 사례의 대상 환경(예: 개발 또는 프로덕션)은 무엇인가요?\nIT 팀의 사용 사례에 대한 이해도는 어떤가요?\n사용 사례의 종속 항목과 통합은 얼마나 되나요?\nIT 팀이 사용 사례에 대한 적절한 최신 문서를 보유하고 있나요?\n사용 사례의 운영 요구사항(SLA)은 무엇인가요?\n사용 사례에 대한 법적 또는 정부 규정 준수 요구사항은 무엇인가요?\n기본 데이터 세트에 액세스하는 경우의 다운타임 및 지연 시간 민감도는 무엇인가요?\n초기에 사용 사례를 마이그레이션하기를 열망하는 비즈니스 계열 대표가 있나요?\n이 질문 목록을 살펴보면 데이터 세트와 데이터 파이프라인에 위험 순위를 매길 수 있습니다. 위험성이 낮은 애셋을 먼저 마이그레이션하고 위험성이 높은 애셋은 나중에 마이그레이션해야 합니다.\n실행\n레거시 시스템에 대한 정보를 수집하고 우선순위가 지정된 사용 사례 백로그를 만든 후에는 사용 사례를 워크로드로 그룹화하고 반복 작업으로 마이그레이션을 진행할 수 있습니다.\n반복 작업은 단일 사용 사례, 몇 가지 개별 사용 사례 또는 단일 워크로드와 관련된 여러 사용 사례로 구성될 수 있습니다. 반복 작업에 선택하는 이러한 옵션은 사용 사례의 상호 연관성, 공통된 종속 항목, 작업을 수행하는 데 사용할 수 있는 리소스에 따라 다릅니다.\n일반적으로 마이그레이션에는 다음 단계가 포함됩니다.\n이러한 단계에 대해서는 다음 섹션에서 더 자세히 설명합니다. 각 반복 작업에서 이러한 단계를 모두 수행하지 않아도 됩니다. 예를 들어 한 반복 작업에서는 레거시 데이터 웨어하우스의 일부 데이터를 BigQuery로 복사하는 데 집중하고 다음 반복 작업에서는 원래 데이터 소스의 수집 파이프라인을 직접 BigQuery로 수정하는 데 집중할 수 있습니다.\n1. 설정 및 데이터 거버넌스'
 'BigQuery [https://cloud.google.com/bigquery?hl=ko]\nDocumentation [https://cloud.google.com/bigquery/docs?hl=ko]\n가이드 [https://cloud.google.com/bigquery/docs/introduction?hl=ko]\n도움이 되었나요?\n의견 보내기\n이 페이지의 내용\n데이터 파이프라인이란 무엇인가요? [https://cloud.google.com/bigquery/docs/migration/pipelines?hl=ko#what-is-a-data-pipeline]\n데이터 파이프라인을 마이그레이션하는 경우 [https://cloud.google.com/bigquery/docs/migration/pipelines?hl=ko#when_to_migrate_the_data_pipelines]\n데이터 파이프라인을 마이그레이션하는 방법 [https://cloud.google.com/bigquery/docs/migration/pipelines?hl=ko#how_to_migrate_the_data_pipelines]\n데이터 파이프라인의 절차 및 패턴 [https://cloud.google.com/bigquery/docs/migration/pipelines?hl=ko#procedures_and_patterns_for_data_pipelines]\n추출, 변환, 로드(ETL) [https://cloud.google.com/bigquery/docs/migration/pipelines?hl=ko#etl]\n추출, 로드, 변환(ELT) [https://cloud.google.com/bigquery/docs/migration/pipelines?hl=ko#elt]\n추출 및 로드(EL) [https://cloud.google.com/bigquery/docs/migration/pipelines?hl=ko#el]\n변경 데이터 캡처(CDC) [https://cloud.google.com/bigquery/docs/migration/pipelines?hl=ko#cdc]\n데이터 파이프라인 마이그레이션\nbookmark_border'
 'March 22, 2023\nBigQuery now supports Unicode column naming [http://cloud.google.com/bigquery/docs/schemas#flexible-column-names] using international character sets, alphanumeric and special characters. Existing columns can use these new capabilities using the RENAME command. This feature is now in preview [https://cloud.google.com/products/#product-launch-stages].\nMarch 20, 2023\nA weekly digest of client library updates from across the Cloud SDK [https://cloud.google.com/sdk].\n--- 탭: Go [https://cloud.google.com/bigquery/docs/release-notes#go] ---\nChanges for bigquery/storage/apiv1beta1 [https://github.com/googleapis/google-cloud-go/tree/main/bigquery/storage/apiv1beta1]\n1.49.0 [https://github.com/googleapis/google-cloud-go/compare/bigquery/v1.48.0...bigquery/v1.49.0] (2023-03-16)\nFeatures'
 'mean average precision [https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval)#Mean_average_precision]\nmean squared error\nnormalized discounted cumulative gain [https://en.wikipedia.org/wiki/Discounted_cumulative_gain#Normalized_DCG]\naverage rank\nPCA [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-pca?hl=ko] ML.EVALUATE [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-evaluate?hl=ko] 설명된 총 분산 비율을 보고합니다.\nAutoencoder [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-autoencoder?hl=ko] ML.EVALUATE [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-evaluate?hl=ko] 다음 측정항목을 보고합니다.\nmean absolute error\nmean squared error\nmean squared log error\n시계열 ARIMA_PLUS [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-time-series?hl=ko] ML.EVALUATE [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-evaluate?hl=ko] 다음 측정항목을 보고합니다.\nmean absolute error\nmean squared error\nmean absolute percentage error\nsymmetric mean absolute percentage error'
 '바이너리 클래스 분류 모델에만 적용됩니다.\n비지도 학습 k-평균 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-kmeans?hl=ko] ML.EVALUATE [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-evaluate?hl=ko] 데이비스-볼딘 색인 [https://en.wikipedia.org/wiki/Davies%E2%80%93Bouldin_index], 데이터 포인트와 지정된 클러스터 중심 사이의 평균 제곱 거리를 보고합니다.\n행렬 분해 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-matrix-factorization?hl=ko] ML.EVALUATE [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-evaluate?hl=ko] 명시적인 피드백 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-matrix-factorization?hl=ko#feedback_type] 기반 모델의 경우 다음 측정항목을 보고합니다.\nmean absolute error\nmean squared error\nmean squared log error\nmedian absolute error\nr2 score\nexplained variance\n암시적인 피드백 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-matrix-factorization?hl=ko#feedback_type] 기반 모델의 경우 다음 측정항목을 보고합니다.\nmean average precision [https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval)#Mean_average_precision]\nmean squared error'
 '부스티드 트리 회귀 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-boosted-tree?hl=ko]\n\n랜덤 포레스트 회귀 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-random-forest?hl=ko]\n\nDNN 회귀 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-dnn-models?hl=ko]\n\n와이드 앤 딥 회귀 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-wnd-models?hl=ko]\n\nAutoML Tables 회귀 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-automl?hl=ko] ML.EVALUATE [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-evaluate?hl=ko] 다음 측정항목을 보고합니다.\nmean absolute error\nmean squared error\nmean squared log error\nmedian absolute error\nr2 score\nexplained variance\n로지스틱 회귀 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-glm?hl=ko]\n\n부스티드 트리 분류 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-boosted-tree?hl=ko]\n\n랜덤 포레스트 분류 [https://cloud.google.com/bigquery/docs/reference/standard-sql/bigqueryml-syntax-create-random-forest?hl=ko]'
 ');\n출력은 다음과 비슷합니다.\n+-------------------------------------------------------------------------------+\n|               generated                                                       |\n+-------------------------------------------------------------------------------+\n| Between the 2019 and 2022 Survey of Consumer Finances (SCF), real median      |\n| family net worth surged 37 percent to $192,900, and real mean net worth       |\n| increased 23 percent to $1,063,700.  This represents the largest three-year   |\n| increase in median net worth in the history of the modern SCF, exceeding the  |\n| next largest by more than double.  In contrast, between 2010 and 2013, real   |\n| median net worth decreased 2 percent, and real mean net worth remained        |\n| unchanged.                                                                    |\n+-------------------------------------------------------------------------------+\n \n삭제\n주의: 프로젝트 삭제가 미치는 영향은 다음과 같습니다.\n프로젝트의 모든 항목이 삭제됩니다. 이 문서의 태스크에 기존 프로젝트를 사용한 경우 프로젝트를 삭제하면 프로젝트에서 수행한 다른 작업도 삭제됩니다.\n커스텀 프로젝트 ID가 손실됩니다. 이 프로젝트를 만들 때 앞으로 사용할 커스텀 프로젝트 ID를 만들었을 수 있습니다. appspot.com URL과 같이 프로젝트 ID를 사용하는 URL을 보존하려면 전체 프로젝트를 삭제하는 대신 프로젝트 내에서 선택한 리소스만 삭제합니다.'
 '// Display the results\n        if (tables.Count > 0)\n        {\n            Console.WriteLine($""Tables in dataset {datasetId}:"");\n            foreach (var table in tables)\n            {\n                Console.WriteLine($""\\t{table.Reference.TableId}"");\n            }\n        }\n        else\n        {\n            Console.WriteLine($""{datasetId} does not contain any tables."");\n        }\n    }\n}'
 'Q: Dimension API에서 사용할 수 있는 열거형 값은 무엇인가요?\nA: Dimension API에서 사용할 수 있는 열거형 값은 다음과 같습니다: \n- DIMENSION_UNSPECIFIED: 기본값이며 사용할 수 없습니다.\n- ROWS: 시트의 행에서 작동합니다.\n- COLUMNS: 시트의 열에서 작동합니다.'
 'Q: DeveloperMetadataLocationType 열거형에서 COLUMN은 어떤 경우에 사용되나요?\nA: COLUMN은 전체 열 측정기준에 연결된 개발자 메타데이터를 나타내는 경우에 사용됩니다.'
 ""Q: VectorConfig의 'dimension' 필드는 어떤 역할을 하나요?\nA: 'dimension' 필드(integer)는 이 구성에 적용되는 벡터의 차원을 나타내며, 결과 인덱스는 이 차원의 벡터만 포함되며 동일한 차원으로 벡터 검색에 사용될 수 있습니다.""
 'Q: Dimension API의 기본값은 무엇인가요?\nA: Dimension API의 기본값은 DIMENSION_UNSPECIFIED입니다. 이 값은 사용할 수 없습니다.'
 'Q: DataSourceTable 객체의 columns 필드는 어떤 정보를 담고 있으며, 어떻게 사용하나요?\nA: columns 필드는 데이터 소스 표에 선택된 열을 나타내며, columnSelectionType이 SELECTED여야 합니다. 이 필드는 다음과 같이 사용됩니다:\n\n```json\n{\n  ""columns"": [\n    {\n      ""dataSourceColumnReference"": {\n        ""dataSourceId"": ""string"",\n        ""columnId"": ""string""\n      }\n    }\n  ]\n}\n```'
 'Q: TARGET_TYPE_UNSPECIFIED의 의미는 무엇인가요?\nA: TARGET_TYPE_UNSPECIFIED는 사용하지 말아야 하며, 반드시 명시적으로 target type을 설정해야 합니다.'
 'Q: BigQuery API에서 프로젝트를 참조할 때 JSON 구조는 어떻게 되나요?\nA: BigQuery API에서 프로젝트를 참조할 때의 JSON 구조는 다음과 같습니다:\n```\n{\n  ""projectId"": string\n}\n```'
 'Q: IAM 정책의 condition에서 사용하는 표현식의 문법은 무엇인가요?\nA: IAM 정책의 condition에서 사용하는 표현식은 Common Expression Language (CEL) 문법을 따릅니다. CEL은 C와 유사한 표현 언어로, 문법과 의미는 [CEL 문서](https://github.com/google/cel-spec)에서 확인할 수 있습니다.'
 'Q: BigQuery API에서 새로운 비동기 작업을 시작하려면 어떤 메서드를 사용해야 하나요?\nA: 새로운 비동기 작업을 시작하려면 BigQuery API의 `jobs.insert` 메서드를 사용해야 합니다.'
 'Q: BigQuery API에서 프로젝트 목록을 나열할 때 반환되는 데이터 구조는 어떻게 되나요?\nA: 프로젝트 목록을 나열할 때 `list` 메서드는 사용자가 권한을 가진 프로젝트의 정보를 포함하는 응답을 반환합니다. 이 응답은 프로젝트의 ID, 이름 등과 같은 정보를 포함할 수 있습니다.'
 'Q: TestIamPermissionsResponse의 사용 예시는 무엇인가요?\nA: TestIamPermissionsResponse는 tables.testIamPermissions 메서드의 응답 메시지로 사용됩니다.'
 'Q: SessionInfo 리소스의 주요 목적은 무엇인가요?\nA: SessionInfo 리소스는 세션과 관련된 정보를 제공합니다.'
 'Q: SessionInfo 리소스에서 sessionId 필드의 데이터 타입은 무엇인가요?\nA: sessionId 필드(sessionId)의 데이터 타입은 string입니다.'
 'Q: BigQuery에서 TargetType의 사용 목적은 무엇인가요?\nA: TargetType은 데이터셋(dataset) 내에서 항목이 적용되는 리소스의 유형을 나타냅니다.'
 'Q: EncryptionConfiguration을 설정할 때 필수 필드는 무엇인가요?\nA: EncryptionConfiguration에서 필수 필드는 없습니다. kmsKeyName 필드는 선택적(optional)입니다.'
 'Q: TestIamPermissionsResponse의 permissions 필드에 포함된 데이터 타입은 무엇인가요?\nA: permissions 필드(permissions[])는 string 타입의 데이터를 포함합니다.'
 'Q: BigQuery에서 BASE_TABLE_EXPIRED_PARTITION이 발생하는 이유는 무엇인가요?\nA: BASE_TABLE_EXPIRED_PARTITION View는 기본 테이블의 파티션이 만료되었을 때 무효화됩니다.'
 'Q: BigQuery 테이블의 위치를 확인하는 방법은 무엇인가요?\nA: 테이블의 위치(location)는 출력 전용이며, 이 값은 데이터셋에서 상속됩니다.'
 ""Q: DML 통계(DmlStats)에서 각 필드의 데이터 타입은 무엇인가요?\nA: 'insertedRowCount', 'deletedRowCount', 'updatedRowCount' 필드는 모두 string (Int64Value format) 타입입니다.""
 'Q: BigQuery 테이블의 파티션 수를 확인하는 방법은 무엇인가요?\nA: 테이블 또는 물리적 뷰에 존재하는 파티션 수(numPartitions)는 출력 전용입니다.'
 'Q: BigQuery에서 특정 루틴의 정보를 업데이트하는 방법은 무엇인가요?\nA: 특정 루틴의 정보를 업데이트하려면 다음의 REST API를 사용합니다: PUT /bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines/{routineId}'
 'Q: BigQuery SQL 쿼리를 실행할 때, 요청 본문에 포함해야 하는 필드는 무엇인가요?\nA: 요청 본문에는 QueryRequest의 인스턴스가 포함되어야 합니다.'
 'Q: BigQuery에서 특정 데이터셋에 새로운 루틴을 생성하는 방법은 무엇인가요?\nA: 새로운 루틴을 생성하려면 다음의 REST API를 사용합니다: POST /bigquery/v2/projects/{projectId}/datasets/{datasetId}/routines'
 'Q: BigQuery 데이터셋에 레이블을 추가하는 방법은 무엇인가요?\nA: 데이터셋을 삽입하거나 업데이트할 때 레이블(labels) 속성을 설정하여 레이블을 추가할 수 있습니다.'
 'Q: BigQuery에서 skipLeadingRows 파라미터의 기본값은 무엇인가요?\nA: BigQuery에서 skipLeadingRows 파라미터의 기본값은 0입니다. 이 속성은 건너뛰어야 할 헤더 행이 있는 경우 유용합니다.'
 'Q: VectorConfig의 dimension 필드는 어떤 의미를 가지나요?\nA: dimension 필드는 이 구성에 적용되는 벡터 차원을 나타내며, 결과 인덱스는 이 차원의 벡터만 포함되며 동일한 차원으로 벡터 검색에 사용될 수 있습니다.'
 'Q: TargetType에서 사용할 수 있는 enum 값은 무엇이 있나요?\nA: TargetType에서 사용할 수 있는 enum 값은 다음과 같습니다: \n\n```plaintext\nTARGET_TYPE_UNSPECIFIED Do not use. You must set a target type explicitly.\nVIEWS This entry applies to views in the dataset.\n```'
 'Q: Common Expression Language (CEL)에서 표현식의 예시는 무엇인가요?\nA: Common Expression Language (CEL)에서 표현식의 예시는 다음과 같습니다:\n\n예시 (비교):\n```\ntitle: ""Summary size limit""\ndescription: ""Determines if a summary is less than 100 chars""\nexpression: ""document.summary.size() < 100""\n```\n\n예시 (동등성):\n```\ntitle: ""Requestor is owner""\ndescription: ""Determines if requestor is the document owner""\nexpression: ""document.owner == request.auth.claims.email""\n```\n\n예시 (논리):\n```\ntitle: ""Public documents""\ndescription: ""Determine whether the document should be publicly visible""\nexpression: ""document.type != \'private\' && document.type != \'internal\'""\n```\n\n예시 (데이터 조작):\n```\ntitle: ""Notification string""\ndescription: ""Create a notification string with a timestamp.""\nexpression: ""\'New message received at \' + string(document.create_time)""\n```'
 'Q: IAM 정책의 condition 필드에서 사용할 수 있는 표현식의 예시는 무엇인가요?\nA: 다음은 IAM 정책의 condition 필드에서 사용할 수 있는 표현식의 예시입니다:\n\n```\ntitle: ""Summary size limit""\ndescription: ""Determines if a summary is less than 100 chars""\nexpression: ""document.summary.size() < 100""\n```\n\n또 다른 예시는:\n```\ntitle: ""Requestor is owner""\ndescription: ""Determines if requestor is the document owner""\nexpression: ""document.owner == request.auth.claims.email""\n```'
 'Q: TestIamPermissionsResponse의 JSON 구조는 어떻게 되나요?\nA: TestIamPermissionsResponse의 JSON 구조는 다음과 같습니다:\n\n```\n{\n  ""permissions"": [\n    string\n  ]\n}\n```'
 'Q: TargetType의 VIEWS는 어떤 리소스에 적용되나요?\nA: VIEWS는 데이터셋(dataset) 내의 뷰(views)에 적용되는 항목입니다.'
 'Q: TargetType을 설정할 때 주의해야 할 점은 무엇인가요?\nA: TargetType을 설정할 때는 반드시 target type을 명시적으로 설정해야 하며, TARGET_TYPE_UNSPECIFIED는 사용하지 않아야 합니다.'
 'Q: tables.update 메서드를 사용하기 위해 필요한 인증 범위는 무엇인가요?\nA: tables.update 메서드를 사용하기 위해 필요한 인증 범위는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform'
 'Q: tables.update 메서드에서 사용할 수 있는 선택적 쿼리 파라미터는 무엇인가요?\nA: tables.update 메서드에서 사용할 수 있는 선택적 쿼리 파라미터는 autodetectSchema입니다. 이 파라미터가 true로 설정되면 스키마를 자동으로 감지하고, 그렇지 않으면 원래 스키마를 유지합니다.'
 'Q: tables.update 메서드의 요청 본문에는 어떤 정보가 포함되어야 하나요?\nA: tables.update 메서드의 요청 본문에는 Table 인스턴스가 포함되어야 합니다.'
 'Q: tables.update 메서드를 호출할 때 필요한 HTTP 요청 형식은 어떻게 되나요?\nA: tables.update 메서드를 호출할 때 필요한 HTTP 요청 형식은 다음과 같습니다:\n```\nPUT https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}\n```'
 'Q: BigQuery에서 테이블 정보를 업데이트할 때 사용하는 메서드는 무엇인가요?\nA: 테이블 정보를 업데이트할 때 사용하는 메서드는 tables.update입니다. 이 메서드는 기존 테이블 리소스를 전체적으로 교체합니다.'
 ""Q: tables.testIamPermissions 메서드의 사용 시 주의사항은 무엇인가요?\nA: tables.testIamPermissions 메서드는 권한 확인을 위한 것이 아니라 권한 인식 UI 및 명령줄 도구를 구축하기 위해 설계되었습니다. 이 작업은 경고 없이 'fail open'할 수 있습니다. 따라서 이 메서드를 사용할 때는 이러한 특성을 고려해야 합니다.""
 'Q: datasets.get 메서드에서 사용할 수 있는 쿼리 파라미터는 무엇이 있나요?\nA: datasets.get 메서드에서 사용할 수 있는 쿼리 파라미터는 `accessPolicyVersion`입니다. 이 파라미터는 선택 사항이며, 접근 정책 스키마의 버전을 가져오는 데 사용됩니다. 유효한 값은 0, 1, 3입니다.'
 'Q: tables.get 메서드의 요청 본문은 어떻게 구성되나요?\nA: tables.get 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n{ }\n```'
 'Q: DataFormatOptions에서 사용할 수 있는 필드는 무엇이 있나요?\nA: DataFormatOptions에서 사용할 수 있는 필드는 `useInt64Timestamp` 하나입니다.'
 'Q: BigQuery 데이터셋의 설명을 추가하는 방법은 무엇인가요?\nA: 데이터셋의 설명은 `description` 필드를 사용하여 추가할 수 있습니다. 이 필드는 사용자 친화적인 설명을 제공하는 선택적 필드입니다. 데이터셋을 생성하거나 업데이트할 때 이 필드를 포함하여 설명을 설정할 수 있습니다.'
 'Q: tables.testIamPermissions 메서드의 응답 본문은 어떤 형식을 가지나요?\nA: 성공적으로 호출된 경우, 응답 본문은 TestIamPermissionsResponse 인스턴스를 포함합니다. 이 응답은 호출자가 요청한 권한의 상태를 나타냅니다.'
 'Q: tables.testIamPermissions 메서드를 호출할 때 필요한 OAuth 스코프는 무엇인가요?\nA: tables.testIamPermissions 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.']","COLUMNS는 Dimension API에서 시트의 열에서 작동하는 것을 의미합니다. 이는 Dimension API에서 사용할 수 있는 열거형 값 중 하나로, 시트의 열에 대해 작업을 수행할 때 사용됩니다.",COLUMNS는 Dimension API에서 시트의 열에서 작동함을 의미합니다.
ttll이 뭐에요? 그리고 한도 같은거 있나요?,"['TtlConfig\n\nThe TTL (time-to-live) configuration for documents that have this Field set.Storing a timestamp value into a TTL-enabled field will be treated as the document\'s absolute expiration time. Timestamp values in the past indicate that the document is eligible for immediate expiration. Using any other data type or leaving the field absent will disable expiration for the individual document.\n\n| JSON representation |\n| --- |\n| {   ""state"": enum (State) } |\n\n| Fields |\n| --- |\n| state | enum (State) Output only. The state of the TTL configuration. |\n\nState\n\nThe state of applying the TTL configuration to all documents.'
 ""TtlConfig\n\nThe TTL (time-to-live) configuration for documents that have this Field set.Storing a timestamp value into a TTL-enabled field will be treated as the document's absolute expiration time. Timestamp values in the past indicate that the document is eligible for immediate expiration. Using any other data type or leaving the field absent will disable expiration for the individual document.\n\n| Fields |\n| --- |\n| state | State Output only. The state of the TTL configuration. |\n\nState\n\nThe state of applying the TTL configuration to all documents.""
 'Maximum writes per second per database: 10,000\nMaximum concurrent connections for mobile/web clients per database: 1,000,000\n\nOctober 11, 2022\n\nTime-to-live (TTL) policies [https://cloud.google.com/firestore/docs/ttl] are now supported at the General Availability level [https://cloud.google.com/products/#product-launch-stages].\n\nAugust 22, 2022\n\nAdded a query builder and table view to the Firestore data section in the Google Cloud console. Use the query builder to filter and compare many documents at once. To learn more, see Query data in the Google Cloud console [https://cloud.google.com/firestore/docs/using-console#query_data].\n\nJuly 19, 2022\n\nTime-to-live (TTL) policies [https://cloud.google.com/firestore/docs/ttl] now available in Preview [https://cloud.google.com/products/#product-launch-stages].\n\nJune 01, 2022\n\nSupport for VPC Service Controls [https://cloud.google.com/firestore/docs/securing-with-vpc-sc] is now available in General Availability.\n\nMay 13, 2022'
 '일시적인 실패\n\nCloud Firestore와 같은 대규모 분산 시스템으로 작업할 때는 네트워크 일시적 오류나 문서의 경합과 같은 일시적인 오류가 발생할 수 있습니다.\n\n대량의 정보를 일괄 로드할 때는 더 큰 일괄 로드 작업이 실패하지 않도록 실패한 쓰기에 대한 재시도 전략을 유지하는 것이 중요합니다.\n참고: MongoDB 호환성을 갖춘 Cloud Firestore는 retryWrites를 지원하지 않습니다. 트랜잭션을 사용하여 애플리케이션이 멱등성을 보장하도록 하는 것이 좋습니다.\n\n의견 보내기'
 '벡터 임베딩으로 검색\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지에서는 Firestore를 사용하여 다음 기법을 사용하여 K-최근접 이웃 (KNN) 벡터 검색을 수행하는 방법을 보여줍니다.\n\n벡터 값 저장\nKNN 벡터 색인 만들기 및 관리\n지원되는 벡터 거리 측정 중 하나를 사용하여 K-최근접 이웃(KNN) 쿼리 수행\n\n시작하기 전에\n\nFirestore에 임베딩을 저장하기 전에 벡터 임베딩을 생성해야 합니다. Firestore는 임베딩을 생성하지 않습니다. Vertex AI와 같은 서비스를 사용하여 Firestore 데이터에서 텍스트 임베딩 [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings?hl=ko]과 같은 벡터 값을 만들 수 있습니다. 그런 다음 이러한 임베딩을 Firestore 문서에 다시 저장할 수 있습니다.\n\n임베딩에 대해 자세히 알아보려면 임베딩이란 무엇인가요? [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings?hl=ko#embedding-types]를 참고하세요.\n\nVertex AI로 텍스트 임베딩을 가져오는 방법을 알아보려면 텍스트 임베딩 가져오기 [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings?hl=ko]를 참고하세요.\n\n벡터 임베딩 저장\n\n다음 예는 Firestore에 벡터 임베딩을 저장하는 방법을 보여줍니다.\n\n벡터 임베딩을 사용한 쓰기 작업\n\n다음 예시는 Firestore 문서에 벡터 임베딩을 저장하는 방법을 보여줍니다.\n\n--- 탭: Python [https://cloud.google.com/firestore/native/docs/vector-search?hl=ko#python] ---\n```\nfrom google.cloud import firestore\nfrom google.cloud.firestore_v1.vector import Vector'
 'Source URL: https://firebase.google.com/docs/firestore/vector-search?hl=ko\nTitle: 벡터 임베딩으로 검색\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\n벡터 임베딩으로 검색\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지에서는 Cloud Firestore를 사용하여 다음 기법을 사용하여 K-최근접 이웃(KNN) 벡터 검색을 수행하는 방법을 보여줍니다.\n\n벡터 값 저장\nKNN 벡터 색인 만들기 및 관리\n지원되는 벡터 거리 측정 중 하나를 사용하여 K-최근접 이웃(KNN) 쿼리 수행\n\n시작하기 전에\n\nCloud Firestore에 임베딩을 저장하기 전에 벡터 임베딩을 생성해야 합니다. Cloud Firestore는 임베딩을 생성하지 않습니다. Vertex\xa0AI와 같은 서비스를 사용하여 Cloud Firestore 데이터에서 텍스트 임베딩 [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings?hl=ko]과 같은 벡터 값을 만들 수 있습니다. 그런 다음 이러한 임베딩을 Cloud Firestore 문서에 다시 저장할 수 있습니다.\n\n임베딩에 대해 자세히 알아보려면 임베딩이란 무엇인가요? [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings?hl=ko#embedding-types]를 참고하세요.\n\nVertex\xa0AI로 텍스트 임베딩을 가져오는 방법을 알아보려면 텍스트 임베딩 가져오기 [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings?hl=ko]를 참고하세요.\n\n벡터 임베딩 저장\n\n다음 예는 Cloud Firestore에 벡터 임베딩을 저장하는 방법을 보여줍니다.\n\n벡터 임베딩을 사용한 쓰기 작업\n\n다음 예시는 Cloud Firestore 문서에 벡터 임베딩을 저장하는 방법을 보여줍니다.'
 ""LangChain을 사용하여 LLM 기반 애플리케이션 빌드\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n프리뷰\n\n- LangChain\n\n이 기능에는\n\n서비스별 약관 [https://cloud.google.com/terms/service-terms?hl=ko#1]의 일반 서비스 약관 섹션에 있는 'GA 이전 제공 서비스 약관'이 적용됩니다.\n\nGA 이전 기능은 '있는 그대로' 제공되며 지원이 제한될 수 있습니다.\n\n자세한 내용은 출시 단계 설명 [https://cloud.google.com/products?hl=ko#product-launch-stages]을 참고하세요.\n\n이 페이지에서는 LangChain [https://www.langchain.com/]을 사용하여 LLM 기반 애플리케이션을 빌드하는 방법을 소개합니다. 이 페이지의 개요는 GitHub의 절차 가이드로 연결됩니다.\n\nLangChain이란 무엇인가요?\n\nLangChain은 개발자가 생성형 AI 애플리케이션 또는 검색 증강 생성(RAG) 워크플로를 빌드할 수 있도록 도와주는 LLM 조정 프레임워크로서, 복잡한 LLM 워크플로를 간소화하는 구조, 도구, 구성요소를 제공합니다.\n\nLangChain에 대한 자세한 내용은 Google LangChain [https://python.langchain.com/docs/integrations/platforms/google] 페이지를 참조하세요. LangChain 프레임워크에 대한 자세한 내용은 LangChain [https://python.langchain.com/docs/get_started/introduction] 제품 문서를 참조하세요.\n\nFirestore용 LangChain 구성요소\n\nFirestore는 다음과 같은 LangChain 인터페이스를 제공합니다.""
 'Source URL: https://firebase.google.com/docs/firestore/rtdb-vs-firestore?hl=ko\nTitle: 데이터베이스 선택: Cloud Firestore 또는 실시간 데이터베이스\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\n데이터베이스 선택: Cloud Firestore 또는 실시간 데이터베이스\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nFirebase는 클라이언트에서 액세스할 수 있는 두 가지 클라우드 기반 문서 데이터베이스를 제공합니다. 신규 고객은 Cloud Firestore로 시작하는 것이 좋습니다.\n\nCloud Firestore는 권장되는 엔터프라이즈급 JSON 호환 문서 데이터베이스로, 600,000명이 넘는 개발자가 신뢰하고 있습니다. 쿼리 가능성, 확장성 및 고가용성이 필요한 풍부한 데이터 모델을 갖춘 애플리케이션에 적합합니다. 또한 지연 시간이 짧은 클라이언트 동기화와 오프라인 데이터 액세스를 제공합니다.\nRealtime Database는 기본 Firebase JSON 데이터베이스입니다. 간단한 조회와 확장성이 제한적이며 지연 시간이 짧은 동기화가 필요한 단순한 데이터 모델을 사용하는 애플리케이션에 적합합니다.\n\n다른 중요한 고려사항은 무엇인가요?\n\n이전의 주요 고려사항에 대해 생각해 본 후 데이터베이스를 선택 [https://firebase.google.com/docs/firestore/rtdb-vs-firestore?hl=ko#choose-a-database]할 준비가 되어 있을 수 있습니다.\n아직 장단점을 고려 중이면 이 섹션에서 Cloud Firestore와 Realtime Database의 기타 차이점을 확인하세요.\n\n데이터 모델\n\nRealtime Database와 Cloud Firestore는 모두 NoSQL 데이터베이스입니다.'
 ""State\n\nThe state of applying the TTL configuration to all documents.\n\n| Enums |\n| --- |\n| STATE_UNSPECIFIED | The state is unspecified or unknown. |\n| CREATING | The TTL is being applied. There is an active long-running operation to track the change. Newly written documents will have TTLs applied as requested. Requested TTLs on existing documents are still being processed. When TTLs on all existing documents have been processed, the state will move to 'ACTIVE'. |\n| ACTIVE | The TTL is active for all documents. |\n| NEEDS_REPAIR | The TTL configuration could not be enabled for all existing documents. Newly written documents will continue to have their TTL applied. The LRO returned when last attempting to enable TTL for this Field has failed, and may have more details. |\n\nFieldOperationMetadata\n\nMetadata for google.longrunning.Operation [https://cloud.google.com/firestore/docs/reference/rpc/google.longrunning#google.longrunning.Operation] results from FirestoreAdmin.UpdateField [https://cloud.google.com/firestore/docs/reference/rpc/google.firestore.admin.v1#google.firestore.admin.v1.FirestoreAdmin.UpdateField].""
 ""State\n\nThe state of applying the TTL configuration to all documents.\n\n| Enums |\n| --- |\n| STATE_UNSPECIFIED | The state is unspecified or unknown. |\n| CREATING | The TTL is being applied. There is an active long-running operation to track the change. Newly written documents will have TTLs applied as requested. Requested TTLs on existing documents are still being processed. When TTLs on all existing documents have been processed, the state will move to 'ACTIVE'. |\n| ACTIVE | The TTL is active for all documents. |\n| NEEDS_REPAIR | The TTL configuration could not be enabled for all existing documents. Newly written documents will continue to have their TTL applied. The LRO returned when last attempting to enable TTL for this Field has failed, and may have more details. |\n\nFieldOperationMetadata\n\nMetadata for google.longrunning.Operation [https://firebase.google.com/docs/firestore/reference/rpc/google.longrunning#google.longrunning.Operation] results from FirestoreAdmin.UpdateField [https://firebase.google.com/docs/firestore/reference/rpc/google.firestore.admin.v1#google.firestore.admin.v1.FirestoreAdmin.UpdateField].""
 '| field.name | string A field name of the form projects/{projectId}/databases/{databaseId}/collectionGroups/{collectionId}/fields/{fieldPath} A field path may be a simple field name, e.g. address or a path to fields within mapValue , e.g. address.city, or a special field path. The only valid special field is *, which represents any field. Field paths may be quoted using (backtick). The only character that needs to be escaped within a quoted field path is the backtick character itself, escaped using a backslash. Special characters in field paths that must be quoted include:*,., ``` (backtick),[,]`, as well as any ascii symbolic characters. Examples: (Note: Comments here are written in markdown syntax, so there is an additional layer of backticks to represent a code block) \\address.city`represents a field namedaddress.city, not the map key cityin the fieldaddress. `*`represents a field named*`, not any field. A special Field contains the default indexing settings for all fields'
 'Q: TTL(수명) 정책을 적용할 때 한도 및 제약조건은 무엇인가요?\nA: 컬렉션당 하나의 필드만 TTL 필드로 표시할 수 있으며, 필드 수준 TTL 구성은 최대 500개까지 허용됩니다.'
 'Q: Firestore에서 특정 필드의 TTL(TIME-TO-LIVE) 구성을 설정하는 방법은 무엇인가요?\nA: TTL 구성을 설정하려면, 필드에 대한 TTL 구성을 포함하는 요청 본문을 사용하여 필드를 업데이트해야 합니다. TTL이 활성화된 필드에 타임스탬프 값을 저장하면 해당 문서의 절대 만료 시간으로 처리됩니다. 예를 들어, 다음과 같은 JSON 형식으로 요청을 보낼 수 있습니다:\n\n```json\n{   ""state"": ""ACTIVE"" }\n```'
 'Q: 알림 채널의 TTL(수명)을 설정하는 방법은 무엇인가요?\nA: 알림 채널의 TTL(수명)은 요청 본문의 `params` 객체 내 `ttl` 속성을 통해 설정할 수 있습니다. 기본값은 604,800초입니다.'
 'Q: Firestore에서 Time-to-live (TTL) 정책을 설정하는 방법은 무엇인가요?\nA: Firestore에서 Time-to-live (TTL) 정책은 현재 일반 사용 가능 수준(General Availability level)에서 지원됩니다. 이 기능을 사용하여 문서의 생존 기간을 설정할 수 있습니다.'
 'Q: TTL(수명) 필드를 설정할 때 필드 값으로 어떤 유형의 값을 사용할 수 있나요?\nA: TTL 필드 값은 미래, 현재 또는 과거의 시간일 수 있습니다. 값이 과거의 시간인 경우 문서는 즉시 삭제 가능한 대상이 될 수 있습니다.'
 'Q: 하위 컬렉션을 삭제하는 것이 어려운 이유는 무엇인가요?\nA: 하위 컬렉션은 손쉽게 삭제할 수 없기 때문에 관리가 복잡해질 수 있습니다.'
 'Q: google.rpc.Status 메시지의 구성 요소는 무엇인가요?\nA: 각 Status 메시지는 세 가지 데이터 조각을 포함합니다: error code, error message, 그리고 error details.'
 'Q: Firestore에서 데이터베이스의 암호화 구성을 설정하는 방법은 무엇인가요?\nA: Firestore에서 데이터베이스의 암호화 구성을 설정하기 위해서는 `Database.EncryptionConfig` (message)를 사용해야 합니다. 이 구성은 고객 관리 암호화 옵션(`CustomerManagedEncryptionOptions`), Google 기본 암호화 옵션(`GoogleDefaultEncryptionOptions`), 그리고 소스 암호화 옵션(`SourceEncryptionOptions`)을 포함합니다.'
 ""Q: Firestore에서 지원하는 정렬 방식은 어떤 것이 있나요?\nA: Firestore에서 지원하는 정렬 방식은 'ASCENDING'과 'DESCENDING'입니다.""
 'Q: Cloud Firestore의 표준 한도에서 프로젝트당 최대 데이터베이스 수는 얼마인가요?\nA: | 한도 | 세부정보 |\n| --- | --- |\n| 프로젝트당 최대 데이터베이스 수 | 100 지원팀에 문의하여 이 한도 상향을 요청할 수 있습니다. |'
 'Q: Cloud Firestore의 데이터 가져오기 방법에는 어떤 것이 있나요?\nA: Cloud Firestore에서는 쿼리를 작성하거나 실시간 리스너를 사용해 데이터베이스에서 데이터를 가져올 수 있습니다.'
 ""Q: Cloud Firestore Enterprise에서 지원되는 쓰기 문제는 어떤 것이 있나요?\nA: Cloud Firestore Enterprise에서는 w: 'majority' 및 w: 1 쓰기 문제만 지원됩니다.""
 'Q: LocationMetadata 타입의 주요 특징은 무엇인가요?\nA: LocationMetadata 타입은 필드가 없다는 것이 주요 특징입니다.'
 'Q: Cloud Firestore에서 액세스 호출 한도를 초과하면 어떤 오류가 발생하나요?\nA: 한도 중 하나라도 초과하면 권한 거부 오류가 발생합니다.'
 'Q: Cloud Firestore에서 문서를 추가할 때 사용할 수 있는 데이터 구조는 어떤 것이 있나요?\nA: 문서를 추가할 때는 객체 형태의 데이터를 사용할 수 있습니다. 예를 들어, 다음과 같은 구조를 사용할 수 있습니다:\n\n```javascript\n{\n  name: ""San Francisco"",\n  state: ""CA"",\n  country: ""USA"",\n  capital: false,\n  population: 860000,\n  regions: [""west_coast"", ""norcal""]\n}\n```'
 'Q: 복합 인덱스 생성 요청의 경로 매개변수(path parameters)에는 어떤 것이 있나요?\nA: 복합 인덱스 생성 요청의 경로 매개변수(path parameters)에는 `parent`가 포함됩니다. `parent`는 `projects/{projectId}/databases/{databaseId}/collectionGroups/{collectionId}` 형식의 문자열입니다.'
 'Q: TTL 정책을 설정할 때 한도 및 제약조건은 무엇인가요?\nA: 컬렉션 그룹당 하나의 필드만 TTL 필드로 표시할 수 있으며, 필드 수준 구성은 최대 500개까지 허용됩니다. Datastore 모드의 Firestore 고객은 TTL을 항목 그룹을 사용한 낙관적 동시 실행 모드와 함께 사용할 수 없습니다.'
 'Q: Cloud Firestore에서 프로젝트당 최대 데이터베이스 수는 얼마인가요?\nA: 프로젝트당 최대 데이터베이스 수는 100입니다. 지원팀에 문의하여 이 한도 상향을 요청할 수 있습니다.'
 'Q: Cloud Firestore에서 지리적 지점 데이터 유형을 사용할 때 주의해야 할 점은 무엇인가요?\nA: Cloud Firestore에서 지리적 지점 데이터 유형은 현재 쿼리 제한사항으로 인해 사용하지 않는 것이 좋습니다. 일반적으로 위도와 경도를 별도의 숫자 필드로 저장하는 것이 권장됩니다.'
 'Q: 대형 읽기에서 지연 시간을 줄이기 위한 방법은 무엇인가요?\nA: 페이지로 나누기를 사용하여 대량 읽기를 분할하는 것이 좋습니다.'
 'Q: Cloud Firestore에서 핫스팟을 피하는 것이 중요한 이유는 무엇인가요?\nA: 핫스팟을 피하는 것이 바로 이 문제를 해결하는 열쇠입니다. 핫스팟이나 잠금 경합을 유발하는 쓰기 작업이 읽기 작업에 부정적인 영향을 줄 수 있으며, 이로 인해 응답 속도가 느려질 수 있습니다.'
 'Q: Cloud Firestore에서 핫스팟을 방지하기 위한 최적의 트래픽 증가 규칙은 무엇인가요?\nA: 핫스팟을 방지하기 위해 Cloud Firestore에서는 초당 500개의 작업을 수행하는 데이터베이스의 컬렉션에서 트래픽을 점진적으로 늘리는 것이 좋습니다. 5분마다 최대 50%씩 트래픽을 늘리는 500/50/5 규칙을 따르는 것이 최적의 확장을 위해 권장됩니다.'
 'Q: Cloud Firestore와 통합할 수 있는 오픈소스 라이브러리는 어떤 것이 있나요?\nA: Cloud Firestore는 다양한 오픈소스 라이브러리와의 통합이 가능합니다. 이러한 통합은 주로 Cloud Firestore를 사용하는 개발자가 자주 이용하는 프레임워크로 이루어집니다.'
 ""Q: 요청 본문에서 'params' 속성의 'ttl'은 무엇을 의미하나요?\nA: 'params' 속성의 'ttl'은 알림 채널의 수명(초)을 의미합니다. 기본값은 604,800초입니다.""
 'Q: C#에서 Firestore에 \'National Air And Space Museum\'라는 박물관 정보를 추가하는 방법은 무엇인가요?\nA: C#에서 Firestore에 \'National Air And Space Museum\'라는 박물관 정보를 추가하려면 다음과 같이 코드를 작성할 수 있습니다.\n\n```csharp\nawait citiesRef.Document(""DC"").Collection(""landmarks"").Document().SetAsync(new { Name = ""National Air And Space Museum"", Type = ""museum"" });\n```'
 'Q: ListDocumentsResponse에서 반환되는 필드에는 어떤 것들이 있나요?\nA: | Fields |\n| --- |\n| documents[] | Document The Documents found. |\n| next_page_token | string A token to retrieve the next page of documents. If this field is omitted, there are no subsequent pages.'
 'Q: Firestore에서 ListDocumentsResponse를 통해 문서 목록을 어떻게 확인할 수 있나요?\nA: | Fields |\n| --- |\n| documents[] | Document The Documents found. |\n| next_page_token | string A token to retrieve the next page of documents. If this field is omitted, there are no subsequent pages. |'
 'Q: Firestore에서 ListDocumentsResponse를 통해 문서 목록을 가져올 때 어떤 필드를 포함하나요?\nA: | Fields |\n| --- |\n| documents[] | Document The Documents found. |\n| next_page_token | string A token to retrieve the next page of documents. If this field is omitted, there are no subsequent pages. |'
 'Q: Firestore에서 TTL 상태(State) enum의 가능한 값은 무엇인가요?\nA: | Enums |\n| --- |\n| STATE_UNSPECIFIED | The state is unspecified or unknown. |\n| CREATING | The TTL is being applied. |\n| ACTIVE | The TTL is active for all documents. |\n| NEEDS_REPAIR | The TTL configuration could not be enabled for all existing documents. |'
 'Q: Firestore에서 TTL 구성의 상태를 확인하기 위한 State의 가능한 값은 무엇인가요?\nA: State의 가능한 값은 다음과 같습니다: \n| Enums |\n| --- |\n| STATE_UNSPECIFIED | The state is unspecified or unknown. |\n| CREATING | The TTL is being applied. |\n| ACTIVE | The TTL is active for all documents. |\n| NEEDS_REPAIR | The TTL configuration could not be enabled for all existing documents. |'
 ""Q: Firestore에서 필드(Field)의 이름(name) 형식은 무엇인가요?\nA: | Fields |\n| --- |\n| name | string A field name of the form projects/{projectId}/databases/{databaseId}/collectionGroups/{collectionId}/fields/{fieldPath} A field path may be a simple field name, e.g. address or a path to fields within mapValue , e.g. address.city, or a special field path. The only valid special field is *, which represents any field. Field paths may be quoted using (backtick). The only character that needs to be escaped within a quoted field path is the backtick character itself, escaped using a backslash. Special characters in field paths that must be quoted include:*,., ``` (backtick),[,]`, as well as any ascii symbolic characters. Examples: (Note: Comments here are written in markdown syntax, so there is an additional layer of backticks to represent a code block) \\address.city`represents a field namedaddress.city, not the map key cityin the fieldaddress. `*`represents a field named*`, not any field. A special Field contains the default indexing settings for all fields. This field's resource name is: projects/{projectId}/databases/{databaseId}/collectionGroups/__default__/fields/* Indexes defined on this Field will be applied to all fields which do not have their own Field index configuration. |""
 'Q: Firestore에서 필드의 TTL 구성 변경에 대한 정보를 포함하는 TtlConfigDelta의 필드는 무엇인가요?\nA: TtlConfigDelta는 TTL 구성 변경에 대한 정보를 포함합니다. 필드는 다음과 같습니다: \n| Fields |\n| --- |\n| change_type | ChangeType Specifies how the TTL configuration is changing. |'
 'Q: FirestoreAdmin API에서 ExportDocumentsMetadata의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| start_time | Timestamp The time this operation started. |\n| end_time | Timestamp The time this operation completed. Will be unset if operation still in progress. |\n| operation_state | OperationState The state of the export operation. |\n| progress_documents | Progress The progress, in documents, of this operation. |\n| progress_bytes | Progress The progress, in bytes, of this operation. |\n| collection_ids[] | string Which collection IDs are being exported. |\n| output_uri_prefix | string Where the documents are being exported to. |\n| namespace_ids[] | string Which namespace IDs are being exported. |\n| snapshot_time | Timestamp The timestamp that corresponds to the version of the database that is being exported. If unspecified, there are no guarantees about the consistency of the documents being exported.'
 'Q: FirestoreAdmin API에서 ExportDocumentsMetadata의 필드 구성은 어떻게 되나요?\nA: | Fields |\n| --- |\n| start_time | Timestamp The time this operation started. |\n| end_time | Timestamp The time this operation completed. Will be unset if operation still in progress. |\n| operation_state | OperationState The state of the export operation. |\n| progress_documents | Progress The progress, in documents, of this operation. |\n| progress_bytes | Progress The progress, in bytes, of this operation. |\n| collection_ids[] | string Which collection IDs are being exported. |\n| output_uri_prefix | string Where the documents are being exported to. |\n| namespace_ids[] | string Which namespace IDs are being exported. |\n| snapshot_time | Timestamp The timestamp that corresponds to the version of the database that is being exported. If unspecified, there are no guarantees about the consistency of the documents being exported.'
 'Q: Firestore에서 PartitionQueryResponse를 통해 어떤 정보를 받을 수 있나요?\nA: | Fields |\n| --- |\n| partitions[] | Cursor Partition results. Each partition is a split point that can be used by RunQuery as a starting or end point for the query results. |\n| next_page_token | string A page token that may be used to request an additional set of results, up to the number specified by partition_count in the PartitionQuery request. If blank, there are no more results. |'
 'Q: FirestoreAdmin API에서 인덱스의 고유성(unique) 설정은 무엇인가요?\nA: | bool Optional. Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.'
 'Q: TTL 정책을 사용하여 Firestore의 데이터를 삭제하는 방법은 무엇인가요?\nA: TTL 정책은 특정 필드를 특정 컬렉션 그룹의 문서 만료 시간으로 지정합니다. TTL 삭제 작업은 문서 삭제 비용에 포함됩니다. TTL 설정에 대한 자세한 내용은 TTL 정책으로 데이터 보관 관리 문서를 참조하세요.'
 'Q: Firestore 인덱스의 unique 필드는 어떤 의미를 가지나요?\nA: | unique | bool Optional. Whether it is an unique index. Unique index ensures all values for the indexed field(s) are unique across documents.'
 'Q: Cloud Firestore에서 TTL 정책을 사용하여 데이터 삭제를 설정하는 방법은 무엇인가요?\nA: TTL 정책은 특정 필드를 특정 컬렉션 그룹의 문서 만료 시간으로 지정합니다. TTL 삭제 작업은 문서 삭제 비용에 포함됩니다. TTL 설정에 대한 자세한 내용은 TTL 정책으로 데이터 보관 관리 문서를 참조하세요.'
 'Q: FirestoreAdmin API에서 인덱스의 밀도 구성(Density) 값은 무엇이 있나요?\nA: | Enums |\n| --- |\n| DENSITY_UNSPECIFIED | Unspecified. It will use database default setting. This value is input only. |\n| SPARSE_ALL | In order for an index entry to be added, the document must contain all fields specified in the index. This is the only allowed value for indexes having ApiScope ANY_API and DATASTORE_MODE_API. |\n| SPARSE_ANY | In order for an index entry to be added, the document must contain at least one of the fields specified in the index. Non-existent fields are treated as having a NULL value when generating index entries. |\n| DENSE | An index entry will be added regardless of whether the document contains any of the fields specified in the index. Non-existent fields are treated as having a NULL value when generating index entries.'
 'Q: TTL 정책을 수정하기 위해 필요한 권한은 무엇인가요?\nA: TTL 정책을 수정하려면 datastore.indexes.update 권한이 필요합니다. 또한 TTL 정책을 보려면 datastore.indexes.list 및 datastore.indexes.get 권한이 필요하며, TTL 작업의 상태를 확인하려면 datastore.operations.list 및 datastore.operations.get 권한이 필요합니다.'
 'Q: TTL 정책을 삭제한 후 Firestore에서 어떤 결과가 발생하나요?\nA: TTL 정책을 삭제하면 Firestore가 테이블에서 TTL 정책을 삭제합니다. 성공하면 콘솔이 TTL(수명) 페이지로 돌아갑니다.'
 'Q: Firestore의 TTL 측정항목은 어떤 용도로 사용되나요?\nA: TTL 측정항목은 Firestore Native와 Datastore 모드의 Firestore 데이터베이스 모두에서 적용된 TTL 정책의 효과를 모니터링하는 데 사용됩니다.'
 'Q: Target를 설정할 때 필수로 포함해야 하는 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| target_id | int32 The target ID that identifies the target on the stream. Must be a positive number and non-zero. If target_id is 0 (or unspecified), the server will assign an ID for this target and return that in a TargetChange::ADD event. Once a target with target_id=0 is added, all subsequent targets must also have target_id=0. If an AddTarget request with target_id != 0 is sent to the server after a target with target_id=0 is added, the server will immediately send a response with a TargetChange::Remove event. Note that if the client sends multiple AddTarget requests without an ID, the order of IDs returned in TargetChange.target_ids are undefined. Therefore, clients should provide a target ID instead of relying on the server to assign one. If target_id is non-zero, there must not be an existing active target on this stream with the same ID. |\n| once | bool If the target should be removed once it is current and consistent. |\n| expected_count | Int32Value The number of documents that last matched the query at the resume token or read time. This value is only relevant when a resume_type is provided. This value being present and greater than zero signals that the client wants ExistenceFilter.unchanged_names to be included in the response. |']","TTL(Time-to-Live)은 문서의 생존 기간을 설정하는 구성입니다. TTL이 활성화된 필드에 타임스탬프 값을 저장하면 해당 문서의 절대 만료 시간으로 처리됩니다. 과거의 타임스탬프 값을 가지는 문서는 즉시 만료될 수 있습니다. TTL 필드를 설정할 때는 타임스탬프 값을 사용해야 하며, 다른 데이터 유형을 사용하거나 필드를 비워두면 만료가 비활성화됩니다.

TTL 정책을 설정할 때의 한도 및 제약조건은 다음과 같습니다:
- 컬렉션당 하나의 필드만 TTL 필드로 지정할 수 있습니다.
- 필드 수준 TTL 구성은 최대 500개까지 허용됩니다.","컬렉션 그룹당 하나의 필드만 TTL 필드로 표시할 수 있고, 필드 수준 구성은 최대 500개까지 허용됩니다. 또한 Datastore 모드의 Firestore 고객은 TTL을 항목 그룹을 사용한 낙관적 동시 실행 모드와 함께 사용할 수 없습니다."
Me want know what FUNCTION_ENTRYPOINT do in gcloud run deploy command?,"['--- 탭: gcloud [https://cloud.google.com/firestore/native/docs/extend-with-cloud-run-functions?hl=ko#gcloud] ---\n```\ngcloud run deploy\nFUNCTION \\\n--source . \\\n--function\nFUNCTION_ENTRYPOINT \\\n--base-image\nBASE_IMAGE_ID \\\n--region\nREGION\n```\n```\ngcloud eventarc triggers create\nTRIGGER_NAME  \\\n--location=\nEVENTARC_TRIGGER_LOCATION \\\n--destination-run-service=\nFUNCTION  \\\n--destination-run-region=\nREGION \\\n--event-filters=""type=google.cloud.firestore.document.v1.created"" \\\n--service-account=\nPROJECT_NUMBER-compute@developer.gserviceaccount.com\n```\n\n--- 탭: Terraform [https://cloud.google.com/firestore/native/docs/extend-with-cloud-run-functions?hl=ko#terraform] ---\nCloud Run 함수의 Eventarc 트리거를 만들려면 Terraform을 사용하여 트리거 만들기 [https://cloud.google.com/eventarc/docs/creating-triggers-terraform?hl=ko]를 참조하세요.\n예시\n\n다음 예에서는 기본 모드 이벤트에서 Firestore를 사용하여 Cloud Run 함수를 트리거하는 방법을 설명합니다.\n\n예 1: Hello Firestore 함수\n\n다음 샘플은 트리거하는 Firestore 이벤트의 필드를 출력합니다.'
 '다음 gcloud dataproc batches submit pyspark [https://cloud.google.com/sdk/gcloud/reference/dataproc/batches/submit/pyspark?hl=ko] 명령어를 사용하여 일괄 작업을 제출합니다.\n\ngcloud dataproc batches submit pyspark PYTHON_SCRIPT_PATH \\\n --version=2.2 \\\n --project=PROJECT_ID \\\n --region=REGION \\\n --deps-bucket=BUCKET_PATH \\\n --properties=""spark.sql.catalog.CATALOG_NAME=org.apache.iceberg.spark.SparkCatalog,spark.sql.catalog.CATALOG_NAME.catalog-impl=org.apache.iceberg.gcp.bigquery.BigQueryMetastoreCatalog,spark.sql.catalog.CATALOG_NAME.gcp_project=PROJECT_ID,spark.sql.catalog.CATALOG_NAME.gcp_location=LOCATION,spark.sql.catalog.CATALOG_NAME.warehouse=WAREHOUSE_DIRECTORY""\n\n다음을 바꿉니다.\n\n\nPYTHON_SCRIPT_PATH: 일괄 작업에서 사용하는 Python 스크립트의 경로\nPROJECT_ID: 일괄 작업을 실행할 Google Cloud 프로젝트의 ID입니다.\nREGION: 워크로드가 실행되는 리전\nBUCKET_PATH: 워크로드 종속 항목을 업로드할 Cloud Storage 버킷의 위치.\n버킷의 gs:// URI 프리픽스는 필요하지 않습니다. 버킷 경로 또는 버킷 이름을 지정할 수 있습니다(예: mybucketname1).'
 ""참고: Terraform 샘플은 일반적으로 필요한 API가 Google Cloud 프로젝트에서 사용 설정되었다고 가정합니다.\n서비스 계정에 액세스 권한 부여\n연결의 서비스 계정에 Vertex AI 사용자 및 스토리지 객체 뷰어 역할을 부여합니다.\n원격 모델을 만들 때 엔드포인트를 URL(예: endpoint = 'https://us-central1-aiplatform.googleapis.com/v1/projects/myproject/locations/us-central1/publishers/google/models/gemini-2.0-flash')로 지정할 계획이라면 URL에 지정한 동일한 프로젝트에서 이 역할을 부여합니다.\n원격 모델을 만들 때 모델 이름을 사용(예: endpoint = 'gemini-2.0-flash')하여 엔드포인트를 지정할 계획이라면 원격 모델을 만들려는 동일한 프로젝트에서 이 역할을 부여합니다.\n다른 프로젝트에서 역할을 부여하면 bqcx-1234567890-wxyz@gcp-sa-bigquery-condel.iam.gserviceaccount.com does not have the permission to access resource 오류가 발생합니다.\n이러한 역할을 부여하려면 다음 단계를 수행합니다.\n--- 탭: 콘솔 ---\nIAM 및 관리자 페이지로 이동합니다.\n\nIAM 및 관리자로 이동 [https://console.cloud.google.com/project/_/iam-admin?hl=ko] \nperson_add 추가를 클릭합니다.\n\n주 구성원 추가 대화상자가 열립니다.\n새 주 구성원 필드에 앞에서 복사한 서비스 계정 ID를 입력합니다.\n역할 선택 필드에서 Vertex AI를 선택한 후 Vertex AI 사용자를 선택합니다.\n다른 역할 추가를 클릭합니다.\n역할 선택 필드에서 Cloud Storage를 선택한 후 스토리지 객체 뷰어를 선택합니다.\n저장을 클릭합니다.\n\n--- 탭: gcloud ---\ngcloud projects add-iam-policy-binding 명령어 [https://cloud.google.com/sdk/gcloud/reference/projects/add-iam-policy-binding?hl=ko]를 사용합니다.""
 ""참고: Terraform 샘플은 일반적으로 필요한 API가 Google Cloud 프로젝트에서 사용 설정되었다고 가정합니다.\n서비스 계정에 액세스 권한 부여\n연결의 서비스 계정에 Vertex AI 사용자 역할을 부여합니다.\n원격 모델을 만들 때 엔드포인트를 URL(예: endpoint = 'https://us-central1-aiplatform.googleapis.com/v1/projects/myproject/locations/us-central1/publishers/google/models/gemini-2.5-flash')로 지정할 계획이라면 URL에 지정한 동일한 프로젝트에서 이 역할을 부여합니다.\n원격 모델을 만들 때 모델 이름을 사용(예: endpoint = 'gemini-2.5-flash')하여 엔드포인트를 지정할 계획이라면 원격 모델을 만들려는 동일한 프로젝트에서 이 역할을 부여합니다.\n다른 프로젝트에서 역할을 부여하면 bqcx-1234567890-wxyz@gcp-sa-bigquery-condel.iam.gserviceaccount.com does not have the permission to access resource 오류가 발생합니다.\n역할을 부여하려면 다음 단계를 따르세요.\n--- 탭: 콘솔 [https://cloud.google.com/bigquery/docs/generate-table?hl=ko#%EC%BD%98%EC%86%94] ---\nIAM 및 관리자 페이지로 이동합니다.\n\nIAM 및 관리자로 이동 [https://console.cloud.google.com/project/_/iam-admin?hl=ko] \nperson_add 추가를 클릭합니다.\n\n주 구성원 추가 대화상자가 열립니다.\n새 주 구성원 필드에 앞에서 복사한 서비스 계정 ID를 입력합니다.\n역할 선택 필드에서 Vertex AI를 선택한 후 Vertex AI 사용자를 선택합니다.\n저장을 클릭합니다.\n\n--- 탭: gcloud [https://cloud.google.com/bigquery/docs/generate-table?hl=ko#gcloud] ---\ngcloud projects add-iam-policy-binding 명령어 [https://cloud.google.com/sdk/gcloud/reference/projects/add-iam-policy-binding?hl=ko]를 사용합니다.""
 '다음 명령어를 사용하여 Google Cloud 에 계정을 인증합니다.\ngcloud auth application-default login\n자세한 내용은 애플리케이션 기본 사용자 인증 정보의 작동 방식 [https://cloud.google.com/docs/authentication/application-default-credentials?hl=ko]을 참고하세요.\n사용자에게 bigquery.admin 및 logging.viewer 역할이 있는지 확인합니다. IAM 역할에 대한 자세한 내용은 액세스 제어 참조 [https://cloud.google.com/bigquery/docs/access-control?hl=ko]를 참고하세요.\n프로젝트의 모든 전송 구성 나열\n프로젝트의 모든 전송 구성을 나열하려면 다음 명령어를 사용합니다.\n  ./dwh-dts-status --list-transfer-configs --project-id=[\nPROJECT_ID] --location=[\nLOCATION]\n다음을 바꿉니다.\nPROJECT_ID : 전송을 실행하는 Google Cloud 프로젝트 ID입니다.\nLOCATION : 전송 구성이 생성된 위치입니다.\n이 명령어는 전송 구성 이름과 ID 목록이 포함된 표를 출력합니다.\n구성의 모든 테이블 상태 보기\n전송 구성에 포함된 모든 테이블의 상태를 보려면 다음 명령어를 사용합니다.\n  ./dwh-dts-status --list-status-for-config --project-id=[\nPROJECT_ID] --config-id=[\nCONFIG_ID] --location=[\nLOCATION]\n다음을 바꿉니다.\nPROJECT_ID: 전송을 실행하는 Google Cloud 프로젝트 ID입니다.\nLOCATION: 전송 구성이 생성된 위치입니다.\nCONFIG_ID: 지정된 전송 구성의 ID입니다.\n이 명령어는 지정된 전송 구성에 있는 테이블 목록과 전송 상태가 포함된 표를 출력합니다. 전송 상태는 PENDING, RUNNING, SUCCEEDED, FAILED, CANCELLED 중 하나일 수 있습니다.\n데이터베이스의 모든 테이블 상태 보기\n특정 데이터베이스에서 전송된 모든 테이블의 상태를 보려면 다음 명령어를 사용합니다.\n  ./dwh-dts-status --list-status-for-database --project-id=[\nPROJECT_ID] --database=['
 'export const beforecreated = beforeUserCreated((event) => {\n// TODO\nreturn;\n});\n```\n\n--- 탭: Python [https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko#python] ---\n```\n@identity_fn.before_user_created()\ndef created_noop(event: identity_fn.AuthBlockingEvent) -> identity_fn.BeforeCreateResponse | None:\nreturn\n```\n위 예시에서는 커스텀 인증 로직 구현이 생략되었습니다. 특정 예에 대한 차단 함수 및 일반적인 시나리오 [https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko#common-scenarios]를 구현하는 방법을 알아보려면 다음 섹션을 참조하세요.\nFirebase CLI를 사용한 함수 배포:\nfirebase deploy --only functions\n\n함수를 업데이트할 때마다 다시 배포해야 합니다.\n\n사용자 및 컨텍스트 정보 가져오기\n\n차단 이벤트는 사용자의 로그인 정보가 포함된 AuthBlockingEvent 객체를 제공합니다. 작업 진행을 허용할지 여부를 결정하기 위해 이러한 값을 코드에서 사용합니다.\n\n객체에는 다음 속성이 포함되어 있습니다.'
 '비밀번호 해시의 민감한 특성으로 인해 Firebase Admin SDK 서비스 계정에는 기본적으로 firebaseauth.configs.getHashConfig 권한이 없습니다. 사용자 서비스 계정에 권한을 직접 추가할 수 없지만 커스텀 IAM 역할을 만들어 [https://cloud.google.com/iam/docs/creating-custom-roles?hl=ko] 간접적으로 권한을 추가할 수 있습니다.\n\n커스텀 IAM 역할을 만들려면 다음 안내를 따르세요.\n\nGoogle Cloud 콘솔의 IAM 및 관리자 패널에서 역할 페이지로 이동합니다.\n페이지 상단의 드롭다운에서 프로젝트를 선택합니다.\n역할 만들기를 클릭합니다.\n권한 추가를 클릭합니다.\nfirebaseauth.configs.getHashConfig 권한을 검색하고 해당 체크박스를 선택합니다.\n추가를 클릭합니다.\n만들기를 클릭하여 새 역할 만들기를 마칩니다.\n\nIAM 페이지의 사용자/서비스 계정에 만든 커스텀 역할을 추가합니다.\n\nIAM 및 관리자 패널에서 IAM을 선택합니다.\n구성원 목록에서 서비스 또는 사용자 계정을 선택하여 수정합니다.\n다른 역할 추가를 클릭합니다.\n이전에 만든 새 커스텀 역할을 검색합니다.\n저장을 클릭합니다.\n\n경고: firebaseauth.configs.getHashConfig 권한을 추가하는 수단으로 Editor 역할을 사용하지 마세요. 이 강력한 역할은 의도한 범위를 벗어난 권한을 제공합니다.\n\n도움이 되었나요?\n\n의견 보내기'
 ""export const beforecreated = beforeUserCreated((event) => {\nconst user = event.data;\nif (event.credential &&\nevent.credential.providerId === 'google.com') {\n// Store the refresh token for later offline use.\n// These will only be returned if refresh tokens credentials are included\n// (enabled by Cloud console).\nreturn saveUserRefreshToken(\nuser.uid,\nevent.credential.refreshToken,\n'google.com'\n)\n.then(() => {\n// Blocking the function is not required. The function can resolve while\n// this operation continues to run in the background.\nreturn new Promise((resolve, reject) => {\n// For this operation to succeed, the appropriate OAuth scope should be requested\n// on sign in with Google, client-side. In this case:\n// https://www.googleapis.com/auth/calendar\n// You can check granted_scopes from within:\n// event.additionalUserInfo.profile.granted_scopes (space joined list of scopes).""
 ""Firebase에 앱 연결\n\n아직 수행하지 않았으면 Flutter의 Firebase SDK를 설치하고 초기화 [https://firebase.google.com/docs/flutter/setup?hl=ko]합니다.\n\n앱에 Firebase 인증 추가\n\nFlutter 프로젝트 루트에서 다음 명령어를 실행하여 플러그인을 설치합니다.\nflutter pub add firebase_auth\n\n완료되면 Flutter 애플리케이션을 다시 빌드합니다.\nflutter run\n\nDart 코드에서 플러그인을 가져옵니다.\nimport 'package:firebase_auth/firebase_auth.dart';\n\n인증 제공업체를 사용하려면 Firebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 제공업체를 사용 설정해야 합니다.\nFirebase 인증 섹션의 로그인 방법 페이지로 이동하여 이메일/비밀번호 로그인과 앱에 사용할 다른 ID 공급업체를 사용 설정합니다.\n\n(선택사항) Firebase 로컬 에뮬레이터 도구 모음으로 프로토타입 제작 및 테스트\n\n앱에서 사용자를 인증하는 방법을 설명하기 전에 인증 기능의 프로토타입을 제작하고 테스트하는 데 사용할 수 있는 도구 모음인 Firebase 로컬 에뮬레이터 도구 모음을 소개하겠습니다. 사용할 인증 기술과 제공업체를 결정하거나, 인증 및 Firebase 보안 규칙을 사용하는 공개 및 비공개 데이터가 포함된 다양한 데이터 모델을 사용해 보거나, 로그인 UI 디자인의 프로토타입을 제작하는 경우 라이브 서비스를 배포하지 않고 로컬에서 작업할 수 있다는 것은 획기적인 아이디어입니다.\n\n인증 에뮬레이터는 로컬 에뮬레이터 도구 모음의 일부이며 앱에서 에뮬레이션된 데이터베이스 콘텐츠와 구성은 물론 필요에 따라 에뮬레이션된 프로젝트 리소스(함수, 기타 데이터베이스, 보안 규칙)와 상호작용할 수 있게 해줍니다.\n\n인증 에뮬레이터를 사용하려면 다음 몇 단계만 거치면 됩니다.""
 '이러한 위험을 완화하려면 Google Cloud gcloud 도구를 사용하여 프로젝트에 이메일 열거 보호 기능을 사용 설정 [https://cloud.google.com/identity-platform/docs/admin/email-enumeration-protection?hl=ko]하는 것이 좋습니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경됩니다. 앱이 더 구체적인 오류에 의존하지 않는지 확인하세요.\n\n다음 단계\n\n사용자가 처음으로 로그인하면 신규 사용자 계정이 생성되고 사용자가 로그인할 때 사용한 사용자 인증 정보(사용자 이름과 비밀번호, 전화번호 또는 인증 제공업체 정보)에 연결됩니다. 이 신규 계정은 Firebase 프로젝트의 일부로 저장되며 사용자의 로그인 방법에 관계없이 프로젝트 내 모든 앱에서 사용자를 식별하는 데 사용될 수 있습니다.\n\n앱의 FirebaseUser [https://firebase.google.com/docs/reference/android/com/google/firebase/auth/FirebaseUser?hl=ko] 객체에서 사용자의 기본 프로필 정보를 가져올 수 있습니다. 사용자 관리 [https://firebase.google.com/docs/auth/android/manage-users?hl=ko]를 참조하세요.\n\nFirebase Realtime Database와 Cloud Storage 보안 규칙 [https://firebase.google.com/docs/database/security/user-security?hl=ko]의 auth 변수에서 로그인한 사용자의 고유 사용자 ID를 가져온 후 이 ID를 통해 사용자가 액세스할 수 있는 데이터를 관리할 수 있습니다.\n\n인증 제공업체의 사용자 인증 정보를 기존 사용자 계정에 연결 [https://firebase.google.com/docs/auth/android/account-linking?hl=ko]하면 사용자가 여러 인증 제공업체를 통해 앱에 로그인할 수 있습니다.\n\n사용자를 로그아웃시키려면 signOut [https://firebase.google.com/docs/reference/android/com/google/firebase/auth/FirebaseAuth?hl=ko#signOut()]을 호출합니다.'
 ""진입수\n탐색 지점\n개요 작성\n입장권\n위 기능에 Geocoding API v3를 사용한 경우 이 문서를 참고하여 대신 SearchDestinations 엔드포인트를 사용하여 이러한 기능을 가져오세요. 이 문서에서는 SearchDestinations API 응답에서 이러한 기능을 찾을 수 있는 위치와 Geocoding API v3와 Geocoding API v4의 SearchDestinations 엔드포인트 간에 API 응답에 이러한 기능이 표시되는 방식의 차이점을 설명합니다.\n진입수\ndestination [https://developers.google.com/maps/documentation/geocoding/reference/rest/v4alpha/geocode.destinations/searchDestinations?hl=ko#destination]와 연결된 입구를 가져오려면 destination.entrances 필드를 사용합니다.\nentrance [https://developers.google.com/maps/documentation/geocoding/reference/rest/v4alpha/geocode.destinations/searchDestinations?hl=ko#entrance]의 형식은 Geocoding API v3의 입구 형식 [https://developers.google.com/maps/documentation/geocoding/building-attributes?hl=ko]과 약간 다릅니다. destination.entrances의 각 입구에는 다음 필드가 있습니다.\ndisplayName - 출입구의 사람이 읽을 수 있는 이름을 갖는 새로운 선택적 필드입니다(예: 'Gate B').\nlocation - LatLng [https://developers.google.com/maps/documentation/geocoding/reference/rest/Shared.Types/LatLng?hl=ko] 유형의 위치입니다. Geocoding API v3에서 사용되는 형식과 다릅니다.\ntags - Geocoding API v3의 진입로 tags 필드와 동일합니다.\nplace - Geocoding API v3의 진입로 buildingPlaceId 필드와 유사합니다. 하지만 이 필드의 장소 ID는 건물뿐만 아니라 모든 유형의 장소일 수 있습니다.\n탐색 지점""
 '--- 탭: Python [https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko#python] ---\n```\n@identity_fn.before_user_signed_in()\ndef ipban(event: identity_fn.AuthBlockingEvent) -> identity_fn.BeforeSignInResponse | None:\nif is_suspicious(event.ip_address):\nraise https_fn.HttpsError(code=https_fn.FunctionsErrorCode.PERMISSION_DENIED,\nmessage=""IP banned."")\nmain.py [https://github.com/firebase/functions-samples/blob/c4fde45b65fab584715e786ce3264a6932d996ec/Python/quickstarts/auth-blocking-functions/functions/main.py#L116-L120]\n```\n커스텀 및 세션 클레임 설정\n\n다음 예시에서는 커스텀 및 세션 클레임을 설정하는 방법을 보여줍니다.\n\n--- 탭: Node.js [https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ko#node.js] ---\n```\nexport const beforecreated = beforeUserCreated((event) => {\nif (event.credential &&\nevent.credential.claims &&\nevent.credential.providerId === ""saml.my-provider-id"") {\nreturn {\n// Employee ID does not change so save in persistent claims (stored in\n// Auth DB).\ncustomClaims: {\neid: event.credential.claims.employeeid,\n},\n};\n}\n});'
 '--- 탭: Swift [https://firebase.google.com/docs/auth/ios/single-sign-on?hl=ko#swift] ---\n```\nlet accessGroup = ""TEAMID.com.example.group1""\nvar tempUser: User?\ndo {\ntry tempUser = Auth.auth().getStoredUser(forAccessGroup: accessGroup)\n} catch let error as NSError {\nprint(""Error getting stored user: %@"", error)\n}\nif tempUser != nil {\n// A user exists in the access group\n} else {\n// No user exists in the access group\n}\n```\n\n--- 탭: Objective-C [https://firebase.google.com/docs/auth/ios/single-sign-on?hl=ko#objective-c] ---\n```\nNSString *accessGroup = @""TEAMID.com.example.group1"";\nFIRUser *tempUser = [FIRAuth getStoredUserForAccessGroup:accessGroup\nerror:nil];\nif (tempUser) {\n// A user exists in the access group\n} else {\n// No user exists in the access group\n}\n```\n프로젝트 설정에서 이전에 설정한 액세스 그룹을 사용합니다.\n\n--- 탭: Swift [https://firebase.google.com/docs/auth/ios/single-sign-on?hl=ko#swift] ---\n```\ndo {\ntry Auth.auth().useUserAccessGroup(accessGroup)\n} catch let error as NSError {\nprint(""Error changing user access group: %@"", error)\n}\n```'
 ""ui.start('#firebaseui-auth-container', {\nsignInOptions: [\n{\nprovider: firebase.auth.GoogleAuthProvider.PROVIDER_ID,\nscopes: [\n'https://www.googleapis.com/auth/contacts.readonly'\n],\ncustomParameters: {\n// Forces account selection even when one account\n// is available.\nprompt: 'select_account'\n}\n},\n{\nprovider: firebase.auth.FacebookAuthProvider.PROVIDER_ID,\nscopes: [\n'public_profile',\n'email',\n'user_likes',\n'user_friends'\n],\ncustomParameters: {\n// Forces password re-entry.\nauth_type: 'reauthenticate'\n}\n},\nfirebase.auth.TwitterAuthProvider.PROVIDER_ID, // Twitter does not support scopes.\nfirebase.auth.EmailAuthProvider.PROVIDER_ID // Other providers don't need to be given as object.\n]\n});\n\n전화번호\n\nFirebase Console [https://console.firebase.google.com/?hl=ko]에서 인증 섹션을 열고 전화번호 로그인을 사용 설정합니다.\n로그인 페이지를 렌더링할 도메인이 승인된 도메인 목록에 추가되었는지도 확인합니다.\nFirebaseUI signInOptions 목록에 전화번호 제공업체 ID를 추가합니다.""
 'Q: gcloud 명령어를 사용하여 Firestore 이벤트를 트리거하는 Cloud Run 함수를 배포하는 방법은 무엇인가요?\nA: 다음 gcloud 명령어를 사용하여 Cloud Run 함수를 배포할 수 있습니다:\n```\ngcloud run deploy\nFUNCTION \\\n--source . \\\n--function FUNCTION_ENTRYPOINT \\\n--base-image BASE_IMAGE_ID \\\n--region REGION\n```'
 ""Q: gcloud 명령어를 사용하여 가져오기 작업을 시작하는 방법은 무엇인가요?\nA: gcloud 명령어를 사용하여 가져오기 작업을 시작하려면 다음과 같이 입력합니다:\n\n```\ngcloud firestore import gs://[BUCKET_NAME]/[EXPORT_PREFIX]/ --database=[DATABASE]\n```\n여기서 BUCKET_NAME/EXPORT_PREFIX는 내보내기 파일의 위치이며, DATABASE는 데이터베이스 이름입니다. 기본 데이터베이스에는 --database='(default)'를 사용합니다.""
 'Q: Cloud Run 호출자 역할을 Compute Engine 기본 서비스 계정에 부여하는 방법은 무엇인가요?\nA: Cloud Run 호출자 역할(run.invoker)을 Compute Engine 기본 서비스 계정에 부여하려면 다음 명령어를 사용하세요:\n\n```bash\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n--member=serviceAccount:PROJECT_NUMBER-compute@developer.gserviceaccount.com \\\n--role=roles/run.invoker\n```'
 'Q: Cloud Run 호출자 역할을 Compute Engine 기본 서비스 계정에 부여하는 방법은 무엇인가요?\nA: Cloud Run 호출자 역할을 Compute Engine 기본 서비스 계정에 부여하려면 다음 명령어를 사용하세요:\n\n```bash\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n--member=serviceAccount:PROJECT_NUMBER-compute@developer.gserviceaccount.com \\\n--role=roles/run.invoker\n```'
 'Q: Cloud Firestore 데이터베이스에 대한 읽기 및 쓰기 권한을 부여하기 위해 gcloud 명령어를 사용하는 방법은 무엇인가요?\nA: 서비스 계정에 Cloud Firestore에 대한 읽기 및 쓰기 권한이 있는 roles/datastore.user 역할을 부여하려면 다음 명령어를 실행합니다.\n\n```bash\ngcloud projects add-iam-policy-binding PROJECT_NAME --member=""SERVICE_ACCOUNT_EMAIL"" --role=roles/datastore.user\n```\n\n다음을 바꿉니다.\n- PROJECT_NAME: 프로젝트의 이름\n- SERVICE_ACCOUNT_EMAIL: 만든 서비스 계정의 이메일 주소'
 'Q: Firebase에서 이메일 열거 보호 기능을 사용 설정하는 방법은 무엇인가요?\nA: 이메일 열거 보호 기능을 사용 설정하려면 Google Cloud gcloud 도구를 사용하여 프로젝트에 이메일 열거 보호 기능을 사용 설정하는 것이 좋습니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경됩니다.'
 'Q: Flutter 프로젝트에 Firebase 인증을 추가하는 방법은 무엇인가요?\nA: Flutter 프로젝트 루트에서 다음 명령어를 실행하여 플러그인을 설치합니다.\n```\nflutter pub add firebase_auth\n```\n완료되면 Flutter 애플리케이션을 다시 빌드합니다.\n```\nflutter run\n```'
 'Q: 이메일 작업 처리 시 continueURL 쿼리 파라미터의 역할은 무엇인가요?\nA: 이메일 작업 처리 시 continueURL 쿼리 파라미터의 링크는 페이로드가 ActionCodeSettings 객체에 지정된 URL인 Hosting 링크가 됩니다.'
 'Q: 이메일 작업에서 linkDomain 매개변수의 역할은 무엇인가요?\nA: linkDomain 매개변수는 프로젝트에 커스텀 호스팅 링크 도메인이 정의된 경우, 지정된 모바일 앱에서 링크를 열 때 사용할 도메인을 지정하는 역할을 합니다.'
 'Q: Firebase에서 이메일 열거 보호 기능을 사용 설정하는 방법은 무엇인가요?\nA: 이메일 열거 보호 기능을 사용 설정하려면 Google Cloud gcloud 도구를 사용하여 프로젝트에 기능을 활성화해야 합니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경됩니다.'
 ""Q: firebase.auth.ActionCodeSettings의 매개변수 중 'url'의 역할은 무엇인가요?\nA: url 매개변수는 컨텍스트에 따라 다른 의미를 가지는 링크(상태/연결 URL)를 설정합니다. 웹 작업 위젯에서 링크가 처리되는 경우 continueUrl 쿼리 매개변수의 딥 링크입니다.""
 'Q: 이메일 작업을 처리할 때 oobCode 쿼리 매개변수의 역할은 무엇인가요?\nA: 이메일 인증과 같은 이메일 작업을 처리할 때는 oobCode 쿼리 매개변수의 작업 코드를 딥 링크에서 파싱한 다음 applyActionCode를 통해 변경사항이 적용되도록 합니다(즉, 이메일 인증).'
 'Q: Firebase Authentication with Identity Platform에서 차단 함수(blocking function)의 역할은 무엇인가요?\nA: 차단 함수(blocking function)는 사용자가 앱에 등록하거나 로그인한 결과를 수정하는 커스텀 코드를 실행할 수 있게 해줍니다. 차단 함수로 Firebase Authentication을 확장하는 방법을 알아보세요.'
 'Q: Chrome 확장 프로그램에서 Firebase Authentication을 사용할 때, 오프스크린 문서의 역할은 무엇인가요?\nA: 오프스크린 문서는 `signInWithPopup`, `linkWithPopup`, `reauthenticateWithPopup`과 같은 인증 방법을 사용할 때 필요합니다. 이 문서는 iframe 내에서 코드를 로드하여 Chrome 확장 프로그램과의 호환성을 제공합니다.'
 'Q: Firebase Authentication에서 이메일 작업 링크를 처리할 때 oobCode 쿼리 매개변수의 역할은 무엇인가요?\nA: 이메일 인증과 같은 이메일 작업을 처리할 때 oobCode 쿼리 매개변수는 작업 코드를 딥 링크에서 파싱하는 데 사용됩니다. 이후 applyActionCode를 통해 변경사항이 적용됩니다.'
 'Q: Firebase에서 이메일 열거 보호 기능을 사용 설정하는 방법은 무엇인가요?\nA: 이메일 열거 보호 기능을 사용 설정하려면 Google Cloud gcloud 도구를 사용하여 프로젝트에 해당 기능을 활성화해야 합니다. 이 기능을 사용 설정하면 Firebase Authentication의 오류 보고 동작이 변경되어, 사용자가 등록한 이메일 주소를 악의적인 행위자가 발견하는 것을 방지할 수 있습니다.'
 'Q: Firebase에서 이메일 링크를 전송하기 위한 actionCodeSettings 객체의 필드 중 linkDomain의 역할은 무엇인가요?\nA: linkDomain 필드는 프로젝트에 대해 커스텀 Hosting 링크 도메인이 정의된 경우, 지정된 모바일 앱에서 링크를 열 때 사용할 도메인을 지정합니다. 만약 정의되지 않은 경우, 기본 도메인이 자동으로 선택됩니다.'
 'Q: TOTP MFA에서 인접한 기간 간격(NUM_ADJ_INTERVALS)의 역할은 무엇인가요?\nA: TOTP MFA에서 인접한 기간 간격(NUM_ADJ_INTERVALS)은 TOTP를 수락할 수 있는 인접한 기간의 수를 정의합니다. 이는 두 당사자(증명자 및 검사자)가 동일한 기간(일반적으로 30초) 내에 OTP를 생성할 때 동일한 비밀번호를 생성하도록 하며, 클럭 드리프트와 사람의 응답 시간을 수용하기 위해 TOTP 서비스가 인접한 기간의 TOTP도 허용하도록 구성할 수 있습니다.'
 ""Q: firebase.auth.ActionCodeSettings의 'handleCodeInApp' 매개변수의 기본값은 무엇인가요?\nA: 'handleCodeInApp' 매개변수의 기본값은 false입니다.""
 'Q: FirebaseUI를 npm을 통해 설치하는 방법은 무엇인가요?\nA: $ npm install firebaseui --save'
 'Q: Objective-C에서 Microsoft OAuthProvider의 인스턴스를 생성하는 방법은 무엇인가요?\nA: FIROAuthProvider *provider = [FIROAuthProvider providerWithProviderID:@""microsoft.com""];'
 'Q: 사용자를 로그아웃시키기 위해 호출해야 하는 메서드는 무엇인가요?\nA: 사용자를 로그아웃시키려면 signOut [https://firebase.google.com/docs/reference/js/auth?hl=ko#signout]을 호출합니다.'
 'Q: FirebaseUI에서 Facebook 제공업체 인스턴스를 Swift로 초기화하는 방법은 무엇인가요?\nA: provider = FUIFacebookAuth(authUI: FUIAuth.defaultAuthUI())'
 'Q: gcloud 명령어를 사용하여 Cloud Firestore 데이터베이스에 대한 읽기 및 쓰기 액세스 권한을 부여하는 방법은 무엇인가요?\nA: 기본적으로 이 새 사용자 인증 정보에는 권한이 없습니다. 데이터베이스에 대한 읽기 및 쓰기 액세스 권한을 부여하려면 이 특정 데이터베이스에 대해 roles/datastore.user 역할을 추가합니다.\n\n```bash\ngcloud projects add-iam-policy-binding PROJECT_NAME \\\n--member=\'principal://firestore.googleapis.com/projects/PROJECT_NUMBER/name/databases/DATABASE_ID/userCreds/USERNAME\' \\\n--role=roles/datastore.user \\\n--condition=\'expression=resource.name == ""projects/PROJECT_NAME/databases/DATABASE_ID"",title=""CONDITION_TITLE""\'\n```\n다음을 바꿉니다.\n- PROJECT_NAME: 프로젝트의 이름\n- PROJECT_NUMBER: 프로젝트 번호\n- DATABASE_ID: 데이터베이스 ID\n- USERNAME: 이전에 만든 사용자 이름\n- CONDITION_TITLE: 이 조건의 제목입니다.'
 'Q: Swift에서 액세스 그룹의 인증 상태를 확인하는 방법은 무엇인가요?\nA: Swift에서 액세스 그룹의 인증 상태를 확인하려면 다음 코드를 사용하세요.\n```swift\nlet accessGroup = ""TEAMID.com.example.group1""\nvar tempUser: User?\ndo {\ntry tempUser = Auth.auth().getStoredUser(forAccessGroup: accessGroup)\n} catch let error as NSError {\nprint(""Error getting stored user: %@"", error)\n}\nif tempUser != nil {\n// A user exists in the access group\n} else {\n// No user exists in the access group\n}\n```'
 'Q: Swift에서 공유 키체인에 사용자 인증 상태가 존재하는지 확인하는 방법은 무엇인가요?\nA: 다음 코드를 사용하여 인증 상태를 확인할 수 있습니다.\n```swift\nlet accessGroup = ""TEAMID.com.example.group1""\nvar tempUser: User?\ndo {\n    try tempUser = Auth.auth().getStoredUser(forAccessGroup: accessGroup)\n} catch let error as NSError {\n    print(""Error getting stored user: %@"", error)\n}\nif tempUser != nil {\n    // A user exists in the access group\n} else {\n    // No user exists in the access group\n}\n```'
 'Q: TOTP MFA에서 사용자가 OTP를 입력하고 MFA 등록을 완료하는 방법은 무엇인가요?\nA: // Ask the user for a verification code from the authenticator app.\nlet verificationCode = // Code from user input.\n\n// Finalize the enrollment.\nlet multiFactorAssertion = TOTPMultiFactorGenerator.assertionForEnrollment(\nwith: totpSecret,\noneTimePassword: verificationCode)\ndo {\ntry await currentUser.multiFactor.enroll(\nwith: multiFactorAssertion,\ndisplayName: ""TOTP"")\n} catch {\n// Wrong or expired OTP. Re-prompt the user.\n}'
 'Q: TOTP MFA에서 사용자가 TOTP를 입력하고 로그인하는 방법은 무엇인가요?\nA: let multiFactorInfo = resolver.hints[selectedIndex]\nswitch multiFactorInfo.factorID {\ncase TOTPMultiFactorID:\nlet otpFromAuthenticator = // OTP typed by the user.\nlet assertion = TOTPMultiFactorGenerator.assertionForSignIn(\nwithEnrollmentID: multiFactorInfo.uid,\noneTimePassword: otpFromAuthenticator)\ndo {\nlet authResult = try await resolver.resolveSignIn(with: assertion)\n} catch {\n// Wrong or expired OTP. Re-prompt the user.\n}\ndefault:\nreturn\n}'
 'Q: TOTP MFA에서 사용자가 TOTP를 입력하고 MFA 등록을 완료하는 방법은 무엇인가요?\nA: 사용자에게 OTP 앱에 표시된 TOTP를 입력하고 이를 사용하여 MFA 등록을 완료하라는 메시지를 표시합니다. 다음 코드를 사용하세요:\n\n```swift\n// Ask the user for a verification code from the authenticator app.\nlet verificationCode = // Code from user input.\n\n// Finalize the enrollment.\nlet multiFactorAssertion = TOTPMultiFactorGenerator.assertionForEnrollment(\n    with: totpSecret,\n    oneTimePassword: verificationCode)\ndo {\n    try await currentUser.multiFactor.enroll(\n        with: multiFactorAssertion,\n        displayName: ""TOTP"")\n} catch {\n    // Wrong or expired OTP. Re-prompt the user.\n}\n```'
 'Q: TOTP MFA에서 사용자가 등록 해제할 때 어떤 코드를 사용해야 하나요?\nA: guard let currentUser = Auth.auth().currentUser else { return }\n\n// Prompt the user to select a factor to unenroll, from this array:\ncurrentUser.multiFactor.enrolledFactors\n\n// ...\n\n// Unenroll the second factor.\nlet multiFactorInfo = currentUser.multiFactor.enrolledFactors[selectedIndex]\ndo {\ntry await currentUser.multiFactor.unenroll(with: multiFactorInfo)\n} catch let error as AuthErrorCode where error.code == .invalidUserToken {\n// Second factor unenrolled, but the user was signed out. Re-authenticate\n// them.\n}'
 'Q: 서비스 워커에서 Firebase 앱을 초기화하는 방법은 무엇인가요?\nA: // Initialize the Firebase app in the service worker script.\ninitializeApp(config);'
 'Q: TOTP MFA에서 사용자가 등록 해제할 때 어떤 절차를 따라야 하나요?\nA: 사용자를 등록 해제하고 오류를 처리하고 재인증을 트리거하려면 다음 코드를 사용하세요:\n\n```swift\nguard let currentUser = Auth.auth().currentUser else { return }\n\n// Prompt the user to select a factor to unenroll, from this array:\ncurrentUser.multiFactor.enrolledFactors\n\n// ...\n\n// Unenroll the second factor.\nlet multiFactorInfo = currentUser.multiFactor.enrolledFactors[selectedIndex]\ndo {\n    try await currentUser.multiFactor.unenroll(with: multiFactorInfo)\n} catch let error\n```'
 'Q: Firebase에서 다중 인증(MFA) 사용자가 성공적으로 로그인한 후 어떤 정보를 얻을 수 있나요?\nA: // UserCredential will also contain the user, additionalUserInfo, optional\n// credential (null for email/password) associated with the first factor sign-in.\n// For example, if the user signed in with Google as a first factor,\n// userCredential.additionalUserInfo will contain data related to Google\n// provider that the user signed in with.\n// - user.credential contains the Google OAuth credential.\n// - user.credential.accessToken contains the Google OAuth access token.\n// - user.credential.idToken contains the Google OAuth ID token.'
 'Q: 전화번호 인증 코드 전송을 위한 verifyPhoneNumber 메서드의 사용 예시는 무엇인가요?\nA: --- 탭: Swift ---\nPhoneAuthProvider.provider()\n.verifyPhoneNumber(phoneNumber, uiDelegate: nil) { verificationID, error in\nif let error = error {\nself.showMessagePrompt(error.localizedDescription)\nreturn\n}\n// Sign in using the verificationID and the code sent to the user\n// ...\n}\n\n--- 탭: Objective-C ---\n[[FIRPhoneAuthProvider provider] verifyPhoneNumber:userInput'
 'Q: 2차 인증을 완료하는 방법은 무엇인가요?\nA: // Complete sign-in. This will also trigger the Auth state listeners.\nresolver.resolveSignIn(multiFactorAssertion)\n.then(function (userCredential) {\n// userCredential will also contain the user, additionalUserInfo, optional\n// credential (null for email/password) associated with the first factor sign-in.\n// For example, if the user signed in with Google as a first factor,\n// userCredential.additionalUserInfo will contain data related to Google\n// provider that the user signed in with.\n// - user.credential contains the Google OAuth credential.\n// - user.credential.accessToken contains the Google OAuth access token.\n// - user.credential.idToken contains the Google OAuth ID token.\n});'
 'Q: 다중 인증(MFA)에서 SMS 인증 코드를 확인한 후 다음 단계는 무엇인가요?\nA: const multiFactorAssertion = PhoneMultiFactorGenerator.assertion(cred);\n// Complete sign-in. This will also trigger the Auth state listeners.\nresolver.resolveSignIn(multiFactorAssertion)\n.then(function (userCredential) {\n// userCredential will also contain the user, additionalUserInfo, optional\n// credential (null for email/password) associated with the first factor sign-in.\n// For example, if the user signed in with Google as a first factor,\n// userCredential.additionalUserInfo will contain data related to Google\n// provider that the user signed in with.\n// user.credential contains the Google OAuth credential.\n// user.credential.accessToken contains the Google OAuth access token.\n// user.credential.idToken contains the Google OAuth ID token.\n});'
 'Q: Firebase에서 전화번호 인증을 위해 사용자의 전화번호를 verifyPhoneNumber 메서드에 전달하는 방법은 무엇인가요?\nA: verifyPhoneNumber(_:uiDelegate:completion:)을 호출하면서 사용자의 전화번호를 전달합니다. 예를 들어, Swift에서는 다음과 같이 사용할 수 있습니다:\n\n```swift\nPhoneAuthProvider.provider()\n.verifyPhoneNumber(phoneNumber, uiDelegate: nil) { verificationID, error in\nif let error = error {\nself.showMessagePrompt(error.localizedDescription)\nreturn\n}\n// Sign in using the verificationID and the code sent to the user\n// ...\n}\n```'
 'Q: Objective-C에서 액세스 그룹의 인증 상태를 확인하는 방법은 무엇인가요?\nA: Objective-C에서 액세스 그룹의 인증 상태를 확인하려면 다음 코드를 사용하세요.\n```objective-c\nNSString *accessGroup = @""TEAMID.com.example.group1"";\nFIRUser *tempUser = [FIRAuth getStoredUserForAccessGroup:accessGroup\nerror:nil];\nif (tempUser) {\n// A user exists in the access group\n} else {\n// No user exists in the access group\n}\n```']","In the `gcloud run deploy` command, the `FUNCTION_ENTRYPOINT` specifies the entry point of the function you want to deploy. It is the function within your code that will be executed when the Cloud Run service is triggered. This entry point is defined in your source code and is necessary for the deployment process to know which function to execute.",FUNCTION_ENTRYPOINT는 gcloud run deploy 명령어에서 함수의 진입점을 지정하는 데 사용됩니다.
Google 피트니스 심박수 데이터 읽기 권한 범위는?,"['https://www.googleapis.com/auth/fitness.body_temperature.write Google 피트니스의 체온 정보에 추가합니다. Google에서 이 앱으로 내 체온 정보를 사용하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.heart_rate.read Google 피트니스에서 내 심박수 데이터를 확인하세요. Google에서 이 앱을 사용하여 내 심박수 정보를 공유하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.heart_rate.write Google 피트니스의 심박수 데이터에 추가합니다. Google에서 이 앱으로 내 심박수 정보를 사용하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.location.read Google 피트니스 속도 및 거리 데이터 확인\nhttps://www.googleapis.com/auth/fitness.location.write Google 피트니스 위치 데이터에 추가\nhttps://www.googleapis.com/auth/fitness.nutrition.read Google 피트니스에서 영양 정보 확인\nhttps://www.googleapis.com/auth/fitness.nutrition.write Google 피트니스의 영양 정보에 추가\nhttps://www.googleapis.com/auth/fitness.oxygen_saturation.read Google 피트니스에서 산소 포화도 정보 확인 Google에서 이 앱을 사용하여 내 산소 포화도 정보를 공유하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.oxygen_saturation.write Google 피트니스에서 산소 포화도 정보를 추가합니다. Google에서 이 앱으로 내 산소 포화도 정보를 사용하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.reproductive_health.read Google 피트니스에서 내 생식 건강 정보를 확인합니다. Google에서 이 앱을 사용하여 내 생식 건강 정보를 공유하는 것에 동의합니다.'
 'Fitness API [https://developers.google.com/fit/rest/v1/get-started?hl=ko], v1\n범위 설명\nhttps://www.googleapis.com/auth/fitness.activity.read Google 피트니스를 사용하여 신체 활동 데이터를 확인하고 저장\nhttps://www.googleapis.com/auth/fitness.activity.write Google 피트니스 신체 활동 데이터에 추가\nhttps://www.googleapis.com/auth/fitness.blood_glucose.read Google 피트니스에서 혈당 정보 확인 Google에서 이 앱을 사용하여 내 혈당 정보를 공유하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.blood_glucose.write Google 피트니스에 혈당 정보를 추가합니다. Google에서 이 앱으로 내 혈당 정보를 사용하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.blood_pressure.read Google 피트니스에서 혈압 정보 확인 Google에서 이 앱을 사용하여 내 혈압 정보를 공유하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.blood_pressure.write Google 피트니스에서 혈압 정보를 추가합니다. Google에서 이 앱으로 내 혈압 정보를 사용하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.body.read Google 피트니스에서 신체 측정 정보 확인\nhttps://www.googleapis.com/auth/fitness.body.write Google 피트니스에 신체 측정 정보 추가\nhttps://www.googleapis.com/auth/fitness.body_temperature.read Google 피트니스에서 체온 정보 확인 Google에서 이 앱을 사용하여 내 체온 정보를 공유하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.body_temperature.write Google 피트니스의 체온 정보에 추가합니다. Google에서 이 앱으로 내 체온 정보를 사용하는 것에 동의합니다.'
 'https://www.googleapis.com/auth/fitness.reproductive_health.read Google 피트니스에서 내 생식 건강 정보를 확인합니다. Google에서 이 앱을 사용하여 내 생식 건강 정보를 공유하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.reproductive_health.write Google 피트니스에서 생식 건강 정보를 추가합니다. Google에서 이 앱으로 내 생식 건강 정보를 사용하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.sleep.read Google 피트니스에서 수면 데이터를 확인할 수 있습니다. Google에서 내 수면 정보를 이 앱과 공유하는 것에 동의합니다.\nhttps://www.googleapis.com/auth/fitness.sleep.write Google 피트니스의 수면 데이터에 추가합니다. Google에서 이 앱으로 내 수면 정보를 사용하는 것에 동의합니다.\nGKE Hub API [https://cloud.google.com/anthos/multicluster-management/connect/registering-a-cluster?hl=ko], v2\n범위 설명\nhttps://www.googleapis.com/auth/cloud-platform Google Cloud 데이터 확인, 수정, 구성, 삭제 및 Google 계정 이메일 주소 확인\nGKE On-Prem API [https://cloud.google.com/anthos/clusters/docs/on-prem/?hl=ko], v1\n범위 설명\nhttps://www.googleapis.com/auth/cloud-platform Google Cloud 데이터 확인, 수정, 구성, 삭제 및 Google 계정 이메일 주소 확인\nGmail API [https://developers.google.com/workspace/gmail/api?hl=ko], v1\n범위 설명\nhttps://mail.google.com/ Gmail에서 모든 이메일 조회, 작성, 전송, 영구 삭제\nhttps://www.googleapis.com/auth/gmail.addons.current.action.compose 부가기능을 사용할 때 임시보관된 이메일 관리 및 이메일 전송'
 'Google Drive의 파일 메타데이터를 보기 위한 읽기 전용 액세스 권한과 Google Calendar 일정을 보기 위한 읽기 전용 액세스 권한을 요청하는 다음 샘플 URL을 클릭하여 이 흐름을 테스트할 수 있습니다.\n\n\n        https://accounts.google.com/o/oauth2/v2/auth?\n scope=https%3A//www.googleapis.com/auth/drive.metadata.readonly%20https%3A//www.googleapis.com/auth/calendar.readonly&\n include_granted_scopes=true&\n response_type=token&\n state=state_parameter_passthrough_value&\n redirect_uri=https%3A//oauth2.example.com/code&\n client_id=client_id [https://accounts.google.com/o/oauth2/v2/auth?scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fdrive.metadata.readonly+https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcalendar.readonly&%3Bstate=state_parameter_passthrough_value&%3Bredirect_uri=https%3A%2F%2Foauth2.example.com%2Fcode&%3Bresponse_type=token&%3Bclient_id=583306224539-atbcaa8ne8g85e8kc006o6vmq99qiid0.apps.googleusercontent.com&hl=ko]'
 ""승인 범위\n기존 범위 https://www.google.com/m8/feeds은 https://www.googleapis.com/auth/contacts 범위의 별칭입니다. 즉, 기존 범위의 기존 OAuth 권한 부여는 https://www.googleapis.com/auth/contacts 범위가 필요한 People API의 모든 엔드포인트에서 작동합니다. 연락처와 연락처 그룹을 읽고 쓰는 기능은 기존 범위에서 작동합니다.\nPeople API에서 '기타 연락처' 또는 디렉터리 데이터에 액세스하려면 새 범위가 필요합니다. 필요한 범위는 위 세부정보를 참고하세요.\n자세한 내용은 요청 승인 [https://developers.google.com/people/v1/how-tos/authorizing?hl=ko]을 참고하세요.\n클라이언트 라이브러리\nApps Script의 경우 고급 사용자 서비스 [https://developers.google.com/apps-script/advanced/people?hl=ko]를 참고하세요.\n지원되는 다른 언어는 클라이언트 라이브러리 설치 [https://developers.google.com/people/v1/libraries?hl=ko]를 참고하세요.\n도움이 되었나요?""
 '신원을 정확하게 나타내야 합니다.\n유효한 앱 이름과 사용자에게 표시할 로고(선택사항)를 입력합니다. 이 브랜드 정보는 애플리케이션의 ID를 정확하게 나타내야 [https://developers.google.com/terms/api-services-user-data-policy?hl=ko#accurately_represent_your_identity_and_intent] 합니다. 앱 브랜딩 정보는 OAuth 에서 구성됩니다.\n프로덕션 앱의 경우 OAuth 동의 화면에 정의된 브랜드 정보는 사용자에게 표시되기 전에 확인되어야 [https://developers.google.com/identity/protocols/oauth2/production-readiness/brand-verification?hl=ko] 합니다. 브랜드 인증을 완료한 앱은 사용자의 앱 액세스 권한 부여 가능성을 높일 수 있습니다. 앱 이름, 홈페이지, 서비스 약관, 개인정보처리방침을 비롯한 기본 애플리케이션 정보는 사용자가 기존 부여를 검토할 때 부여 화면에 표시되거나 조직의 앱 사용을 검토하는 Google Workspace 관리자에게 표시됩니다.\nGoogle은 ID를 허위로 진술하거나 사용자를 속이려는 앱의 Google API 서비스 및 기타 Google 제품 및 서비스에 대한 액세스 권한을 취소하거나 정지할 수 있습니다.\n필요한 범위만 요청\n애플리케이션을 개발하는 동안 API의 기능과 기능에 관해 자세히 알아보기 위해 API에서 제공하는 예시 범위를 사용하여 애플리케이션 내에서 개념 증명을 만들었을 수 있습니다. 이러한 예시 범위는 특정 API에 대해 가능한 모든 작업을 포괄적으로 다루므로 앱 요구사항의 최종 구현보다 더 많은 정보를 요청하는 경우가 많습니다. 예를 들어 예시 범위는 읽기, 쓰기, 삭제 권한을 요청할 수 있지만 애플리케이션에는 읽기 권한만 필요할 수 있습니다. 애플리케이션을 구현하는 데 필요한 중요한 정보로 제한된 관련 권한을 요청 [https://developers.google.com/terms/api-services-user-data-policy?hl=ko#request_relevant_permissions]합니다.'
 '실시간 업데이트 사용량\n활성 연결 및 스냅샷 리스너 측정항목은 실시간 업데이트 [https://firebase.google.com/docs/firestore/query-data/listen?hl=ko] 사용량을 측정합니다.\n사용자가 휴대전화에서 앱을 연다고 가정해 보겠습니다. 그러면 앱이 Cloud Firestore에 연결되고 쿼리 10개를 구독합니다. 이 경우 측정항목은 1개의 활성 연결과 10개의 스냅샷 리스너 기준으로 증가합니다.\n샘플링 레이트\nCloud Firestore 측정항목은 매분 샘플링되지만 업데이트 내용이 대시보드에 표시되려면 최대 4분이 걸릴 수 있습니다.\n\n지연 시간 측정항목\n\n백엔드 지연 시간 측정항목은 일반적인 Google Cloud firestore [https://cloud.google.com//monitoring/api/metrics_gcp_d_h?hl=ko#gcp-firestore] 측정항목을 통해 제공됩니다.'
 '실시간 업데이트 사용량\n활성 연결 및 스냅샷 리스너 측정항목은 실시간 업데이트 [https://cloud.google.com/firestore/native/docs/query-data/listen?hl=ko] 사용량을 측정합니다.\n사용자가 휴대전화에서 앱을 연다고 가정해 보겠습니다. 그러면 앱이 Firestore에 연결되고 쿼리 10개를 구독합니다. 이 경우 측정항목은 활성 연결 1개와 스냅샷 리스너 10개를 기준으로 증가합니다.\n샘플링 레이트\nFirestore 측정항목은 1분 간격으로 샘플링되지만 업데이트 내용이 대시보드에 표시되는 데 최대 4분이 걸릴 수 있습니다.\n\n지연 시간 측정항목\n\n백엔드 지연 시간 측정항목은 일반적인 Google Cloud firestore [https://cloud.google.com//monitoring/api/metrics_gcp_d_h?hl=ko#gcp-firestore] 측정항목을 통해 제공됩니다.'
 ""// Access scopes for two non-Sign-In scopes: Read-only Drive activity and Google Calendar.\nconst scopes = [\n  'https://www.googleapis.com/auth/drive.metadata.readonly',\n  'https://www.googleapis.com/auth/calendar.readonly'\n];\n\n// Generate a secure random state value.\nconst state = crypto.randomBytes(32).toString('hex');\n\n// Store state in the session\nreq.session.state = state;\n\n// Generate a url that asks permissions for the Drive activity and Google Calendar scope\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true,\n  // Include the state parameter to reduce the risk of CSRF attacks.\n  state: state\n});\n\n\n  중요 - refresh_token는 첫 번째 승인에서만 반환됩니다. 자세한 내용은 여기 [https://github.com/googleapis/google-api-nodejs-client/issues/750#issuecomment-304521450]를 참고하세요.""
 ""Only request scopes that you need\nYou must only request the smallest set of scopes that are necessary for providing functionality knowingly chosen by the user. You must request scopes that require the least amount of access to user data necessary to provide that functionality. For example, an app that only uses Gmail APIs to occasionally send emails on a user's behalf shouldn't request the scope that provides full access to the user's email data. Data that you receive from Google APIs must only be used in the way that you represent to your users.""
 ""# Required, scope value\n  # Access scopes for two non-Sign-In scopes: Read-only Drive activity and Google Calendar.\n  scope = ['Google::Apis::DriveV3::AUTH_DRIVE_METADATA_READONLY',\n           'Google::Apis::CalendarV3::AUTH_CALENDAR_READONLY']\n\n  # Required, Authorizers require a storage instance to manage long term persistence of\n  # access and refresh tokens.\n  set :token_store, Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\n\n  # Required, indicate where the API server will redirect the user after the user completes\n  # the authorization flow. The redirect URI is required. The value must exactly\n  # match one of the authorized redirect URIs for the OAuth 2.0 client, which you\n  # configured in the API Console. If this value doesn't match an authorized URI,\n  # you will get a 'redirect_uri_mismatch' error.\n  set :callback_uri, '/oauth2callback'""
 'Your project configuration in the Google Cloud Console Consent Screen page [https://console.developers.google.com/apis/credentials/consent] must match the list of scopes requested by your app. When a change in app functionality or in Google APIs necessitates an update to the scopes that are used, you must revoke [https://developers.google.com/identity/protocols/oauth2/web-server#tokenrevoke] the tokens with the previously-used scopes that are no longer in use at the earliest opportunity and update your project configuration in the Google Cloud Console. Proper configuration is particularly important for scopes that require verification [https://support.google.com/cloud/answer/9110914#sensitive-restricted-scopes]; if an app is no longer approved to use them, Google may revoke tokens that contain these scopes at any time without notice.'
 ""app.use(session({\n    secret: 'your_secure_secret_key', // Replace with a strong secret\n    resave: false,\n    saveUninitialized: false,\n  }));\n\n  // Example on redirecting user to Google's OAuth 2.0 server.\n  app.get('/', async (req, res) => {\n    // Generate a secure random state value.\n    const state = crypto.randomBytes(32).toString('hex');\n    // Store state in the session\n    req.session.state = state;\n\n    // Generate a url that asks permissions for the Drive activity and Google Calendar scope\n    const authorizationUrl = oauth2Client.generateAuthUrl({\n      // 'online' (default) or 'offline' (gets refresh_token)\n      access_type: 'offline',\n      /** Pass in the scopes array defined above.\n        * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n      scope: scopes,\n      // Enable incremental authorization. Recommended as a best practice.\n      include_granted_scopes: true,\n      // Include the state parameter to reduce the risk of CSRF attacks.\n      state: state\n    });\n\n    res.redirect(authorizationUrl);\n  });""
 'Q: Google 피트니스에서 심박수 데이터를 확인하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Google 피트니스에서 내 심박수 데이터를 확인하기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/fitness.heart_rate.read 입니다.'
 'Q: Google 피트니스에서 혈당 정보를 추가하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Google 피트니스에 혈당 정보를 추가하기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/fitness.blood_glucose.write 입니다.'
 'Q: Google 피트니스에서 내 수면 데이터를 확인하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: 내 수면 데이터를 확인하기 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n```\nhttps://www.googleapis.com/auth/fitness.sleep.read\n```'
 'Q: Google 피트니스에서 영양 정보를 확인하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Google 피트니스에서 영양 정보를 확인하기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/fitness.nutrition.read 입니다.'
 'Q: Google 피트니스에서 체온 정보를 추가하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Google 피트니스의 체온 정보에 추가하기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/fitness.body_temperature.write 입니다.'
 'Q: AdMob API에서 AdMob 데이터를 읽기 위한 OAuth 2.0 범위는 무엇인가요?\nA: AdMob 데이터를 읽기 위해서는 다음의 OAuth 2.0 범위를 사용해야 합니다: `https://www.googleapis.com/auth/admob.readonly`.'
 'Q: Cloud Healthcare API를 통해 건강 관리 관련 데이터를 읽기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Cloud Healthcare API를 통해 건강 관리 관련 데이터를 읽기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/cloud-healthcare 입니다.'
 'Q: Google 피트니스에서 수면 데이터를 추가하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Google 피트니스의 수면 데이터에 추가하기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/fitness.sleep.write 입니다.'
 'Q: Cloud Healthcare API를 사용하여 건강 관리 관련 데이터를 읽기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Cloud Healthcare API를 사용하여 건강 관리 관련 데이터를 읽기 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n\n```\nhttps://www.googleapis.com/auth/cloud-healthcare\n```'
 'Q: Google Vault API에서 eDiscovery 데이터를 확인하기 위한 OAuth 2.0 범위는 무엇인가요?\nA: eDiscovery 데이터를 확인하기 위한 OAuth 2.0 범위는 `https://www.googleapis.com/auth/ediscovery.readonly`입니다.'
 'Q: OAuth 2.0 승인 요청을 위한 권한 범위를 설정하는 방법은 무엇인가요?\nA: OAuth 2.0 승인 요청을 위한 권한 범위는 다음과 같이 설정할 수 있습니다. 예를 들어, PHP에서는 다음과 같이 설정합니다.\n\n```php\n$client->addScope([Google\\Service\\Drive::DRIVE_METADATA_READONLY, Google\\Service\\Calendar::CALENDAR_READONLY]);\n```'
 'Q: Cloud Data Fusion API를 사용하여 Google Cloud 데이터를 확인하고 수정하기 위한 OAuth 2.0 범위는 무엇인가요?\nA: Google Cloud 데이터를 확인하고 수정하기 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n```\nhttps://www.googleapis.com/auth/cloud-platform\n```'
 'Q: Cloud Firestore API를 통해 Google 클라우드 데이터 저장소의 데이터를 조회하고 관리하기 위한 OAuth 2.0 범위는 무엇인가요?\nA: Google 클라우드 데이터 저장소의 데이터를 조회하고 관리하기 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n```\nhttps://www.googleapis.com/auth/datastore\n```'
 'Q: AdMob API에서 AdMob 데이터를 보기 위한 OAuth 2.0 범위는 무엇인가요?\nA: AdMob 데이터를 보기 위해서는 다음의 OAuth 2.0 범위를 사용해야 합니다: \n\n```\nhttps://www.googleapis.com/auth/admob.readonly\n```'
 'Q: AdSense Management API에서 애드센스 데이터를 관리하기 위한 OAuth 2.0 범위는 무엇인가요?\nA: 애드센스 데이터를 관리하기 위해서는 다음의 OAuth 2.0 범위를 사용해야 합니다: \n\n```\nhttps://www.googleapis.com/auth/adsense\n```'
 'Q: Blogger API에서 Blogger 계정을 읽기 전용으로 확인하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Blogger 계정을 읽기 전용으로 확인하기 위해 필요한 OAuth 2.0 범위는 `https://www.googleapis.com/auth/blogger.readonly`입니다.'
 'Q: Google Drive 파일을 읽기 전용으로 접근하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Google Drive 파일을 읽기 전용으로 접근하기 위해서는 다음의 OAuth 2.0 범위를 사용해야 합니다: \n```\nhttps://www.googleapis.com/auth/drive.readonly\n```'
 'Q: Chrome에서 내가 읽기 목록에 추가한 페이지의 사본 이동을 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Chrome에서 내가 읽기 목록에 추가한 페이지의 사본 이동을 위해 필요한 OAuth 2.0 범위는 `https://www.googleapis.com/auth/dataportability.chrome.reading_list`입니다.'
 'Q: Google 피트니스에서 생식 건강 정보를 추가하기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: 생식 건강 정보를 추가하기 위해 필요한 OAuth 2.0 범위는 다음과 같습니다: \n```\nhttps://www.googleapis.com/auth/fitness.reproductive_health.write\n```'
 'Q: Dataflow API에서 Google BigQuery의 데이터를 보기 위해 필요한 OAuth 2.0 범위는 무엇인가요?\nA: Dataflow API에서 Google BigQuery의 데이터를 보기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/bigquery입니다.'
 'Q: Google 지도 측정항목 페이지에서 어떤 정보를 확인할 수 있나요?\nA: Google 지도 측정항목 [https://console.cloud.google.com/project/_/google/maps-apis/metrics?hl=ko] 페이지에는 트래픽, 오류, 지연 시간 중앙값 등 세 가지 그래프가 표시됩니다. 그래프의 사용 데이터는 응답 코드 클래스, API, API 메서드, 사용자 인증 정보, 플랫폼, 도메인을 기준으로 그룹화할 수 있습니다.'
 'Q: Ruby에서 Google API 클라이언트를 사용하여 OAuth 2.0 승인 요청의 매개변수를 설정하는 방법은 무엇인가요?\nA: 다음 코드는 승인 요청의 매개변수를 정의하는 Google\\Client() 객체를 만듭니다.\n\n```php\nuse Google\\Client;\n\n$client = new Client();\n\n// Required, call the setAuthConfig function to load authorization credentials from\n// client_secret.json file.\n$client->setAuthConfig(\'client_secret.json\');\n\n// Required, to set the scope value, call the addScope function\n$client->addScope([Google\\Service\\Drive::DRIVE_METADATA_READONLY, Google\\Service\\Calendar::CALENDAR_READONLY]);\n\n// Required, call the setRedirectUri function to specify a valid redirect URI for the\n// provided client_id\n$client->setRedirectUri(\'http://\' . $_SERVER[\'HTTP_HOST\'] . \'/oauth2callback.php\');\n\n// Recommended, offline access will give you both an access and refresh token so that\n// your app can refresh the access token without user interaction.\n$client->setAccessType(\'offline\');\n\n// Recommended, call the setState function. Using a state value can increase your assurance that\n// an incoming connection is the result of an authentication request.\n$client->setState($sample_passthrough_value);\n\n// Optional, if your application knows which user is trying to authenticate, it can use this\n// parameter to provide a hint to the Google Authentication Server.\n$client->setLoginHint(\'hint@example.com\');\n\n// Optional, call the setPrompt function to set ""consent"" will prompt the user for consent\n$client->setPrompt(\'consent\');\n\n// Optional, call the setIncludeGrantedScopes function with true to enable incremental\n// authorization\n$client->setIncludeGrantedScopes(true);\n```'
 ""Q: Node.js에서 점진적 승인을 활성화하기 위해 authorizationUrl을 생성하는 방법은 무엇인가요?\nA: Node.js에서 점진적 승인을 활성화하기 위해 authorizationUrl을 생성하는 방법은 다음과 같습니다:\n\n```javascript\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});\n```""
 ""Q: Node.js에서 OAuth 2.0 인증 흐름을 구현하기 위해 authorizationUrl을 생성하는 방법은 무엇인가요?\nA: Node.js에서 OAuth 2.0 인증 흐름을 구현하기 위해 authorizationUrl을 생성하려면 다음과 같이 코드를 작성합니다:\n\n```javascript\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});\n```""
 ""Q: Node.js에서 Google API에 대한 오프라인 액세스를 요청하기 위해 authorizationUrl을 어떻게 설정하나요?\nA: Node.js에서 Google API에 대한 오프라인 액세스를 요청하기 위해 authorizationUrl을 설정할 때, access_type 매개변수를 'offline'으로 설정해야 합니다. 아래는 예시 코드입니다.\n\n```javascript\nconst authorizationUrl = oauth2Client.generateAuthUrl({\n  // 'online' (default) or 'offline' (gets refresh_token)\n  access_type: 'offline',\n  /** Pass in the scopes array defined above.\n    * Alternatively, if only one scope is needed, you can pass a scope URL as a string */\n  scope: scopes,\n  // Enable incremental authorization. Recommended as a best practice.\n  include_granted_scopes: true\n});\n```""
 ""Q: Python에서 OAuth 2.0 승인 코드를 액세스 토큰으로 교환하는 방법은 무엇인가요?\nA: 콜백 페이지에서 google-auth 라이브러리를 사용하여 승인 서버 응답을 확인합니다. 그런 다음 flow.fetch_token 메서드를 사용하여 해당 응답의 승인 코드를 액세스 토큰으로 교환합니다.\n\n```python\nstate = flask.session['state']\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/drive.metadata.readonly'],\n    state=state)\nflow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\nauthorization_response = flask.request.url\nflow.fetch_token(authorization_response=authorization_response)\n\n# Store the credentials in the session.\n# ACTION ITEM for developers:\n#     Store user's access and refresh tokens in your data store if\n#     incorporating this code into your real app.\ncredentials = flow.credentials\nflask.session['credentials'] = {\n    'token': credentials.token,\n    'refresh_token': credentials.refresh_token,\n    'token_uri': credentials.token_uri,\n    'client_id': credentials.client_id,\n    'client_secret': credentials.client_secret,\n    'granted_scopes': credentials.granted_scopes}\n```""
 ""Q: Python에서 OAuth 2.0 승인 코드를 액세스 토큰으로 교환하는 방법은 무엇인가요?\nA: 콜백 페이지에서 google-auth 라이브러리를 사용하여 승인 서버 응답을 확인합니다. 그런 다음 flow.fetch_token 메서드를 사용하여 해당 응답의 승인 코드를 액세스 토큰으로 교환합니다. 아래는 코드 예시입니다:\n\n```python\nstate = flask.session['state']\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/drive.metadata.readonly'],\n    state=state)\nflow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\nauthorization_response = flask.request.url\nflow.fetch_token(authorization_response=authorization_response)\n\n# Store the credentials in the session.\n# ACTION ITEM for developers:\n#     Store user's access and refresh tokens in your data store if\n#     incorporating this code into your real app.\ncredentials = flow.credentials\nflask.session['credentials'] = {\n    'token': credentials.token,\n    'refresh_token': credentials.refresh_token,\n    'token_uri': credentials.token_uri,\n    'client_id': credentials.client_id,\n    'client_secret': credentials.client_secret,\n    'gr\n```""
 ""Q: JavaScript에서 액세스 토큰을 프로그래매틱 방식으로 취소하는 방법은 무엇인가요?\nA: 프로그래매틱 방식으로 토큰을 취소하려면 애플리케이션이 https://oauth2.googleapis.com/revoke에 요청을 보내고 토큰을 매개변수로 포함해야 합니다. 다음은 JavaScript에서 토큰을 취소하는 방법을 보여주는 코드 스니펫입니다.\n\n```javascript\nfunction revokeAccess(accessToken) {\n  // Google's OAuth 2.0 endpoint for revoking access tokens.\n  var revokeTokenEndpoint = 'https://oauth2.googleapis.com/revoke';\n\n  // Create <form> element to use to POST data to the OAuth 2.0 endpoint.\n  var form = document.createElement('form');\n  form.setAttribute('method', 'post');\n  form.setAttribute('action', revokeTokenEndpoint);\n\n  // Add access token to the form so it is set as value of 'token' parameter.\n  var tokenField = document.createElement('input');\n  tokenField.setAttribute('type', 'hidden');\n  tokenField.setAttribute('name', 'token');\n  tokenField.setAttribute('value', accessToken);\n}\n```""
 ""Q: Node.js에서 OAuth 2.0 인증 흐름을 시작하는 방법은 무엇인가요?\nA: 다음은 Node.js에서 OAuth 2.0 인증 흐름을 시작하는 예시입니다.\n\n```javascript\n// Example on redirecting user to Google's OAuth 2.0 server.\napp.get('/', async (req, res) => {\n  // Generate a secure random state value.\n  const state = crypto.randomBytes(32).toString('hex');\n  // Store state in the session\n  req.session.state = state;\n\n  // Generate a url that asks permissions for the Drive activity and Google Calendar scope\n  const authorizationUrl = oauth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: scopes,\n    include_granted_scopes: true,\n    state: state\n  });\n\n  res.redirect(authorizationUrl);\n});\n```""
 ""Q: JavaScript에서 액세스 토큰을 프로그래매틱 방식으로 취소하는 방법은 무엇인가요?\nA: JavaScript에서 액세스 토큰을 프로그래매틱 방식으로 취소하려면, 애플리케이션이 https://oauth2.googleapis.com/revoke에 요청을 보내고 토큰을 매개변수로 포함해야 합니다. 다음은 이를 수행하는 JavaScript 코드 예시입니다:\n\n```javascript\nfunction revokeAccess(accessToken) {\n  // Google's OAuth 2.0 endpoint for revoking access tokens.\n  var revokeTokenEndpoint = 'https://oauth2.googleapis.com/revoke';\n\n  // Create <form> element to use to POST data to the OAuth 2.0 endpoint.\n  var form = document.createElement('form');\n  form.setAttribute('method', 'post');\n  form.setAttribute('action', revokeTokenEndpoint);\n\n  // Add access token to the form so it is set as value of 'token' parameter.\n  var tokenField = document.createElement('input');\n  tokenField.setAttribute('type', 'hidden');\n  tokenField.setAttribute('name', 'token');\n  tokenField.setAttribute('value', accessToken);\n  form.appendChild(tokenField);\n\n  // Add form to page and submit it to actually revoke the token.\n  document.body.appendChild(form);\n  form.submit();\n}\n```\n이 코드는 액세스 토큰을 취소하기 위해 양식을 생성하고 제출합니다.""
 'Q: Node.js에서 프로그래매틱 방식으로 토큰을 취소하기 위해 어떤 요청을 실행해야 하나요?\nA: 프로그래매틱 방식으로 토큰을 취소하려면 /revoke 엔드포인트에 HTTPS POST 요청을 실행합니다.\n\n```javascript\nconst https = require(\'https\');\n\n// Build the string for the POST request\nlet postData = ""token="" + userCredential.access_token;\n\n// Options for POST request to Google\'s OAuth 2.0 server to revoke a token\nlet postOptions = {\n  host: \'oauth2.googleapis.com\',\n  port: \'443\',\n  path: \'/revoke\',\n  method: \'POST\',\n  headers: {\n    \'Content-Type\': \'application/x-www-form-urlencoded\',\n    \'Content-Length\': Buffer.byteLength(postData)\n  }\n};\n\n// Set up the request\nconst postReq = https.request(postOptions, function (res) {\n  res.setEncoding(\'utf8\');\n  res.on(\'data\', d => {\n    console.log(\'Response: \' + d);\n  });\n});\n\npostReq.on(\'error\', error => {\n  console.log(error)\n});\n\n// Post the request with data\npostReq.write(postData);\npostReq.end();\n```'
 ""Q: Flask에서 사용자가 Google Calendar API에 대한 권한을 부여했는지 확인하는 방법은 무엇인가요?\nA: 사용자가 Google Calendar API에 대한 권한을 부여했는지 확인하려면, 다음과 같은 코드를 사용할 수 있습니다:\n\n```python\n@app.route('/calendar')\ndef calendar_api_request():\n  if 'credentials' not in flask.session:\n    return flask.redirect('authorize')\n\n  features = flask.session['features']\n\n  if features['calendar']:\n    return ('<p>User granted the Google Calendar read permission.</p>')\n  else:\n    return '<p>Calendar feature is not enabled.</p>'\n```""
 'Q: Node.js에서 프로그래매틱 방식으로 토큰을 취소하기 위해 어떤 요청을 실행해야 하나요?\nA: Node.js에서 프로그래매틱 방식으로 토큰을 취소하려면 /revoke 엔드포인트에 HTTPS POST 요청을 실행해야 합니다. 아래는 요청을 실행하는 코드 예시입니다.\n\n```javascript\nconst https = require(\'https\');\n\n// Build the string for the POST request\nlet postData = ""token="" + userCredential.access_token;\n\n// Options for POST request to Google\'s OAuth 2.0 server to revoke a token\nlet postOptions = {\n  host: \'oauth2.googleapis.com\',\n  port: \'443\',\n  path: \'/revoke\',\n  method: \'POST\',\n  headers: {\n    \'Content-Type\': \'application/x-www-form-urlencoded\',\n    \'Content-Length\': Buffer.byteLength(postData)\n  }\n};\n\n// Set up the request\nconst postReq = https.request(postOptions, function (res) {\n  res.setEncoding(\'utf8\');\n  res.on(\'data\', d => {\n    console.log(\'Response: \' + d);\n  });\n});\n\npostReq.on(\'error\', error => {\n  console.log(error)\n});\n\n// Post the request with data\npostReq.write(postData);\npostReq.end();\n```\n\n토큰 매개변수는 액세스 토큰 또는 갱신 토큰일 수 있으며, 취소가 성공적으로 처리되면 응답의 상태 코드는 200입니다.'
 'Q: Flask에서 API 요청을 테스트하는 페이지를 만드는 방법은 무엇인가요?\nA: Flask에서 API 요청을 테스트하는 페이지를 만들려면, 다음과 같은 코드를 사용할 수 있습니다:\n\n```python\ndef print_index_table():\n  return (\'<table>\' +\n          \'<tr><td><a href=""/test"">Test an API request</a></td>\' +\n          \'<td>Submit an API request and see a formatted JSON response. \' +\n          \'    Go through the authorization flow if there are no stored \' +\n          \'    credentials for the user.</td></tr>\' +\n          \'<tr><td><a href=""/authorize"">Test the auth flow directly</a></td>\' +\n          \'<td>Go directly to the authorization flow. If there are stored \' +\n          \'    credentials, you still might not be prompted to reauthorize \' +\n          \'    the application.</td></tr>\' +\n          \'<tr><td><a href=""/revoke"">Revoke current credentials</a></td>\' +\n          \'<td>Revoke the access token associated with the current user \' +\n          \'    session. After revoking credentials, if you go to the test \' +\n          \'    page, you should see an <code>invalid_grant</code> error.\' +\n          \'</td></tr>\' +\n          \'<tr><td><a href=""/clear"">Clear Flask session credentials</a></td>\' +\n          \'<td>Clear the access token currently stored in the user session. \' +\n          \'    After clearing the token, if you <a href=""/test"">test the \' +\n          \'    API request</a> again, you should go back to the auth flow.\' +\n          \'</td></tr></table>\')\n```'
 ""Q: JavaScript에서 액세스 토큰이 유효한 범위를 확인하는 방법은 무엇인가요?\nA: 다음 코드 스니펫은 액세스 토큰이 유효한 범위를 특정 쿼리에 사용하려는 범위와 비교하는 방법을 보여줍니다. 액세스 토큰이 해당 범위를 포함하지 않으면 OAuth 2.0 흐름이 시작됩니다.\n\n```javascript\nvar SCOPE = 'https://www.googleapis.com/auth/drive.metadata.readonly';\nvar params = JSON.parse(localStorage.getItem('oauth2-test-params'));\n\nvar current_scope_granted = false;\nif (params.hasOwnProperty('scope')) {\n  var scopes = params['scope'].split(' ');\n  for (var s = 0; s < scopes.length; s++) {\n    if (SCOPE == scopes[s]) {\n      current_scope_granted = true;\n    }\n  }\n}\n\nif (!current_scope_granted) {\n  oauth2SignIn(); // This function is defined elsewhere in this document.\n} else {\n  // Since you already have access, you can proceed with the API request.\n}\n```""
 ""Q: JavaScript에서 OAuth 2.0 서버에 액세스 토큰을 요청하기 위한 폼을 어떻게 생성하나요?\nA: 다음은 JavaScript에서 OAuth 2.0 서버에 액세스 토큰을 요청하기 위한 폼을 생성하는 코드입니다.\n\n```javascript\nfunction oauth2SignIn() {\n    // create random state value and store in local storage\n    var state = generateCryptoRandomState();\n    localStorage.setItem('state', state);\n\n    // Google's OAuth 2.0 endpoint for requesting an access token\n    var oauth2Endpoint = 'https://accounts.google.com/o/oauth2/v2/auth';\n\n    // Create element to open OAuth 2.0 endpoint in new window.\n    var form = document.createElement('form');\n    form.setAttribute('method', 'GET'); // Send as a GET request.\n    form.setAttribute('action', oauth2Endpoint);\n\n    // Parameters to pass to OAuth 2.0 endpoint.\n    var params = {'client_id': YOUR_CLIENT_ID,\n                  'redirect_uri': YOUR_REDIRECT_URI,\n                  'scope': 'https://www.googleapis.com/auth/drive.metadata.readonly https://www.googleapis.com/auth/calendar.readonly',\n                  'state': state,\n                  'include_granted_scopes': 'true',\n                  'response_type': 'token'};\n\n    // Add form parameters as hidden input values.\n    for (var p in params) {\n      var input = document.createElement('input');\n      input.setAttribute('type', 'hidden');\n      input.setAttribute('name', p);\n      input.setAttribute('value', params[p]);\n      form.appendChild(input);\n    }\n\n    // Add form to page and submit it to open the OAuth 2.0 endpoint.\n    document.body.appendChild(form);\n    form.submit();\n}\n```""
 ""Q: JavaScript에서 OAuth 2.0 흐름을 시작하기 위해 어떤 요청을 생성해야 하나요?\nA: OAuth 2.0 흐름을 시작하기 위해 다음과 같은 요청을 생성해야 합니다. 이 요청은 Google의 OAuth 2.0 엔드포인트에 대한 GET 요청입니다. 아래는 해당 코드입니다.\n```javascript\nfunction oauth2SignIn() {\n    // create random state value and store in local storage\n    var state = generateCryptoRandomState();\n    localStorage.setItem('state', state);\n\n    // Google's OAuth 2.0 endpoint for requesting an access token\n    var oauth2Endpoint = 'https://accounts.google.com/o/oauth2/v2/auth';\n\n    // Create element to open OAuth 2.0 endpoint in new window.\n    var form = document.createElement('form');\n    form.setAttribute('method', 'GET'); // Send as a GET request.\n    form.setAttribute('action', oauth2Endpoint);\n\n    // Parameters to pass to OAuth 2.0 endpoint.\n    var params = {'client_id': YOUR_CLIENT_ID,\n                  'redirect_uri': YOUR_REDIRECT_URI,\n                  'scope': 'https://www.googleapis.com/auth/drive.metadata.readonly https://www.googleapis.com/auth/calendar.readonly',\n                  'state': state,\n                  'include_granted_scopes': 'true',\n                  'response_type': 'token'};\n\n    // Add form parameters as hidden input values.\n    for (var p in params) {\n      var input = document.createElement('input');\n      input.setAttribute('type', 'hidden');\n      input.setAttribute('name', p);\n      input.setAttribute('value', params[p]);\n      form.appendChild(input);\n    }\n\n    // Add form to page and submit it to open the OAuth 2.0 endpoint.\n    document.body.appendChild(form);\n    form.submit();\n}\n```""
 ""Q: Python에서 오프라인 액세스를 요청할 때 authorization_url을 어떻게 설정하나요?\nA: Python에서 오프라인 액세스를 요청할 때 authorization_url을 설정하려면 다음과 같이 코드를 작성합니다:\n\n```python\nauthorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')\n```""
 ""Q: Python에서 점진적 승인을 구현하기 위해 authorization_url을 생성하는 방법은 무엇인가요?\nA: Python에서 점진적 승인을 구현하기 위해 authorization_url을 생성하는 방법은 다음과 같습니다:\n\n```python\nauthorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')\n```""
 ""Q: Python에서 Google API에 대한 오프라인 액세스를 요청하기 위해 authorization_url을 어떻게 설정하나요?\nA: Python에서 Google API에 대한 오프라인 액세스를 요청하기 위해 authorization_url을 설정할 때, access_type 매개변수를 'offline'으로 설정해야 합니다. 아래는 예시 코드입니다.\n\n```python\nauthorization_url, state = flow.authorization_url(\n    # Enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true')\n```""
 ""Q: Node.js에서 Google API 클라이언트를 사용하여 OAuth 2.0 승인 요청의 매개변수를 설정하는 방법은 무엇인가요?\nA: Node.js에서 Google API 클라이언트를 사용하여 OAuth 2.0 승인 요청의 매개변수를 설정하는 방법은 다음과 같습니다.\n\n```javascript\nconst { google } = require('googleapis');\nconst OAuth2 = google.auth.OAuth2;\n\nconst oauth2Client = new OAuth2(\n  YOUR_CLIENT_ID,\n  YOUR_CLIENT_SECRET,\n  YOUR_REDIRECT_URL\n);\n\n// Required: Set the scopes\nconst scopes = [\n  'https://www.googleapis.com/auth/drive.metadata.readonly',\n  'https://www.googleapis.com/auth/calendar.readonly'\n];\n\n// Generate the URL for consent\nconst authUrl = oauth2Client.generateAuthUrl({\n  access_type: 'offline',\n  scope: scopes,\n});\n```""]",Google 피트니스에서 심박수 데이터를 읽기 위한 OAuth 2.0 범위는 `https://www.googleapis.com/auth/fitness.heart_rate.read`입니다.,Google 피트니스에서 심박수 데이터를 확인하기 위해 필요한 OAuth 2.0 범위는 https://www.googleapis.com/auth/fitness.heart_rate.read 입니다.
projets.databeses.gte 메서드 쓸때 HTTP 리퀘스트 포맷이 뭐에요?,"['Source URL: https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.collectionGroups.fields/get?hl=ko\nTitle: Method: projects.databases.collectionGroups.fields.get\n\nSend feedback\n\nMethod: projects.databases.collectionGroups.fields.get\n\nStay organized with collections\n\nSave and categorize content based on your preferences.\n\nGets the metadata and configuration for a Field.\n\nHTTP request\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/collectionGroups/*/fields/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Required. A name of the form projects/{projectId}/databases/{databaseId}/collectionGroups/{collectionId}/fields/{field_id} |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body contains an instance of Field [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.collectionGroups.fields#Field].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:'
 'Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service.\n\nHTTP request\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/operations/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string The name of the operation resource. |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body contains an instance of Operation [https://firebase.google.com/docs/firestore/reference/rest/Shared.Types/Operation].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:\n\nhttps://www.googleapis.com/auth/datastore\nhttps://www.googleapis.com/auth/cloud-platform\nFor more information, see the OAuth 2.0 Overview [https://developers.google.com/identity/protocols/OAuth2].\n\nSend feedback'
 'HTTP request\nPOST https://firestore.googleapis.com/v1/{parent=projects/*/databases/*/documents}:runAggregationQueryThe URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| parent | string Required. The parent resource name. In the format: projects/{projectId}/databases/{databaseId}/documents or projects/{projectId}/databases/{databaseId}/documents/{document_path}. For example: projects/my-project/databases/my-database/documents or projects/my-project/databases/my-database/documents/chatrooms/my-chatroom |\n\nRequest body\nThe request body contains data with the following structure:\n\n| JSON representation |\n| --- |\n| {   ""explainOptions"": {     object (ExplainOptions)   },    // Union field query_type can be only one of the following:   ""structuredAggregationQuery"": {     object (StructuredAggregationQuery)   }   // End of list of possible types for union field query_type.    // Union field consistency_selector can be only one of the following:   ""transaction"": string,   ""newTransaction"": {     object (TransactionOptions)   },   ""readTime"": string   // End of list of possible types for union field consistency_selector. } |'
 'Gets multiple documents.Documents returned by this method are not guaranteed to be returned in the same order that they were requested.\n\nHTTP request\nPOST https://firestore.googleapis.com/v1beta1/{database=projects/*/databases/*}/documents:batchGetThe URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| database | string Required. The database name. In the format: projects/{projectId}/databases/{databaseId}. |\n\nRequest body\nThe request body contains data with the following structure:\n\n| JSON representation |\n| --- |\n| {   ""documents"": [     string   ],   ""mask"": {     object (DocumentMask)   },    // Union field consistency_selector can be only one of the following:   ""transaction"": string,   ""newTransaction"": {     object (TransactionOptions)   },   ""readTime"": string   // End of list of possible types for union field consistency_selector. } |'
 'HTTP request\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Required. A name of the form projects/{projectId}/databases/{databaseId} |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body contains an instance of Database [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases#Database].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:\n\nhttps://www.googleapis.com/auth/datastore\nhttps://www.googleapis.com/auth/cloud-platform\nFor more information, see the OAuth 2.0 Overview [https://developers.google.com/identity/protocols/OAuth2].\n\nSend feedback'
 '서비스 런타임 측정항목\n\nserviceruntime [https://cloud.google.com/monitoring/api/metrics_gcp_p_z?hl=ko#gcp-serviceruntime] 측정항목은 프로젝트 트래픽에 대한 대략적인 개요를 제공합니다. 이러한 측정항목은 대부분의 Google Cloud API에서 사용할 수 있습니다. consumed_api [https://cloud.google.com/monitoring/api/resources?hl=ko#tag_consumed_api] 모니터링 리소스 유형에는 이러한 일반 측정항목이 포함됩니다. 이러한 측정항목은 30분마다 샘플링되므로 데이터가 평활화됩니다.\n\nserviceruntime 측정항목의 중요한 리소스 라벨은 method입니다. 이 라벨은 호출된 기본 RPC 메서드를 나타냅니다. 호출하는 SDK 메서드의 이름은 기본 RPC 메서드와 동일하지 않을 수 있습니다. SDK는 상위 수준 API 추상화를 제공하기 때문입니다. 하지만 애플리케이션이 Firestore와 상호작용하는 방식을 이해하려면 RPC 메서드 이름을 기반으로 한 측정항목을 이해하는 것이 중요합니다.\n\n특정 SDK 메서드의 기본 RPC 메서드를 알아야 하는 경우 API 문서 [https://cloud.google.com/firestore/native/docs/reference/rpc/google.firestore.v1?hl=ko]를 참고하세요.\n\n다음 서비스 런타임 측정항목을 사용하여 데이터베이스를 모니터링합니다.\n\napi/request_count\n\n이 측정항목은 프로토콜(http, gRPC 등의 요청 프로토콜), 응답 코드 (HTTP 응답 코드 [https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto]), response_code_class (2xx, 4xx 등 응답 코드 클래스) 전반에서 완료된 요청 수 및 grpc_status_code (숫자 gRPC 응답 코드 [https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto])를 제공합니다. 이 측정항목을 사용하여 전체 API 요청을 관찰하고 오류율을 계산합니다.'
 'Source URL: https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.operations/get?hl=ko\nTitle: Method: projects.databases.operations.get\nbookmark_border\n\nSend feedback\n\nMethod: projects.databases.operations.get\n\nbookmark_borderbookmark\n\nStay organized with collections\n\nSave and categorize content based on your preferences.\n\n이 페이지의 내용HTTP request [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.operations/get#http-request]Path parameters [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.operations/get#path-parameters]Request body [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.operations/get#request-body]Response body [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.operations/get#response-body]Authorization scopes [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.operations/get#authorization-scopes]사용해 보기 [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.operations/get#try-it]'
 'Source URL: https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.operations/get?hl=ko\nTitle: Method: projects.databases.operations.get\nbookmark_border\n\nSend feedback\n\nMethod: projects.databases.operations.get\n\nbookmark_borderbookmark\n\nStay organized with collections\n\nSave and categorize content based on your preferences.\n\n이 페이지의 내용HTTP request [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.operations/get#http-request]Path parameters [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.operations/get#path-parameters]Request body [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.operations/get#request-body]Response body [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.operations/get#response-body]Authorization scopes [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.operations/get#authorization-scopes]사용해 보기 [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.operations/get#try-it]'
 'Source URL: https://cloud.google.com/firestore/docs/langchain?hl=ko\nTitle: LangChain을 사용하여 LLM 기반 애플리케이션 빌드\nbookmark_border\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\n\n의견 보내기\n\n이 페이지의 내용LangChain이란 무엇인가요? [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#what-is-langchain-mysql]Firestore용 LangChain 구성요소 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#langchain-components]Firestore용 벡터 저장소 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#vector-store]벡터 저장소 절차 가이드 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#vector_store_procedure_guide]Firestore용 문서 로더 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#document-loader]문서 로더 절차 가이드 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#document_loader_procedure_guide]Firestore의 채팅 메시지 기록 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#chat-message-history]채팅 메시지 기록 절차 가이드 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#chat_message_history_procedure_guide]\n\nLangChain을 사용하여 LLM 기반 애플리케이션 빌드\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n프리뷰'
 ""서비스 런타임 측정항목\n\nserviceruntime [https://cloud.google.com/monitoring/api/metrics_gcp_p_z?hl=ko#gcp-serviceruntime] 측정항목은 프로젝트 트래픽에 대한 개략적인 개요를 제공합니다. 이러한 측정항목은 대부분의 Google Cloud API에서 사용할 수 있습니다. consumed_api [https://cloud.google.com/monitoring/api/resources?hl=ko#tag_consumed_api] 모니터링 리소스 유형에는 이러한 일반 측정항목이 포함됩니다. 이러한 측정항목은 30분마다 샘플링되므로 데이터가 평활화됩니다.\n\nserviceruntime 측정항목의 중요한 리소스 라벨은 method입니다. 이 라벨은 호출된 기본 RPC 메서드를 나타냅니다. 호출하는 SDK 메서드의 이름은 기본 RPC 메서드와 동일하지 않을 수 있습니다. SDK는 상위 수준 API 추상화를 제공하기 때문입니다. 하지만 애플리케이션이 Cloud Firestore와 상호작용하는 방식을 이해하려면 RPC 메서드 이름을 기반으로 한 측정항목을 이해하는 것이 중요합니다.\n\n특정 SDK 메서드의 기본 RPC 메서드를 알아야 하는 경우 API 참고 리소스 [https://cloud.google.com/firestore/docs/reference/rpc/google.firestore.v1?hl=ko]를 참고하세요.\n\napi/request_latencies\n\napi/request_latencies 측정항목은 완료된 모든 요청의 지연 시간 분포를 제공합니다.\n\nCloud Firestore는 Cloud Firestore 서비스 구성요소의 측정항목을 기록합니다. 지연 시간 측정항목에는 Cloud Firestore가 요청을 받는 시점부터 스토리지 레이어와의 상호작용을 포함하여 Cloud Firestore가 응답 전송을 완료하는 시점까지의 시간이 포함됩니다. 따라서 클라이언트와 Cloud Firestore 서비스 간의 왕복 지연 시간(rtt)은 이러한 측정항목에 포함되지 않습니다.\n\n문서 작업 측정항목\n\nCloud Firestore는 읽기, 쓰기, 삭제 수를 제공합니다. 쓰기 측정항목은 'CREATE' 작업과 'UPDATE' 작업 간의 분류를 제공합니다. 이러한 측정항목은 CRUD 작업과 일치합니다.""
 'Deletes a backup.\n\nHTTP request\nDELETE https://firestore.googleapis.com/v1/{name=projects/*/locations/*/backups/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Required. Name of the backup to delete. format is projects/{project}/locations/{location}/backups/{backup}. |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body is an empty JSON object.\n\nAuthorization scopes\nRequires one of the following OAuth scopes:\n\nhttps://www.googleapis.com/auth/datastore\nhttps://www.googleapis.com/auth/cloud-platform\nFor more information, see the Authentication Overview [https://cloud.google.com/docs/authentication#authorization-gcp].\n\nSend feedback'
 'Deletes a backup.\n\nHTTP request\nDELETE https://firestore.googleapis.com/v1/{name=projects/*/locations/*/backups/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Required. Name of the backup to delete. format is projects/{project}/locations/{location}/backups/{backup}. |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body is an empty JSON object.\n\nAuthorization scopes\nRequires one of the following OAuth scopes:\n\nhttps://www.googleapis.com/auth/datastore\nhttps://www.googleapis.com/auth/cloud-platform\nFor more information, see the OAuth 2.0 Overview [https://developers.google.com/identity/protocols/OAuth2].\n\nSend feedback'
 'BackupSource\n\nInformation about a backup that was used to restore a database.\n\n| Fields |\n| --- |\n| backup | string The resource name of the backup that was used to restore this database. Format: projects/{project}/locations/{location}/backups/{backup}. |\n\nDeleteBackupRequest\n\nThe request for FirestoreAdmin.DeleteBackup [https://cloud.google.com/firestore/docs/reference/rpc/google.firestore.admin.v1#google.firestore.admin.v1.FirestoreAdmin.DeleteBackup].\n\n| Fields |\n| --- |\n| name | string Required. Name of the backup to delete. format is projects/{project}/locations/{location}/backups/{backup}. |\n\nDeleteBackupScheduleRequest\n\nThe request for [FirestoreAdmin.DeleteBackupSchedules][].\n\n| Fields |\n| --- |\n| name | string Required. The name of the backup schedule. Format projects/{project}/databases/{database}/backupSchedules/{backup_schedule} |\n\nDeleteDatabaseMetadata\nThis type has no fields.\n\nMetadata related to the delete database operation.\n\nDeleteDatabaseRequest\n\nThe request for FirestoreAdmin.DeleteDatabase [https://cloud.google.com/firestore/docs/reference/rpc/google.firestore.admin.v1#google.firestore.admin.v1.FirestoreAdmin.DeleteDatabase].'
 'Q: projects.databases.operations.get 메서드의 HTTP 요청 형식은 어떻게 되나요?\nA: HTTP 요청 형식은 다음과 같습니다:\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/operations/*}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: projects.databases.operations.get 메서드의 요청 본문은 어떻게 구성되나요?\nA: projects.databases.operations.get 메서드의 요청 본문은 비어 있어야 합니다.'
 'Q: batchGet 메서드의 HTTP 요청 형식은 어떻게 되나요?\nA: batchGet 메서드의 HTTP 요청 형식은 다음과 같습니다:\n```\nPOST https://firestore.googleapis.com/v1/{database=projects/*/databases/*}/documents:batchGet\n```'
 'Q: operations.get 메서드의 HTTP 요청 형식은 어떻게 되나요?\nA: operations.get 메서드는 다음과 같은 HTTP 요청 형식을 사용합니다:\n```\nGET https://www.googleapis.com/drive/v3/operations/{name}\n```\n여기서 {name}은 작업 리소스의 이름입니다.'
 'Q: GET 요청을 통해 projects.databases.operations.get 메서드를 호출할 때 필요한 URL 형식은 무엇인가요?\nA: GET 요청을 통해 호출할 때 URL 형식은 다음과 같습니다: \n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/operations/*}\n```'
 'Q: beginTransaction 메서드의 HTTP 요청 URL에서 사용하는 경로 매개변수는 무엇인가요?\nA: beginTransaction 메서드의 HTTP 요청 URL에서 사용하는 경로 매개변수는 `database`입니다. 이 매개변수는 필수이며, 형식은 `projects/{projectId}/databases/{databaseId}`입니다.'
 'Q: batchGet 메서드의 HTTP 요청 형식은 어떻게 되나요?\nA: batchGet 메서드의 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1/{database=projects/*/databases/*}/documents:batchGet\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: projects.databases.operations.delete 메서드의 HTTP 요청 형식은 어떻게 되나요?\nA: HTTP 요청 형식은 다음과 같습니다:\nDELETE https://firestore.googleapis.com/v1/{name=projects/*/databases/*/operations/*}\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: projects.databases.operations.get 메서드의 요청 본문은 어떻게 구성되나요?\nA: 요청 본문은 비어 있어야 합니다.'
 'Q: backupSchedule을 업데이트하기 위한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다.\n\n```\nPATCH https://firestore.googleapis.com/v1/{backupSchedule.name=projects/*/databases/*/backupSchedules/*}\n```\nURL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: BatchGet 요청을 보낼 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: BatchGet 요청을 보낼 때 필요한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1beta1/{database=projects/*/databases/*}/documents:batchGet\n```'
 'Q: Aggregation 쿼리를 실행하기 위해 필요한 HTTP 요청 형식은 무엇인가요?\nA: Aggregation 쿼리를 실행하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1beta1/{parent=projects/*/databases/*/documents}:runAggregationQuery\n```\n여기서 `parent`는 필수 파라미터로, 형식은 `projects/{projectId}/databases/{databaseId}/documents`입니다.'
 'Q: projects.locations.backups.get 메서드를 사용하여 백업 정보를 가져오는 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/locations/*/backups/*}\n```\nURL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: 문서를 삭제하기 위한 HTTP 요청 형식은 무엇인가요?\nA: 문서를 삭제하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nDELETE https://firestore.googleapis.com/v1/{name=projects/*/databases/*/documents/*/**}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: projects.locations.get 메서드를 사용하여 위치 정보를 가져오는 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/locations/*}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Google Cloud Firestore에서 문서를 내보내기 위해 필요한 HTTP 요청 형식은 무엇인가요?\nA: 문서를 내보내기 위해 필요한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1beta1/{name=projects/*/databases/*}:exportDocuments\n```\n여기서 `{name}`은 내보낼 데이터베이스를 나타내며, 형식은 `projects/{projectId}/databases/{databaseId}`입니다.'
 'Q: Google Cloud Firestore에서 문서를 내보내기 위해 필요한 HTTP 요청 형식은 무엇인가요?\nA: 문서를 내보내기 위해 필요한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1beta2/{name=projects/*/databases/*}:exportDocuments\n```\n여기서 `{name}`은 내보낼 데이터베이스를 나타내며, 형식은 `projects/{projectId}/databases/{databaseId}`입니다.'
 'Q: PATCH 메서드를 사용하여 Firestore 문서를 업데이트할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nPATCH https://firestore.googleapis.com/v1beta1/{document.name=projects/*/databases/*/documents/*/**}\n```\nURL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Google Cloud Firestore에 문서를 가져오기 위해 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1/{name=projects/*/databases/*}:importDocuments\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Firestore에서 documents.list 메서드를 사용하여 문서를 나열할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{parent=projects/*/databases/*/documents}/{collectionId}\n```\nURL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Firestore에서 문서를 삭제하기 위한 HTTP 요청 형식은 무엇인가요?\nA: 문서를 삭제하기 위한 HTTP 요청 형식은 다음과 같습니다.\n\n```\nDELETE https://firestore.googleapis.com/v1/{name=projects/*/databases/*/documents/*/**}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Firestore에서 데이터베이스를 삭제하기 위한 HTTP 요청 형식은 무엇인가요?\nA: 데이터베이스를 삭제하기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nDELETE https://firestore.googleapis.com/v1/{name=projects/*/databases/*}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: projects.databases.operations.get 메서드를 사용하여 어떤 정보를 얻을 수 있나요?\nA: projects.databases.operations.get 메서드는 장기 실행 작업의 최신 상태를 가져옵니다. 클라이언트는 API 서비스에서 권장하는 간격으로 작업 결과를 폴링(poll)하는 데 이 메서드를 사용할 수 있습니다.'
 'Q: DeleteDocumentRequest를 사용하여 Firestore에서 문서를 삭제할 때 필요한 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to delete. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| current_document | Precondition An optional precondition on the document. The request will fail if this is set and not met by the target document. |'
 'Q: FirestoreAdmin API에서 DeleteBackupRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. Name of the backup to delete. format is projects/{project}/locations/{location}/backups/{backup}. |'
 'Q: FirestoreAdmin API에서 CloneDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}. |'
 'Q: Firestore에서 데이터베이스를 복제하기 위한 CloneDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}. |'
 'Q: Firestore에서 데이터베이스 복제 요청의 CloneDatabaseRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}.'
 'Q: PartitionQueryResponse를 통해 Firestore에서 파티션 결과를 어떻게 확인하나요?\nA: | Fields |\n| --- |\n| partitions[] | Cursor Partition results. Each partition is a split point that can be used by RunQuery as a starting or end point for the query results. The RunQuery requests must be made with the same query supplied to this PartitionQuery request. The partition cursors will be ordered according to same ordering as the results of the query supplied to PartitionQuery. For example, if a PartitionQuery request returns partition cursors A and B, running the following three queries will return the entire result set of the original query: query, end_at A query, start_at A, end_at B query, start_at B An empty result may indicate that the query has too few results to be partitioned, or that the query is not yet supported for partitioning. |\n| next_page_token | string A page token that may be used to request an additional set of results, up to the number specified by partition_count in the PartitionQuery request. If blank, there are no more results. |'
 'Q: 문서를 삭제할 때 사용할 수 있는 쿼리 매개변수는 무엇인가요?\nA: | Parameters |\n| --- |\n| currentDocument | object (Precondition) An optional precondition on the document. The request will fail if this is set and not met by the target document. |'
 'Q: Firestore에서 PartitionQueryResponse의 응답으로 반환되는 필드에는 어떤 것들이 있나요?\nA: | Fields |\n| --- |\n| partitions[] | Cursor Partition results. Each partition is a split point that can be used by RunQuery as a starting or end point for the query results. |\n| next_page_token | string A page token that may be used to request an additional set of results, up to the number specified by partition_count in the PartitionQuery request.'
 'Q: Target를 설정할 때 필수로 포함해야 하는 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| target_id | int32 The target ID that identifies the target on the stream. Must be a positive number and non-zero. If target_id is 0 (or unspecified), the server will assign an ID for this target and return that in a TargetChange::ADD event. Once a target with target_id=0 is added, all subsequent targets must also have target_id=0. If an AddTarget request with target_id != 0 is sent to the server after a target with target_id=0 is added, the server will immediately send a response with a TargetChange::Remove event. Note that if the client sends multiple AddTarget requests without an ID, the order of IDs returned in TargetChange.target_ids are undefined. Therefore, clients should provide a target ID instead of relying on the server to assign one. If target_id is non-zero, there must not be an existing active target on this stream with the same ID. |\n| once | bool If the target should be removed once it is current and consistent. |\n| expected_count | Int32Value The number of documents that last matched the query at the resume token or read time. This value is only relevant when a resume_type is provided. This value being present and greater than zero signals that the client wants ExistenceFilter.unchanged_names to be included in the response. |'
 'Q: Firestore에서 DeleteDocumentRequest를 사용하여 문서를 삭제할 때, 어떤 필드를 제공해야 하나요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to delete. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| current_document | Precondition An optional precondition on the document. The request will fail if this is set and not met by the target document. |'
 'Q: DeleteDocumentRequest를 사용하여 Firestore에서 문서를 삭제할 때, 요청에 포함해야 하는 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to delete. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| current_document | Precondition An optional precondition on the document. The request will fail if this is set and not met by the target document.'
 'Q: DeleteDocumentRequest를 사용하여 Firestore에서 문서를 삭제할 때 어떤 필드를 설정해야 하나요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to delete. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| current_document | Precondition An optional precondition on the document. The request will fail if this is set and not met by the target document. |'
 'Q: DeleteDocumentRequest를 사용하여 Firestore에서 문서를 삭제할 때, 어떤 필드를 제공해야 하나요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to delete. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| current_document | Precondition An optional precondition on the document. The request will fail if this is set and not met by the target document. |'
 'Q: DeleteDocumentRequest를 사용하여 Firestore에서 문서를 삭제할 때, 요청에 포함해야 하는 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to delete. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| current_document | Precondition An optional precondition on the document. The request will fail if this is set and not met by the target document. |'
 'Q: Index의 state 필드는 어떤 상태를 나타내나요?\nA: | Enums |\n| --- |\n| STATE_UNSPECIFIED | The state is unspecified. |\n| CREATING | The index is being created. There is an active long-running operation for the index. The index is updated when writing a document. Some index data may exist. |\n| READY | The index is ready to be used. The index is updated when writing a document. The index is fully populated from all stored documents it applies to. |\n| NEEDS_REPAIR | The index was being created, but something went wrong. There is no active long-running operation for the index, and the most recently finished long-running operation failed. The index is not updated when writing a document. Some index data may exist. Use the google.longrunning.Operations API to determine why the operation that last attempted to create this index failed, then re-create the index.'
 'Q: FirestoreAdmin API에서 인덱스의 상태(State) 값은 무엇이 있나요?\nA: | Enums |\n| --- |\n| STATE_UNSPECIFIED | The state is unspecified. |\n| CREATING | The index is being created. There is an active long-running operation for the index. The index is updated when writing a document. Some index data may exist. |\n| READY | The index is ready to be used. The index is updated when writing a document. The index is fully populated from all stored documents it applies to. |\n| NEEDS_REPAIR | The index was being created, but something went wrong. There is no active long-running operation for the index, and the most recently finished long-running operation failed. The index is not updated when writing a document. Some index data may exist. Use the google.longrunning.Operations API to determine why the operation that last attempted to create this index failed, then re-create the index.'
 'Q: FirestoreAdmin API에서 인덱스의 상태(State) 값은 무엇이 있나요?\nA: | Enums |\n| --- |\n| STATE_UNSPECIFIED | The state is unspecified. |\n| CREATING | The index is being created. There is an active long-running operation for the index. The index is updated when writing a document. Some index data may exist. |\n| READY | The index is ready to be used. The index is updated when writing a document. The index is fully populated from all stored documents it applies to. |\n| NEEDS_REPAIR | The index was being created, but something went wrong. There is no active long-running operation for the index, and the most recently finished long-running operation failed. The index is not updated when writing a document. Some index data may exist. Use the google.longrunning.Operations API to determine why the operation that last attempted to create this index failed, then re-create the index. |'
 'Q: Firestore에서 PartitionQueryResponse를 통해 어떤 정보를 받을 수 있나요?\nA: | Fields |\n| --- |\n| partitions[] | Cursor Partition results. Each partition is a split point that can be used by RunQuery as a starting or end point for the query results. |\n| next_page_token | string A page token that may be used to request an additional set of results, up to the number specified by partition_count in the PartitionQuery request. If blank, there are no more results. |'
 'Q: Firestore 데이터베이스를 생성하기 위한 HTTP 요청은 어떻게 구성하나요?\nA: Firestore 데이터베이스를 생성하기 위한 HTTP 요청은 다음과 같이 구성됩니다:\n\n```\nPOST https://firestore.googleapis.com/v1/{parent=projects/*}/databases\n```\n여기서 `{parent=projects/*}`는 프로젝트 ID를 포함한 부모 이름을 나타냅니다.'
 'Q: projects.databases.list 메서드를 사용하여 데이터베이스 목록을 가져오는 HTTP 요청은 어떻게 구성하나요?\nA: 다음과 같이 GET 요청을 구성합니다:\n\n```\nGET https://firestore.googleapis.com/v1/{parent=projects/*}/databases\n```\n여기서 `{parent=projects/*}`는 프로젝트 ID를 포함해야 합니다.'
 'Q: GET 요청을 통해 projects.databases.operations.get 메서드를 호출할 때 필요한 URL 형식은 무엇인가요?\nA: GET 요청을 통해 호출할 때 URL 형식은 다음과 같습니다: \n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/operations/*}\n```'
 'Q: Firestore 데이터베이스에 대한 정보를 가져오려면 어떤 HTTP 요청을 사용해야 하나요?\nA: Firestore 데이터베이스에 대한 정보를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다.\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*}\n```\n여기서 `{name}`은 `projects/{projectId}/databases/{databaseId}` 형식의 문자열입니다.'
 'Q: Firestore 데이터베이스에 대한 정보를 가져오려면 어떤 HTTP 요청을 사용해야 하나요?\nA: Firestore 데이터베이스에 대한 정보를 가져오기 위해서는 다음과 같은 HTTP GET 요청을 사용해야 합니다:\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*}\n```\n여기서 `{name}`은 `projects/{projectId}/databases/{databaseId}` 형식의 문자열입니다.'
 'Q: projects.databases.collectionGroups.indexes.get 메서드를 사용하여 복합 인덱스를 가져오는 방법은 무엇인가요?\nA: 복합 인덱스를 가져오려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/collectionGroups/*/indexes/*}\n```\n여기서 {name}은 `projects/{projectId}/databases/{databaseId}/collectionGroups/{collectionId}/indexes/{index_id}` 형식의 문자열입니다.'
 'Q: Firestore에서 documents.list 메서드를 사용하여 문서를 나열할 때, 요청 URL의 형식은 어떻게 되나요?\nA: 요청 URL의 형식은 다음과 같습니다: \nGET https://firestore.googleapis.com/v1beta1/{parent=projects/*/databases/*/documents/*/**}/{collectionId} \n여기서 {parent}는 프로젝트 ID와 데이터베이스 ID를 포함한 부모 리소스 이름입니다.'
 'Q: projects.locations.backups.get 메서드를 사용하여 백업 정보를 가져오는 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/locations/*/backups/*}\n```\nURL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: projects.locations.get 메서드를 사용하여 위치 정보를 가져오는 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/locations/*}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: 트랜잭션 롤백을 위한 HTTP 요청 방법은 무엇인가요?\nA: 트랜잭션 롤백을 위한 HTTP 요청은 POST 메서드를 사용해야 하며, 요청 URL은 `https://firestore.googleapis.com/v1/{database=projects/*/databases/*}/documents:rollback`입니다.'
 'Q: Firestore에서 documents.list 메서드를 사용하여 문서를 나열할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{parent=projects/*/databases/*/documents}/{collectionId}\n```\nURL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Firestore에서 documents.list 메서드를 사용하여 문서를 나열할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1beta1/{parent=projects/*/databases/*/documents}/{collectionId}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Firestore에서 documents.list 메서드를 사용하여 문서를 나열할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{parent=projects/*/databases/*/documents}/{collectionId}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Firestore에서 documents.list 메서드를 사용하여 문서를 나열할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{parent=projects/*/databases/*/documents/*/**}/{collectionId}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: FirestoreAdmin.ListFields 메서드를 호출할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: FirestoreAdmin.ListFields 메서드를 호출할 때 필요한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{parent=projects/*/databases/*/collectionGroups/*}/fields\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: documents.batchWrite 메서드를 사용하여 여러 개의 쓰기 작업을 어떻게 수행하나요?\nA: documents.batchWrite 메서드를 사용하여 여러 개의 쓰기 작업을 수행하려면, HTTP POST 요청을 다음과 같이 보냅니다:\n\n```\nPOST https://firestore.googleapis.com/v1beta1/{database=projects/*/databases/*}/documents:batchWrite\n```\n여기서 {database}는 프로젝트 ID와 데이터베이스 ID를 포함한 데이터베이스 이름입니다.'
 'Q: Firestore의 batchWrite 메서드를 사용하여 여러 개의 쓰기 작업을 어떻게 수행하나요?\nA: Firestore의 batchWrite 메서드를 사용하여 여러 개의 쓰기 작업을 수행하려면, 다음과 같은 HTTP POST 요청을 사용합니다:\n\n```\nPOST https://firestore.googleapis.com/v1/{database=projects/*/databases/*}/documents:batchWrite\n```\n여기서 {database}는 프로젝트 ID와 데이터베이스 ID를 포함한 데이터베이스 이름입니다.'
 'Q: Cloud Firestore API에서 데이터베이스 정보를 가져오는 방법은 무엇인가요?\nA: 데이터베이스 정보를 가져오려면 `get` 메서드를 사용합니다. 다음은 요청 예시입니다:\n\n```http\nGET /v1/{name=projects/*/databases/*}\n```'
 'Q: PATCH 메서드를 사용하여 Firestore 문서를 업데이트할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nPATCH https://firestore.googleapis.com/v1beta1/{document.name=projects/*/databases/*/documents/*/**}\n```\nURL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: FirestoreAdmin API에서 데이터베이스를 복제하는 요청의 구조는 어떻게 되나요?\nA: 데이터베이스 복제를 위한 요청은 CloneDatabase 메서드를 사용합니다. 요청 구조는 CloneDatabaseRequest 메시지를 포함해야 합니다.'
 'Q: Firebase Firestore API에서 문서를 가져오는 방법은 무엇인가요?\nA: 문서를 가져오기 위해서는 GET 요청을 사용해야 합니다. 요청 URL은 다음과 같은 형식을 따릅니다: `https://firestore.googleapis.com/v1/projects/{projectId}/databases/{databaseId}/documents/{documentId}`.'
 'Q: PATCH 메서드를 사용하여 Firestore에서 문서를 업데이트할 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nPATCH https://firestore.googleapis.com/v1/{document.name=projects/*/databases/*/documents/*/**}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: projects.databases.operations.get 메서드의 HTTP 요청 형식은 어떻게 되나요?\nA: HTTP 요청 형식은 다음과 같습니다:\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/operations/*}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Firestore에서 특정 문서를 가져오기 위한 HTTP 요청 형식은 무엇인가요?\nA: 특정 문서를 가져오기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/documents/*/**}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Firestore에서 특정 문서를 가져오기 위한 HTTP 요청 형식은 무엇인가요?\nA: 특정 문서를 가져오기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nGET https://firestore.googleapis.com/v1beta1/{name=projects/*/databases/*/documents/*/**}\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Cloud Firestore API에서 문서의 메타데이터를 가져오는 방법은 무엇인가요?\nA: 문서의 메타데이터를 가져오려면 `get` 메서드를 사용합니다. 다음은 요청 예시입니다:\n\n```http\nGET /v1beta1/{name=projects/*/databases/*/documents/*/**}\n```'
 'Q: Cloud Firestore API에서 문서 목록을 가져오는 방법은 무엇인가요?\nA: 문서 목록을 가져오려면 `listDocuments` 메서드를 사용합니다. 다음은 요청 예시입니다.\n\n```http\nGET /v1/{parent=projects/*/databases/*/documents}/{collectionId}\n```'
 'Q: Firebase Firestore API에서 문서를 가져올 때 필요한 파라미터는 무엇인가요?\nA: 문서를 가져오기 위해서는 `projectId`, `databaseId`, `documentId`가 필요합니다. 이들은 각각 프로젝트 ID, 데이터베이스 ID, 문서 ID를 나타냅니다.'
 'Q: Cloud Firestore API에서 필드 메타데이터를 가져오는 방법은 무엇인가요?\nA: 필드 메타데이터를 가져오기 위해서는 `get` 메서드를 사용합니다. 이 메서드는 특정 필드의 메타데이터와 구성을 가져옵니다. 요청은 다음과 같이 구성됩니다:\n\n```\nGET /v1beta2/{name=projects/*/databases/*/collectionGroups/*/fields/*}\n```'
 'Q: Google Cloud Firestore에 문서를 가져오기 위해 필요한 HTTP 요청 형식은 무엇인가요?\nA: HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1/{name=projects/*/databases/*}:importDocuments\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: Cloud Firestore API에서 백업 정보를 가져오는 방법은 무엇인가요?\nA: 백업 정보를 가져오려면 GET 메서드를 사용하여 다음과 같이 요청합니다:\n\n```\nGET /v1/{name=projects/*/locations/*/backups/*}\n```\n여기서 `{name}`은 가져올 백업의 경로를 나타냅니다.'
 'Q: Google Cloud Firestore에 문서를 가져오기 위해 필요한 HTTP 요청 형식은 무엇인가요?\nA: 문서를 가져오기 위한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1/{name=projects/*/databases/*}:importDocuments\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 ""Q: mongosh를 사용하여 Cloud Firestore 데이터베이스에 연결하는 방법은 무엇인가요?\nA: 다음 명령어를 사용하여 mongosh를 실행합니다: \n\n``` \nmongosh 'mongodb://USERNAME:PASSWORD@CONNECTION_STRING:443/DATABASE_ID?loadBalanced=true&authMechanism=SCRAM-SHA-256&tls=true&retryWrites=false' \n``` \nUSERNAME, PASSWORD, CONNECTION_STRING, DATABASE_ID를 각각 생성한 데이터베이스 사용자의 이름, 비밀번호, 데이터베이스 연결 문자열, 데이터베이스 ID로 바꿉니다.""
 'Q: Firestore에서 documents.list 메서드를 사용하여 문서를 나열할 때, 요청 URL의 형식은 어떻게 되나요?\nA: 요청 URL의 형식은 다음과 같습니다: \n```\nGET https://firestore.googleapis.com/v1/{parent=projects/*/databases/*/documents/*/**}/{collectionId}\n```\n여기서 `parent`는 필수 파라미터로, 형식은 `projects/{projectId}/databases/{databaseId}/documents` 또는 `projects/{projectId}/databases/{databaseId}/documents/{document_path}`입니다.'
 'Q: Google Cloud Firestore에 문서를 가져오기 위해 필요한 HTTP 요청 형식은 무엇인가요?\nA: 문서를 가져오기 위해 필요한 HTTP 요청 형식은 다음과 같습니다:\n\n```\nPOST https://firestore.googleapis.com/v1beta1/{name=projects/*/databases/*}:importDocuments\n```\n이 URL은 gRPC Transcoding 구문을 사용합니다.'
 'Q: 복제 요청을 보낼 때 필요한 HTTP 요청 형식은 무엇인가요?\nA: 복제 요청은 다음과 같은 형식으로 POST 요청을 보냅니다: \n```\nPOST https://firestore.googleapis.com/v1/{parent=projects/*}/databases:clone\n```'
 'Q: Cloud Firestore API에서 문서를 가져오는 방법은 무엇인가요?\nA: 문서를 가져오기 위해서는 `importDocuments` 메서드를 사용합니다. 이 메서드는 문서를 Google Cloud Firestore로 가져옵니다. 요청은 다음과 같이 구성됩니다:\n\n```\nPOST /v1beta2/{name=projects/*/databases/*}:importDocuments\n```'
 'Q: projects.databases.collectionGroups.indexes.get 메서드를 사용하여 복합 인덱스를 가져오는 방법은 무엇인가요?\nA: 복합 인덱스를 가져오려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://firestore.googleapis.com/v1beta2/{name=projects/*/databases/*/collectionGroups/*/indexes/*}\n```\n여기서 {name}은 `projects/{projectId}/databases/{databaseId}/collectionGroups/{collectionId}/indexes/{index_id}` 형식의 문자열입니다.'
 'Q: Firestore에서 문서의 메타데이터를 가져오는 방법은 무엇인가요?\nA: Firestore에서 문서의 메타데이터를 가져오려면 GET 메서드를 사용하여 다음과 같은 요청을 보냅니다:\n\n```\nGET /v1beta1/{name=projects/*/databases/*/documents/*/**}\n```\n이 요청은 특정 문서의 메타데이터를 반환합니다.'
 'Q: projects.databases.collectionGroups.fields.get 메서드를 사용하여 필드의 메타데이터를 가져오는 방법은 무엇인가요?\nA: 다음과 같은 HTTP GET 요청을 사용하여 필드의 메타데이터와 구성을 가져올 수 있습니다:\n\n```\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/collectionGroups/*/fields/*}\n```\n여기서 `{name}`은 `projects/{projectId}/databases/{databaseId}/collectionGroups/{collectionId}/fields/{field_id}` 형식의 문자열입니다.'
 'Q: Cloud Firestore API에서 문서 목록을 가져오는 방법은 무엇인가요?\nA: 문서 목록을 가져오려면 GET 메서드를 사용하여 다음과 같이 요청합니다:\n\n```\nGET /v1/{parent=projects/*/databases/*/documents}/{collectionId}\n```\n여기서 `{parent}`는 문서의 부모 경로를, `{collectionId}`는 가져올 문서가 포함된 컬렉션의 ID를 나타냅니다.'
 'Q: DeleteDocumentRequest를 사용하여 Firestore에서 문서를 삭제할 때 필요한 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. The resource name of the Document to delete. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. |\n| current_document | Precondition An optional precondition on the document. The request will fail if this is set and not met by the target document. |'
 'Q: FirestoreAdmin API에서 CloneDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}. |'
 'Q: Firestore에서 데이터베이스를 복제하기 위한 CloneDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}. |'
 'Q: Firestore에서 데이터베이스 복제 요청의 CloneDatabaseRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |\n| tags | map<string, string> Optional. Immutable. Tags to be bound to the cloned database. The tags should be provided in the format of tagKeys/{tag_key_id} -> tagValues/{tag_value_id}.'
 'Q: Target를 설정할 때 필수로 포함해야 하는 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| target_id | int32 The target ID that identifies the target on the stream. Must be a positive number and non-zero. If target_id is 0 (or unspecified), the server will assign an ID for this target and return that in a TargetChange::ADD event. Once a target with target_id=0 is added, all subsequent targets must also have target_id=0. If an AddTarget request with target_id != 0 is sent to the server after a target with target_id=0 is added, the server will immediately send a response with a TargetChange::Remove event. Note that if the client sends multiple AddTarget requests without an ID, the order of IDs returned in TargetChange.target_ids are undefined. Therefore, clients should provide a target ID instead of relying on the server to assign one. If target_id is non-zero, there must not be an existing active target on this stream with the same ID. |\n| once | bool If the target should be removed once it is current and consistent. |\n| expected_count | Int32Value The number of documents that last matched the query at the resume token or read time. This value is only relevant when a resume_type is provided. This value being present and greater than zero signals that the client wants ExistenceFilter.unchanged_names to be included in the response. |'
 'Q: Firestore에서 Target을 설정할 때 어떤 필드를 제공해야 하나요?\nA: | Fields |\n| --- |\n| target_id | int32 The target ID that identifies the target on the stream. Must be a positive number and non-zero. If target_id is 0 (or unspecified), the server will assign an ID for this target and return that in a TargetChange::ADD event. Once a target with target_id=0 is added, all subsequent targets must also have target_id=0. If an AddTarget request with target_id != 0 is sent to the server after a target with target_id=0 is added, the server will immediately send a response with a TargetChange::Remove event. Note that if the client sends multiple AddTarget requests without an ID, the order of IDs returned in TargetChange.target_ids are undefined. Therefore, clients should provide a target ID instead of relying on the server to assign one. If target_id is non-zero, there must not be an existing active target on this stream with the same ID. |\n| once | bool If the target should be removed once it is current and consistent. |\n| expected_count | Int32Value The number of documents that last matched the query at the resume token or read time. This value is only relevant when a resume_type is provided. This value being present and greater than zero signals that the client wants ExistenceFilter.unchanged_names to be included in the response. |\n| Union field target_type. The type of target to listen to. target_type can be only one of the following: |\n| query | QueryTarget A target specified by a query. |\n| documents | DocumentsTarget A target specified by a set of document names. |'
 'Q: FirestoreAdmin API에서 RestoreDatabaseRequest의 database_id 필드는 어떤 규칙을 따라야 하나요?\nA: | Fields |\n| --- |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |'
 ""Q: FirestoreAdmin API에서 ExportDocumentsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to export. Unspecified means all collections. Each collection ID in this list must be unique. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |\n| snapshot_time | Timestamp The timestamp that corresponds to the version of the database to be exported. The timestamp must be in the past, rounded to the minute and not older than earliestVersionTime. If specified, then the exported documents will represent a consistent view of the database at the provided time. Otherwise, there are no guarantees about the consistency of the exported documents.""
 ""Q: FirestoreAdmin API에서 ExportDocumentsRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| name | string Required. Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to export. Unspecified means all collections. Each collection ID in this list must be unique. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |\n| snapshot_time | Timestamp The timestamp that corresponds to the version of the database to be exported. The timestamp must be in the past, rounded to the minute and not older than earliestVersionTime. If specified, then the exported documents will represent a consistent view of the database at the provided time. Otherwise, there are no guarantees about the consistency of the exported documents.""
 'Q: RunAggregationQueryResponse에서 어떤 정보를 확인할 수 있나요?\nA: | Fields |\n| --- |\n| result | AggregationResult A single aggregation result. Not present when reporting partial progress. |\n| transaction | bytes The transaction that was started as part of this request. Only present on the first response when the request requested to start a new transaction. |\n| read_time | Timestamp The time at which the aggregate result was computed. This is always monotonically increasing; in this case, the previous AggregationResult in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no result will be sent, and this represents the time at which the query was run. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunAggregationQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |'
 'Q: Firestore에서 RunAggregationQueryResponse를 통해 어떤 정보를 받을 수 있나요?\nA: | Fields |\n| --- |\n| result | AggregationResult A single aggregation result. Not present when reporting partial progress. |\n| transaction | bytes The transaction that was started as part of this request. Only present on the first response when the request requested to start a new transaction. |\n| read_time | Timestamp The time at which the aggregate result was computed. This is always monotonically increasing; in this case, the previous AggregationResult in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no result will be sent, and this represents the time at which the query was run. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunAggregationQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |'
 'Q: RunAggregationQueryResponse에서 aggregation 결과를 확인할 때 어떤 필드를 확인해야 하나요?\nA: | Fields |\n| --- |\n| result | AggregationResult A single aggregation result. Not present when reporting partial progress. |\n| transaction | bytes The transaction that was started as part of this request. Only present on the first response when the request requested to start a new transaction. |\n| read_time | Timestamp The time at which the aggregate result was computed. This is always monotonically increasing; in this case, the previous AggregationResult in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no result will be sent, and this represents the time at which the query was run. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunAggregationQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |'
 'Q: FirestoreAdmin API에서 CreateDatabaseRequest의 필드에는 어떤 것들이 있나요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |'
 'Q: Firestore에서 데이터베이스를 생성하는 CreateDatabaseRequest의 요청 구조는 어떻게 되나요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition.'
 'Q: Firestore에서 데이터베이스를 생성할 때 필요한 CreateDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition.'
 'Q: Firestore에서 데이터베이스 생성 요청을 위한 CreateDatabaseRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. A parent name of the form projects/{project_id} |\n| database | Database Required. The Database to create. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |'
 'Q: RunQueryResponse에서 쿼리 결과를 어떻게 확인할 수 있나요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Can only be set in the first response, and only if RunQueryRequest.new_transaction was set in the request. If set, no other fields will be set in this response. |\n| document | Document A query result, not set when reporting partial progress. |\n| read_time | Timestamp The time at which the document was read. This may be monotonically increasing; in this case, the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no document will be sent, and this represents the time at which the query was run. |\n| skipped_results | int32 The number of results that have been skipped due to an offset between the last response and the current response. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |\n| Union field continuation_selector. The continuation mode for the query. If present, it indicates the current query response stream has finished. This can be set with or without a document present, but when set, no more results are returned. continuation_selector can be only one of the following: |\n| done | bool If present, Firestore has completely finished the request and no more documents will be returned. |'
 'Q: Firestore에서 RunQueryResponse를 통해 어떤 정보를 받을 수 있나요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Can only be set in the first response, and only if RunQueryRequest.new_transaction was set in the request. If set, no other fields will be set in this response. |\n| document | Document A query result, not set when reporting partial progress. |\n| read_time | Timestamp The time at which the document was read. This may be monotonically increasing; in this case, the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no document will be sent, and this represents the time at which the query was run. |\n| skipped_results | int32 The number of results that have been skipped due to an offset between the last response and the current response. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |\n| Union field continuation_selector. The continuation mode for the query. If present, it indicates the current query response stream has finished. This can be set with or without a document present, but when set, no more results are returned. continuation_selector can be only one of the following: |\n| done | bool If present, Firestore has completely finished the request and no more documents will be returned. |'
 'Q: RunQueryResponse에서 쿼리 결과를 확인할 때 어떤 필드를 확인해야 하나요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Can only be set in the first response, and only if RunQueryRequest.new_transaction was set in the request. If set, no other fields will be set in this response. |\n| document | Document A query result, not set when reporting partial progress. |\n| read_time | Timestamp The time at which the document was read. This may be monotonically increasing; in this case, the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no document will be sent, and this represents the time at which the query was run. |\n| skipped_results | int32 The number of results that have been skipped due to an offset between the last response and the current response. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |\n| Union field continuation_selector. The continuation mode for the query. If present, it indicates the current query response stream has finished. This can be set with or without a document present, but when set, no more results are returned. continuation_selector can be only one of the following: |\n| done | bool If present, Firestore has completely finished the request and no more documents will be returned. |'
 'Q: RunQueryResponse에서 쿼리 결과를 확인할 때 포함될 수 있는 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| transaction | bytes The transaction that was started as part of this request. Can only be set in the first response, and only if RunQueryRequest.new_transaction was set in the request. If set, no other fields will be set in this response. |\n| document | Document A query result, not set when reporting partial progress. |\n| read_time | Timestamp The time at which the document was read. This may be monotonically increasing; in this case, the previous documents in the result stream are guaranteed not to have changed between their read_time and this one. If the query returns no results, a response with read_time and no document will be sent, and this represents the time at which the query was run. |\n| skipped_results | int32 The number of results that have been skipped due to an offset between the last response and the current response. |\n| explain_metrics | ExplainMetrics Query explain metrics. This is only present when the RunQueryRequest.explain_options is provided, and it is sent only once with the last response in the stream. |\n| Union field continuation_selector. The continuation mode for the query. If present, it indicates the current query response stream has finished. This can be set with or without a document present, but when set, no more results are returned. continuation_selector can be only one of the following: |\n| done | bool If present, Firestore has completely finished the request and no more documents will be returned. |'
 ""Q: FirestoreAdmin API에서 데이터베이스를 복원하는 RestoreDatabase 메서드의 요청 구조는 어떻게 되나요?\nA: | RestoreDatabase |\n| --- |\n| rpc RestoreDatabase(RestoreDatabaseRequest) returns (Operation) Creates a new database by restoring from an existing backup. The new database must be in the same cloud region or multi-region location as the existing backup. This behaves similar to FirestoreAdmin.CreateDatabase except instead of creating a new empty database, a new database is created with the database type, index configuration, and documents from an existing backup. The long-running operation can be used to track the progress of the restore, with the Operation's metadata field type being the RestoreDatabaseMetadata. The response type is the Database if the restore was successful. The new database is not readable or writeable until the LRO has completed. Authorization scopes Requires one of the following OAuth scopes: https://www.googleapis.com/auth/datastore https://www.googleapis.com/auth/cloud-platform For more information, see the OAuth 2.0 Overview.""
 ""Q: BloomFilter의 구조와 해시 계산 방법은 무엇인가요?\nA: A bloom filter (https://en.wikipedia.org/wiki/Bloom_filter) [https://en.wikipedia.org/wiki/Bloom_filter)]. The bloom filter hashes the entries with MD5 and treats the resulting 128-bit hash as 2 distinct 64-bit hash values, interpreted as unsigned integers using 2's complement encoding. These two hash values, named h1 and h2, are then used to compute the hash_count hash values using the formula, starting at i=0:\nh(i) = h1 + (i * h2)\nThese resulting values are then taken modulo the number of bits in the bloom filter to get the bits of the bloom filter to test for the given entry.""
 ""Q: BloomFilter의 구조와 해시 계산 방법은 무엇인가요?\nA: A bloom filter (https://en.wikipedia.org/wiki/Bloom_filter) [https://en.wikipedia.org/wiki/Bloom_filter)].The bloom filter hashes the entries with MD5 and treats the resulting 128-bit hash as 2 distinct 64-bit hash values, interpreted as unsigned integers using 2's complement encoding.These two hash values, named h1 and h2, are then used to compute the hash_count hash values using the formula, starting at i=0:\nh(i) = h1 + (i * h2)\n\nThese resulting values are then taken modulo the number of bits in the bloom filter to get the bits of the bloom filter to test for the given entry.""
 ""Q: Firestore에서 필드(Field)의 인덱스 구성(IndexConfig)은 어떤 정보를 포함하나요?\nA: | IndexConfig |\n| --- |\n| indexes[] | object (Index) The indexes supported for this field. |\n| usesAncestorConfig | boolean Output only. When true, the Field's index configuration is set from the configuration specified by the ancestorField. When false, the Field's index configuration is defined explicitly. |\n| ancestorField | string Output only. Specifies the resource name of the Field from which this field's index configuration is set (when usesAncestorConfig is true), or from which it would be set if this field had no index configuration (when usesAncestorConfig is false). |\n| reverting | boolean Output only When true, the Field's index configuration is in the process of being reverted. Once complete, the index config will transition to the same state as the field specified by ancestorField, at which point usesAncestorConfig will be true and reverting will be false. |""
 'Q: PartitionQueryResponse를 통해 Firestore에서 파티션 결과를 어떻게 확인하나요?\nA: | Fields |\n| --- |\n| partitions[] | Cursor Partition results. Each partition is a split point that can be used by RunQuery as a starting or end point for the query results. The RunQuery requests must be made with the same query supplied to this PartitionQuery request. The partition cursors will be ordered according to same ordering as the results of the query supplied to PartitionQuery. For example, if a PartitionQuery request returns partition cursors A and B, running the following three queries will return the entire result set of the original query: query, end_at A query, start_at A, end_at B query, start_at B An empty result may indicate that the query has too few results to be partitioned, or that the query is not yet supported for partitioning. |\n| next_page_token | string A page token that may be used to request an additional set of results, up to the number specified by partition_count in the PartitionQuery request. If blank, there are no more results. |'
 'Q: ExportDocumentsRequest를 사용하여 Firestore 데이터베이스를 내보낼 때 필요한 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection ids to export. Unspecified means all collections. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time.'
 'Q: 문서 업데이트 요청 시 사용할 수 있는 쿼리 매개변수에는 어떤 것들이 있나요?\nA: | Parameters |\n| --- |\n| updateMask | object (DocumentMask) The fields to update. None of the field paths in the mask may contain a reserved name. If the document exists on the server and has fields not referenced in the mask, they are left unchanged. Fields referenced in the mask, but not present in the input document, are deleted from the document on the server. |\n| mask | object (DocumentMask) The fields to return. If not set, returns all fields. If the document has a field that is not present in this mask, that field will not be returned in the response. |\n| currentDocument | object (Precondition) An optional precondition on the document. The request will fail if this is set and not met by the target document.'
 'Q: ExportDocumentsRequest를 사용하여 문서를 내보낼 때 필요한 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection ids to export. Unspecified means all collections. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time.'
 ""Q: Firestore에서 인덱스 구성(IndexConfig)의 'reverting' 필드는 어떤 의미인가요?\nA: | Fields |\n| --- |\n| reverting | boolean Output only When true, the Field's index configuration is in the process of being reverted. Once complete, the index config will transition to the same state as the field specified by ancestorField, at which point usesAncestorConfig will be true and reverting will be false. |""
 'Q: Cloud Firestore에서 문서를 내보내는 ExportDocuments 요청의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection ids to export. Unspecified means all collections. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time. |'
 'Q: FirestoreAdmin API에서 문서를 대량으로 삭제하는 BulkDeleteDocuments 메서드는 어떻게 사용하나요?\nA: | BulkDeleteDocuments |\n| --- |\n| rpc BulkDeleteDocuments(BulkDeleteDocumentsRequest) returns (Operation) Bulk deletes a subset of documents from Google Cloud Firestore. Documents created or updated after the underlying system starts to process the request will not be deleted. The bulk delete occurs in the background and its progress can be monitored and managed via the Operation resource that is created. For more details on bulk delete behavior, refer to: https://cloud.google.com/firestore/docs/manage-data/bulk-delete Authorization scopes Requires one of the following OAuth scopes: https://www.googleapis.com/auth/datastore https://www.googleapis.com/auth/cloud-platform For more information, see the Authentication Overview. |'
 'Q: Firestore 데이터베이스에서 인덱스의 fields 필드는 어떤 형식을 가져야 하나요?\nA: | fields[] | IndexField The fields supported by this index. For composite indexes, this requires a minimum of 2 and a maximum of 100 fields. The last field entry is always for the field path __name__. If, on creation, __name__ was not specified as the last field, it will be added automatically with the same direction as that of the last field defined. If the final field in a composite index is not directional, the __name__ will be ordered ASCENDING (unless explicitly specified). For single field indexes, this will always be exactly one entry with a field path equal to the field path of the associated field.'
 'Q: Cloud Firestore에서 ExportDocumentsRequest 메서드를 사용하여 문서를 내보내기 위한 요청 형식은 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Database to export. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection ids to export. Unspecified means all collections. |\n| output_uri_prefix | string The output URI. Currently only supports Google Cloud Storage URIs of the form: gs://BUCKET_NAME[/NAMESPACE_PATH], where BUCKET_NAME is the name of the Google Cloud Storage bucket and NAMESPACE_PATH is an optional Google Cloud Storage namespace path. When choosing a name, be sure to consider Google Cloud Storage naming guidelines: https://cloud.google.com/storage/docs/naming. If the URI is a bucket (without a namespace path), a prefix will be generated based on the start time.'
 'Q: Firestore에서 BatchGetDocumentsRequest를 사용하여 문서를 배치로 가져올 때 필요한 필드는 무엇인가요?\nA: | BatchGetDocumentsRequest |\n| --- |\n| Fields |\n| --- |\n| database | string Required. The database name. In the format: projects/{project_id}/databases/{database_id}. |\n| documents[] | string The names of the documents to retrieve. In the format: projects/{project_id}/databases/{database_id}/documents/{document_path}. The request will fail if any of the document is not a child resource of the given database. Duplicate names will be elided. |\n| mask | DocumentMask The fields to return. If not set, returns all fields. If a document has a field that is not present in this mask, that field will not be returned in the response. |'
 'Q: ListDocumentsRequest를 사용하여 Firestore에서 문서를 나열할 때 필요한 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The parent resource name. In the format: projects/{project_id}/databases/{database_id}/documents or projects/{project_id}/databases/{database_id}/documents/{document_path}. For example: projects/my-project/databases/my-database/documents or projects/my-project/databases/my-database/documents/chatrooms/my-chatroom |\n| collection_id | string Optional. The collection ID, relative to parent, to list. For example: chatrooms or messages. This is optional, and when not provided, Firestore will list documents from all collections under the provided parent. |\n| page_size | int32 Optional. The maximum number of documents to return in a single response. Firestore may return fewer than this value. |\n| page_token | string Optional. A page token, received from a previous ListDocuments response. Provide this to retrieve the subsequent page. When paginating, all other parameters (with the exception of page_size) must match the values set in the request that generated the page token. |\n| order_by | string Optional. The optional ordering of the documents to return. For example: priority desc, __name__ desc. This mirrors the ORDER BY used in Firestore queries but in a string representation. When absent, documents are ordered based on __name__ ASC. |\n| mask | DocumentMask Optional. The fields to return. If not set, returns all fields. If a document has a field that is not present in this mask, that field will not be returned in the response. |\n| show_missing | bool If the list should show missing documents. A document is missing if it does not exist, but there are sub-documents nested underneath it. When true, such missing documents will be returned with a key but will not have fields, create_time, or update_time set. Requests with show_missing may not specify where or order_by. |'
 'Q: documents.list 메서드에서 사용할 수 있는 쿼리 파라미터는 무엇이 있나요?\nA: | Parameters |\n| --- |\n| pageSize | integer Optional. The maximum number of documents to return in a single response. Firestore may return fewer than this value. |\n| pageToken | string Optional. A page token, received from a previous documents.list response. Provide this to retrieve the subsequent page. When paginating, all other parameters (with the exception of pageSize) must match the values set in the request that generated the page token. |\n| orderBy | string Optional. The optional ordering of the documents to return. For example: priority desc, __name__ desc. This mirrors the ORDER BY used in Firestore queries but in a string representation. When absent, documents are ordered based on __name__ ASC. |\n| mask | object (DocumentMask) Optional. The fields to return. If not set, returns all fields. If a document has a field that is not present in this mask, that field will not be returned in the response. |\n| showMissing | boolean If the list should show missing documents. A document is missing if it does not exist, but there are sub-documents nested underneath it. When true, such missing documents will be returned with a key but will not have fields, createTime, or updateTime set. Requests with showMissing may not specify where or orderBy. |'
 'Q: Firestore 인덱스의 query_scope 필드는 어떤 역할을 하나요?\nA: | query_scope | QueryScope Indexes with a collection query scope specified allow queries against a collection that is the child of a specific document, specified at query time, and that has the same collection ID. Indexes with a collection group query scope specified allow queries against all collections descended from a specific document, specified at query time, and that have the same collection ID as this index.'
 'Q: Firestore 데이터베이스의 version_retention_period 필드는 무엇을 의미하나요?\nA: | Fields |\n| --- |\n| version_retention_period | Duration Output only. The period during which past versions of data are retained in the database. Any read or query can specify a read_time within this window, and will read the state of the database at that time. If the PITR feature is enabled, the retention period is 7 days. Otherwise, the retention period is 1 hour.'
 'Q: 문서를 삭제할 때 사용할 수 있는 쿼리 매개변수는 무엇인가요?\nA: | Parameters |\n| --- |\n| currentDocument | object (Precondition) An optional precondition on the document. The request will fail if this is set and not met by the target document. |'
 'Lists documents.\n\nHTTP request\nGET https://firestore.googleapis.com/v1/{parent=projects/*/databases/*/documents}/{collectionId}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| parent | string Required. The parent resource name. In the format: projects/{projectId}/databases/{databaseId}/documents or projects/{projectId}/databases/{databaseId}/documents/{document_path}. For example: projects/my-project/databases/my-database/documents or projects/my-project/databases/my-database/documents/chatrooms/my-chatroom |\n| collectionId | string Optional. The collection ID, relative to parent, to list. For example: chatrooms or messages. This is optional, and when not provided, Firestore will list documents from all collections under the provided parent. |'
 'HTTP request\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Required. A name of the form projects/{projectId}/databases/{databaseId} |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body contains an instance of Database [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases#Database].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:\n\nhttps://www.googleapis.com/auth/datastore\nhttps://www.googleapis.com/auth/cloud-platform\nFor more information, see the OAuth 2.0 Overview [https://developers.google.com/identity/protocols/OAuth2].\n\nSend feedback'
 'HTTP request\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Required. A name of the form projects/{projectId}/databases/{databaseId} |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body contains an instance of Database [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases#Database].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:\n\nhttps://www.googleapis.com/auth/datastore\nhttps://www.googleapis.com/auth/cloud-platform\nFor more information, see the Authentication Overview [https://cloud.google.com/docs/authentication#authorization-gcp].\n\nSend feedback'
 'Source URL: https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases/list?hl=ko\nTitle: Method: projects.databases.list\n\nSend feedback\n\nMethod: projects.databases.list\n\nStay organized with collections\n\nSave and categorize content based on your preferences.\n\nList all the databases in the project.\n\nHTTP request\nGET https://firestore.googleapis.com/v1/{parent=projects/*}/databasesThe URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| parent | string Required. A parent name of the form projects/{projectId} |\n\nQuery parameters\n| Parameters |\n| --- |\n| showDeleted | boolean If true, also returns deleted resources. |\n\nRequest body\nThe request body must be empty.\n\nResponse body\n\nThe list of databases for a project.\nIf successful, the response body contains data with the following structure:\n\n| JSON representation |\n| --- |\n| {   ""databases"": [     {       object (Database)     }   ],   ""unreachable"": [     string   ] } |'
 'Lists documents.\n\nHTTP request\nGET https://firestore.googleapis.com/v1beta1/{parent=projects/*/databases/*/documents}/{collectionId}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| parent | string Required. The parent resource name. In the format: projects/{projectId}/databases/{databaseId}/documents or projects/{projectId}/databases/{databaseId}/documents/{document_path}. For example: projects/my-project/databases/my-database/documents or projects/my-project/databases/my-database/documents/chatrooms/my-chatroom |\n| collectionId | string Optional. The collection ID, relative to parent, to list. For example: chatrooms or messages. This is optional, and when not provided, Firestore will list documents from all collections under the provided parent. |'
 'HTTP request\nGET https://firestore.googleapis.com/v1/{name=projects/*/locations/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Resource name for the location. |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body contains an instance of Location [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.locations#Location].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:\n\nhttps://www.googleapis.com/auth/datastore\nhttps://www.googleapis.com/auth/cloud-platform\nFor more information, see the OAuth 2.0 Overview [https://developers.google.com/identity/protocols/OAuth2].\n\n도움이 되었나요?\n\nSend feedback'
 'Lists documents.\n\nHTTP request\nGET https://firestore.googleapis.com/v1beta1/{parent=projects/*/databases/*/documents/*/**}/{collectionId}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| parent | string Required. The parent resource name. In the format: projects/{projectId}/databases/{databaseId}/documents or projects/{projectId}/databases/{databaseId}/documents/{document_path}. For example: projects/my-project/databases/my-database/documents or projects/my-project/databases/my-database/documents/chatrooms/my-chatroom |\n| collectionId | string Optional. The collection ID, relative to parent, to list. For example: chatrooms or messages. This is optional, and when not provided, Firestore will list documents from all collections under the provided parent. |'
 'Gets an index.\n\nHTTP request\nGET https://firestore.googleapis.com/v1beta1/{name=projects/*/databases/*/indexes/*}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string The name of the index. For example: projects/{projectId}/databases/{databaseId}/indexes/{index_id} |\n\nRequest body\nThe request body must be empty.\n\nResponse body\nIf successful, the response body contains an instance of Index [https://cloud.google.com/firestore/docs/reference/rest/v1beta1/projects.databases.indexes#Index].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:\n\nhttps://www.googleapis.com/auth/datastore\nhttps://www.googleapis.com/auth/cloud-platform\nFor more information, see the Authentication Overview [https://cloud.google.com/docs/authentication#authorization-gcp].\n\nSend feedback'
 'Gets a single document.\n\nHTTP request\nGET https://firestore.googleapis.com/v1/{name=projects/*/databases/*/documents/*/**}The URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Required. The resource name of the Document to get. In the format: projects/{projectId}/databases/{databaseId}/documents/{document_path}. |'
 '서비스 런타임 측정항목\n\nserviceruntime [https://cloud.google.com/monitoring/api/metrics_gcp_p_z?hl=ko#gcp-serviceruntime] 측정항목은 프로젝트 트래픽에 대한 대략적인 개요를 제공합니다. 이러한 측정항목은 대부분의 Google Cloud API에서 사용할 수 있습니다. consumed_api [https://cloud.google.com/monitoring/api/resources?hl=ko#tag_consumed_api] 모니터링 리소스 유형에는 이러한 일반 측정항목이 포함됩니다. 이러한 측정항목은 30분마다 샘플링되므로 데이터가 평활화됩니다.\n\nserviceruntime 측정항목의 중요한 리소스 라벨은 method입니다. 이 라벨은 호출된 기본 RPC 메서드를 나타냅니다. 호출하는 SDK 메서드의 이름은 기본 RPC 메서드와 동일하지 않을 수 있습니다. SDK는 상위 수준 API 추상화를 제공하기 때문입니다. 하지만 애플리케이션이 Firestore와 상호작용하는 방식을 이해하려면 RPC 메서드 이름을 기반으로 한 측정항목을 이해하는 것이 중요합니다.\n\n특정 SDK 메서드의 기본 RPC 메서드를 알아야 하는 경우 API 문서 [https://cloud.google.com/firestore/native/docs/reference/rpc/google.firestore.v1?hl=ko]를 참고하세요.\n\n다음 서비스 런타임 측정항목을 사용하여 데이터베이스를 모니터링합니다.\n\napi/request_count\n\n이 측정항목은 프로토콜(http, gRPC 등의 요청 프로토콜), 응답 코드 (HTTP 응답 코드 [https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto]), response_code_class (2xx, 4xx 등 응답 코드 클래스) 전반에서 완료된 요청 수 및 grpc_status_code (숫자 gRPC 응답 코드 [https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto])를 제공합니다. 이 측정항목을 사용하여 전체 API 요청을 관찰하고 오류율을 계산합니다.'
 'ttl_config {}\n}\n\nproject-id를 프로젝트 ID로 바꿉니다. 프로젝트 ID는 고유해야 합니다.\ndatabase-id를 데이터베이스 ID로 바꿉니다.\n\n복합 색인\n\n다음 Terraform 구성 파일 예시에서는 chatrooms 컬렉션의 name 필드와 description 필드 조합에 대한 복합 색인을 만듭니다.\n\nfirestore.tf\n\nresource ""google_firestore_index"" ""composite-index"" {\nproject = ""project-id""\ndatabase = ""database-id""\n\ncollection = ""chatrooms""\n\nfields {\nfield_path = ""name""\norder      = ""ASCENDING""\n}\n\nfields {\nfield_path = ""description""\norder      = ""DESCENDING""\n}\n\n}\n\nproject-id를 프로젝트 ID로 바꿉니다. 프로젝트 ID는 고유해야 합니다.\ndatabase-id를 데이터베이스 ID로 바꿉니다.\n\n벡터 색인\n\n다음 Terraform 구성 파일 예시에서는 chatrooms 컬렉션의 embedding 필드에 대한 벡터 색인을 만듭니다.\n\nfirestore.tf\n\nresource ""google_firestore_index"" ""vector-index"" {\nproject = ""project-id""\ndatabase = ""database-id""\ncollection = ""chatrooms""\n\nfields {\nfield_path = ""__name__""\norder = ""ASCENDING""\n}\n\nfields {\nfield_path = ""embedding""\nvector_config {\ndimension = 128\nflat {}\n}\n}\n}\n\nproject-id를 프로젝트 ID로 바꿉니다. 프로젝트 ID는 고유해야 합니다.\ndatabase-id를 데이터베이스 ID로 바꿉니다.\n\n색인 빌드 시간\n\n색인을 빌드하려면 Cloud Firestore가 색인을 설정한 다음 색인을 기존 데이터로 백필해야 합니다. 색인 빌드 시간은 설정 시간과 백필 시간의 합계입니다.'
 ""서비스 런타임 측정항목\n\nserviceruntime [https://cloud.google.com/monitoring/api/metrics_gcp_p_z?hl=ko#gcp-serviceruntime] 측정항목은 프로젝트 트래픽에 대한 개략적인 개요를 제공합니다. 이러한 측정항목은 대부분의 Google Cloud API에서 사용할 수 있습니다. consumed_api [https://cloud.google.com/monitoring/api/resources?hl=ko#tag_consumed_api] 모니터링 리소스 유형에는 이러한 일반 측정항목이 포함됩니다. 이러한 측정항목은 30분마다 샘플링되므로 데이터가 평활화됩니다.\n\nserviceruntime 측정항목의 중요한 리소스 라벨은 method입니다. 이 라벨은 호출된 기본 RPC 메서드를 나타냅니다. 호출하는 SDK 메서드의 이름은 기본 RPC 메서드와 동일하지 않을 수 있습니다. SDK는 상위 수준 API 추상화를 제공하기 때문입니다. 하지만 애플리케이션이 Cloud Firestore와 상호작용하는 방식을 이해하려면 RPC 메서드 이름을 기반으로 한 측정항목을 이해하는 것이 중요합니다.\n\n특정 SDK 메서드의 기본 RPC 메서드를 알아야 하는 경우 API 참고 리소스 [https://cloud.google.com/firestore/docs/reference/rpc/google.firestore.v1?hl=ko]를 참고하세요.\n\napi/request_latencies\n\napi/request_latencies 측정항목은 완료된 모든 요청의 지연 시간 분포를 제공합니다.\n\nCloud Firestore는 Cloud Firestore 서비스 구성요소의 측정항목을 기록합니다. 지연 시간 측정항목에는 Cloud Firestore가 요청을 받는 시점부터 스토리지 레이어와의 상호작용을 포함하여 Cloud Firestore가 응답 전송을 완료하는 시점까지의 시간이 포함됩니다. 따라서 클라이언트와 Cloud Firestore 서비스 간의 왕복 지연 시간(rtt)은 이러한 측정항목에 포함되지 않습니다.\n\n문서 작업 측정항목\n\nCloud Firestore는 읽기, 쓰기, 삭제 수를 제공합니다. 쓰기 측정항목은 'CREATE' 작업과 'UPDATE' 작업 간의 분류를 제공합니다. 이러한 측정항목은 CRUD 작업과 일치합니다.""
 'Identity and Access Management 조건 [https://cloud.google.com/iam/docs/conditions-overview?hl=ko]을 사용하여 데이터베이스 수준별로 액세스 권한을 구성할 수 있습니다.\n다음 예시에서는 Google Cloud CLI를 사용하여 하나 이상의 데이터베이스에 조건부 액세스 권한을 할당합니다. Google Cloud 콘솔에서 IAM 조건을 정의 [https://cloud.google.com/iam/docs/managing-conditional-role-bindings?hl=ko]할 수도 있습니다.\n경고: Google Cloud 콘솔은 데이터베이스 수준에서 구성된 IAM 조건에 따라 데이터베이스에 대한 액세스를 허용/거부하지 않습니다. 이는 Google Cloud 콘솔을 사용하여 데이터베이스에 액세스하는 경우에만 적용됩니다.\nREST API 또는 클라이언트 라이브러리와 같이 Google Cloud 콘솔 외부에서 데이터베이스에 액세스할 때 IAM 조건이 적용됩니다.\n기존 IAM 정책 보기\ngcloud projects get-iam-policy PROJECT_ID\n\nPROJECT_ID를 프로젝트 ID로 설정합니다.\n\n데이터베이스에 대한 액세스 권한 부여\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n--member=\'user:EMAIL\' \\\n--role=\'roles/datastore.user\' \\\n--condition=\'expression=resource.name==""projects/PROJECT_ID/databases/DATABASE_ID"",title=TITLE,description=DESCRIPTION\'\n\n다음을 설정합니다.\n\nPROJECT_ID: 프로젝트 ID입니다.\nEMAIL: 특정 Google 계정을 나타내는 이메일 주소입니다. 예를 들면 alice@example.com입니다.\nDATABASE_ID: 데이터베이스 ID\nTITLE: 표현식의 제목(선택사항)입니다.\nDESCRIPTION: 표현식의 설명(선택사항)입니다.'
 '복합 색인\n\n다음 Terraform 구성 파일 예시에서는 chatrooms 컬렉션의 name 필드와 description 필드 조합에 대한 복합 색인을 만듭니다.\n\nfirestore.tf\n\nresource ""google_firestore_index"" ""composite-index"" {\nproject = ""project-id""\ndatabase = ""database-id""\n\ncollection = ""chatrooms""\n\nfields {\nfield_path = ""name""\norder      = ""ASCENDING""\n}\n\nfields {\nfield_path = ""description""\norder      = ""DESCENDING""\n}\n\n}\n\nproject-id를 프로젝트 ID로 바꿉니다. 프로젝트 ID는 고유해야 합니다.\ndatabase-id를 데이터베이스 ID로 바꿉니다.\n\n벡터 색인\n\n다음 Terraform 구성 파일 예시에서는 chatrooms 컬렉션의 embedding 필드에 대한 벡터 색인을 만듭니다.\n\nfirestore.tf\n\nresource ""google_firestore_index"" ""vector-index"" {\nproject = ""project-id""\ndatabase = ""database-id""\ncollection = ""chatrooms""\n\nfields {\nfield_path = ""__name__""\norder = ""ASCENDING""\n}\n\nfields {\nfield_path = ""embedding""\nvector_config {\ndimension = 128\nflat {}\n}\n}\n}\n\nproject-id를 프로젝트 ID로 바꿉니다. 프로젝트 ID는 고유해야 합니다.\ndatabase-id를 데이터베이스 ID로 바꿉니다.\n\nDatastore 모드 색인\n\nTerraform을 사용하여 데이터 스토어 모드 색인을 만들 수도 있습니다.\n\ndatastore.tf\n\nresource ""google_firestore_index"" ""datastore-mode-index"" {\nproject = ""project-id""\ndatabase = ""database-id""\n\ncollection = ""chatrooms""\n\nfields {\nfield_path = ""name""\norder      = ""ASCENDING""\n}\n\nfields {\nfield_path = ""description""\norder      = ""DESCENDING""\n}'
 '데이터베이스별 액세스 권한 구성\n\nIdentity and Access Management 조건 [https://cloud.google.com/iam/docs/conditions-overview?hl=ko]을 사용하여 데이터베이스 수준별로 액세스 권한을 구성할 수 있습니다.\n다음 예시에서는 Google Cloud CLI를 사용하여 하나 이상의 데이터베이스에 조건부 액세스 권한을 할당합니다. Google Cloud 콘솔에서 IAM 조건을 정의 [https://cloud.google.com/iam/docs/managing-conditional-role-bindings?hl=ko]할 수도 있습니다.\n경고: Google Cloud 콘솔은 데이터베이스 수준에서 구성된 IAM 조건에 따라 데이터베이스에 대한 액세스를 허용/거부하지 않습니다. 이는 Google Cloud 콘솔을 사용하여 데이터베이스에 액세스하는 경우에만 적용됩니다.\nREST API 또는 클라이언트 라이브러리와 같이 Google Cloud 콘솔 외부에서 데이터베이스에 액세스할 때 IAM 조건이 적용됩니다.\n기존 IAM 정책 보기\ngcloud projects get-iam-policy PROJECT_ID\n\nPROJECT_ID를 프로젝트 ID로 설정합니다.\n\n데이터베이스에 대한 액세스 권한 부여\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n--member=\'user:EMAIL\' \\\n--role=\'roles/datastore.user\' \\\n--condition=\'expression=resource.name==""projects/PROJECT_ID/databases/DATABASE_ID"",title=TITLE,description=DESCRIPTION\'\n\n다음을 설정합니다.\n\nPROJECT_ID: 프로젝트 ID입니다.\nEMAIL: 특정 Google 계정을 나타내는 이메일 주소입니다. 예를 들면 alice@example.com입니다.\nDATABASE_ID: 데이터베이스 ID\nTITLE: 표현식의 제목(선택사항)입니다.\nDESCRIPTION: 표현식의 설명(선택사항)입니다.'
 'Identity and Access Management 조건 [https://firebase.google.com/iam/docs/conditions-overview?hl=ko]을 사용하여 데이터베이스 수준별로 액세스 권한을 구성할 수 있습니다.\n다음 예시에서는 Google Cloud CLI를 사용하여 하나 이상의 데이터베이스에 조건부 액세스 권한을 할당합니다. Google Cloud 콘솔에서 IAM 조건을 정의 [https://firebase.google.com/iam/docs/managing-conditional-role-bindings?hl=ko]할 수도 있습니다.\n경고: Google Cloud 콘솔은 데이터베이스 수준에서 구성된 IAM 조건에 따라 데이터베이스에 대한 액세스를 허용/거부하지 않습니다.\nREST API 또는 클라이언트 라이브러리와 같이 Google Cloud 콘솔 외부에서 데이터베이스에 액세스할 때 IAM 조건이 적용됩니다.\n기존 IAM 정책 보기\ngcloud projects get-iam-policy PROJECT_ID\n\nPROJECT_ID를 프로젝트 ID로 설정합니다.\n\n데이터베이스에 대한 액세스 권한 부여\ngcloud projects add-iam-policy-binding PROJECT_ID \\\n--member=\'user:EMAIL\' \\\n--role=\'roles/datastore.user\' \\\n--condition=\'expression=resource.name==""projects/PROJECT_ID/databases/DATABASE_ID"",title=TITLE,description=DESCRIPTION\'\n\n다음을 설정합니다.\n\nPROJECT_ID: 프로젝트 ID입니다.\nEMAIL: 특정 계정을 나타내는 이메일 주소입니다. 예를 들면 alice@example.com입니다.\nDATABASE_ID: 데이터베이스 ID\nTITLE: 표현식의 제목(선택사항)입니다.\nDESCRIPTION: 표현식의 설명(선택사항)입니다.'
 '특히 다음 비동기 작업을 살펴보세요.\n\n보안 규칙 설정(예: initializeTestEnvironment 사용)\n데이터 읽기 및 쓰기(예: db.collection(""users"").doc(""alice"").get() 사용)\n작업 어설션(assertSucceeds 및 assertFails 포함)\n\n에뮬레이터를 처음 로드할 때만 테스트 통과\n\n에뮬레이터는 상태 저장 방식입니다. 작성된 모든 데이터를 메모리에 저장하므로 에뮬레이터가 종료될 때마다 데이터가 손실됩니다. 동일한 프로젝트 ID로 여러 테스트를 실행하는 경우 각 테스트에서 후속 테스트에 영향을 미칠 수 있는 데이터를 생성할 수 있습니다. 다음 방법을 사용하여 이러한 동작을 우회할 수 있습니다.\n\n테스트마다 고유한 프로젝트 ID를 사용합니다. 이렇게 하려면 각 테스트의 일부로 initializeTestEnvironment를 호출해야 합니다. 규칙은 기본 프로젝트 ID에 대해서만 자동으로 로드됩니다.\n이전에 작성한 데이터와 상호작용하지 않도록 테스트를 다시 구성합니다. 예를 들어 테스트마다 다른 컬렉션을 사용합니다.\n테스트 중에 작성된 모든 데이터를 삭제합니다.\n\n테스트 설정이 매우 복잡함\n\n테스트를 설정할 때 Firestore 보안 규칙에서 실제로 허용하지 않는 방식으로 데이터를 수정하는 것이 좋습니다. 규칙으로 인해 테스트 설정이 복잡하다면 설정 단계에서 RulesTestEnvironment.withSecurityRulesDisabled를 사용하여 읽기 및 쓰기로 인해 PERMISSION_DENIED 오류가 트리거되지 않도록 하세요.\n\n이후 테스트는 각각 RulesTestEnvironment.authenticatedContext 및 unauthenticatedContext를 사용하여 인증된 사용자 또는 인증되지 않은 사용자로 작업을 실행할 수 있습니다. 이를 통해 Firestore 보안 규칙이 다양한 사례를 올바르게 허용/거부하는지 확인할 수 있습니다.\n\n도움이 되었나요?\n\n의견 보내기'
 ""DATABASE_ID를 데이터베이스의 ID로 바꿉니다.\ngcloud firestore indexes fields list [https://cloud.google.com/sdk/gcloud/reference/firestore/indexes/fields/list?hl=ko]를 사용하여 단일 필드(기본 제공) 색인 예외 목록을 가져옵니다.\ngcloud firestore indexes fields list --database=DATABASE_ID\n\n인플레이스 복원 수행\n\n인플레이스 복원 작업을 수행하려면 다음 단계를 완료하세요. 이 프로세스는 데이터베이스를 삭제하는 시점과 복원 작업이 완료된 시점 사이에 다운타임이 필요합니다.\n\n복원 작업이 시작되면 작업을 취소할 수 없으므로 작업이 완료될 때까지 기다려야 합니다. 복원 작업이 작업에 사용된 데이터베이스 ID를 즉시 차지합니다.\n\ngcloud firestore backups list [https://cloud.google.com/sdk/gcloud/reference/firestore/backups/list?hl=ko] 명령어를 사용하여 복원 작업에 사용할 백업을 식별하고 리소스 이름을 기록해 둡니다. 리소스 이름의 형식은 다음과 같습니다.\nprojects/PROJECT_ID/locations/LOCATION/backups/BACKUP_ID\n\ngcloud firestore databases delete 명령어를 사용하여 기존 데이터베이스를 삭제합니다.\ngcloud firestore databases delete --database='DATABASE_ID'\n\nDATABASE_ID를 데이터베이스 ID로 바꿉니다.\n데이터베이스 ID를 다시 사용할 수 있도록 데이터베이스를 삭제한 후 5분 이상 기다립니다. gcloud firestore databases restore [https://cloud.google.com/sdk/gcloud/reference/firestore/databases/restore?hl=ko] 명령어를 사용하여 복원 작업을 시작합니다.\ngcloud firestore databases restore \\\n--source-backup=projects/PROJECT_ID/locations/LOCATION/backups/BACKUP_ID \\\n--destination-database='DATABASE_ID'\n\nDATABASE_ID를 데이터베이스 ID로 바꿉니다.""
 ""보안 규칙 버전 2\n\n2019년 5월부터 Cloud Firestore 보안 규칙 버전 2를 사용할 수 있습니다. 규칙 버전 2는 재귀 와일드 카드 [https://firebase.google.com/docs/firestore/security/rules-structure?hl=ko#recursive_wildcards] {name=**}의 동작을 변경합니다. 컬렉션 그룹 쿼리 [https://firebase.google.com/docs/firestore/query-data/queries?hl=ko#collection-group-query]를 사용하려면 버전 2를 사용해야 합니다. 보안 규칙의 첫 번째 줄에 rules_version = '2';를 추가하여 버전 2를 선택해야 합니다.\nrules_version = '2';\nservice cloud.firestore {\nmatch /databases/{database}/documents {\n\n규칙 작성\n\n프로젝트의 기본 데이터베이스 및 각 추가 데이터베이스에 대해 만드는 데이터 모델에 맞는 Cloud Firestore Security Rules를 작성하고 관리합니다.\n\n모든 Cloud Firestore Security Rules는 데이터베이스의 문서를 식별하는 match 구문과 이러한 문서에 대한 액세스를 제어하는 allow 표현식으로 구성됩니다.\nservice cloud.firestore {\nmatch /databases/{database}/documents {\nmatch /<some_path>/ {\nallow read, write: if <some_condition>;\n}\n}\n}\n\nCloud Firestore 모바일 또는 웹 클라이언트 라이브러리의 모든 데이터베이스 요청은 데이터를 읽거나 쓰기 전에 보안 규칙에 따라 평가됩니다. 규칙이 지정된 문서 경로 중 일부라도 액세스를 거부하면 전체 요청이 실패합니다.\n\n아래는 기본 규칙 세트의 몇 가지 예입니다. 유효한 규칙이지만 프로덕션 애플리케이션에는 권장되지 않습니다.""
 'Source URL: https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.backupSchedules/list?hl=ko\nTitle: Method: projects.databases.backupSchedules.list\n\nSend feedback\n\nMethod: projects.databases.backupSchedules.list\n\nStay organized with collections\n\nSave and categorize content based on your preferences.\n\nList backup schedules.\n\nHTTP request\nGET https://firestore.googleapis.com/v1/{parent=projects/*/databases/*}/backupSchedulesThe URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| parent | string Required. The parent database. Format is projects/{project}/databases/{database}. |\n\nRequest body\nThe request body must be empty.\n\nResponse body\n\nThe response for FirestoreAdmin.ListBackupSchedules [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.backupSchedules/list#google.firestore.admin.v1.FirestoreAdmin.ListBackupSchedules].\nIf successful, the response body contains data with the following structure:\n\n| JSON representation |\n| --- |\n| {   ""backupSchedules"": [     {       object (BackupSchedule)     }   ] } |'
 '| Fields |\n| --- |\n| parent | string Required. The project to restore the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| backup | string Required. Backup to restore from. Must be from the same project as the parent. The restored database will be created in the same location as the source backup. Format is: projects/{project_id}/locations/{location}/backups/{backup} |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the restored database. If this field is not specified, the restored database will use the same encryption configuration as the backup, namely use_source_encryption. |'
 '| Fields |\n| --- |\n| databaseId | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| backup | string Required. Backup to restore from. Must be from the same project as the parent. The restored database will be created in the same location as the source backup. Format is: projects/{projectId}/locations/{location}/backups/{backup} |\n| encryptionConfig | object (EncryptionConfig) Optional. Encryption configuration for the restored database. If this field is not specified, the restored database will use the same encryption configuration as the backup, namely useSourceEncryption. |'
 '| Fields |\n| --- |\n| parent | string Required. The project to clone the database in. Format is projects/{project_id}. |\n| database_id | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This database ID must not be associated with an existing database. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n| pitr_snapshot | PitrSnapshot Required. Specification of the PITR data to clone from. The source database must exist. The cloned database will be created in the same location as the source database. |\n| encryption_config | EncryptionConfig Optional. Encryption configuration for the cloned database. If this field is not specified, the cloned database will use the same encryption configuration as the source database, namely use_source_encryption. |'
 'Exports a copy of all or a subset of documents from Google Cloud Firestore to another storage system, such as Google Cloud Storage. Recent updates to documents may not be reflected in the export. The export occurs in the background and its progress can be monitored and managed via the Operation resource that is created. The output of an export may only be used once the associated operation is done. If an export operation is cancelled before completion it may leave partial data behind in Google Cloud Storage.For more details on export behavior and output format, refer to: https://cloud.google.com/firestore/docs/manage-data/export-import [https://cloud.google.com/firestore/docs/manage-data/export-import]\n\nHTTP request\nPOST https://firestore.googleapis.com/v1/{name=projects/*/databases/*}:exportDocumentsThe URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| name | string Required. Database to export. Should be of the form: projects/{projectId}/databases/{databaseId}. |\n\nRequest body\nThe request body contains data with the following structure:'
 'Create a database.\n\nHTTP request\nPOST https://firestore.googleapis.com/v1/{parent=projects/*}/databasesThe URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| parent | string Required. A parent name of the form projects/{projectId} |\n\nQuery parameters\n| Parameters |\n| --- |\n| databaseId | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n\nRequest body\nThe request body contains an instance of Database [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases#Database].\n\nResponse body\nIf successful, the response body contains a newly created instance of Operation [https://cloud.google.com/firestore/docs/reference/rest/Shared.Types/Operation].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:'
 'Create a database.\n\nHTTP request\nPOST https://firestore.googleapis.com/v1/{parent=projects/*}/databasesThe URL uses gRPC Transcoding [https://google.aip.dev/127] syntax.\n\nPath parameters\n| Parameters |\n| --- |\n| parent | string Required. A parent name of the form projects/{projectId} |\n\nQuery parameters\n| Parameters |\n| --- |\n| databaseId | string Required. The ID to use for the database, which will become the final component of the database\'s resource name. This value should be 4-63 characters. Valid characters are /[a-z][0-9]-/ with first character a letter and the last a letter or a number. Must not be UUID-like /[0-9a-f]{8}(-[0-9a-f]{4}){3}-[0-9a-f]{12}/. ""(default)"" database ID is also valid if the database is Standard edition. |\n\nRequest body\nThe request body contains an instance of Database [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases#Database].\n\nResponse body\nIf successful, the response body contains a newly created instance of Operation [https://firebase.google.com/docs/firestore/reference/rest/Shared.Types/Operation].\n\nAuthorization scopes\nRequires one of the following OAuth scopes:']","죄송하지만, ""projets.databeses.gte"" 메서드에 대한 정보는 제공된 문서에 없습니다. 따라서 해당 메서드의 HTTP 요청 형식에 대해 답변드릴 수 없습니다. 다른 질문이 있으시면 말씀해 주세요.","HTTP 요청 형식은 다음과 같습니다:
```
GET https://firestore.googleapis.com/v1/{name=projects/*/databases/*}
```"
"Google Developers Console을 활용하여 YouTube Data API를 사용 설정하려면 어떤 절차를 따라야 하며, 첫 번째 단계에서 반드시 수행해야 하는 작업은 무엇입니까?","['YouTube에서 Shorts 동영상의 조회수를 집계하는 방식에 맞게 Data API를 업데이트하고 있습니다. 자세히 알아보기 [https://developers.google.com/youtube/v3/revision_history?hl=ko#march-26,-2025]\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nYouTube [https://developers.google.com/youtube?hl=ko]\nData API [https://developers.google.com/youtube/v3?hl=ko]\n가이드 [https://developers.google.com/youtube/v3/getting-started?hl=ko]\nGo 빠른 시작\nbookmark_border\n이 페이지의 내용\n기본 요건\n1단계: YouTube Data API 사용 설정하기\n2단계: 작업공간 준비하기\n3단계: 샘플 설정\n4단계: 샘플 실행\n메모\n추가 자료\n이 페이지의 나머지 부분에서 설명하는 단계를 완료하면 약 5분 후에 YouTube Data API에 요청을 수행하는 간단한 Go 명령줄 애플리케이션이 생성됩니다.\n이 가이드에 사용된 샘플 코드는 GoogleDevelopers YouTube 채널의 channel 리소스를 검색하고 이 리소스에서 기본 정보를 출력합니다.\n기본 요건\n이 빠른 시작을 실행하려면 다음이 필요합니다.\nGo [https://golang.org/], 최신 버전 권장\nGit [https://git-scm.com/], 최신 버전 권장\n인터넷 및 웹브라우저 액세스\nGoogle 계정\n1단계: YouTube Data API 사용 설정하기\n이 마법사 [https://console.developers.google.com/start/api?id=youtube&hl=ko]를 사용하여 Google Developers Console에서 프로젝트를 만들거나 선택하고 API를 자동으로 사용 설정하세요. 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭합니다.\n사용자 인증 정보 만들기 페이지에서 취소 버튼을 클릭합니다.'
 'YouTube에서 Shorts 동영상의 조회수를 집계하는 방식에 맞게 Data API를 업데이트하고 있습니다. 자세히 알아보기 [https://developers.google.com/youtube/v3/revision_history?hl=ko#march-26,-2025]\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nYouTube [https://developers.google.com/youtube?hl=ko]\nData API [https://developers.google.com/youtube/v3?hl=ko]\n가이드 [https://developers.google.com/youtube/v3/getting-started?hl=ko]\nRuby 빠른 시작\nbookmark_border\n이 페이지의 내용\n기본 요건\n1단계: YouTube Data API 사용 설정하기\n2단계: Google 클라이언트 라이브러리 설치하기\n3단계: 샘플 설정\n4단계: 샘플 실행\n메모\n추가 자료\n이 페이지의 나머지 부분에 설명된 단계를 완료하면 약 5분 후에 YouTube Data API에 요청을 수행하는 간단한 Ruby 명령줄 애플리케이션을 사용할 수 있습니다.\n이 가이드에 사용된 샘플 코드는 GoogleDevelopers YouTube 채널의 channel 리소스를 검색하고 이 리소스에서 기본 정보를 출력합니다.\n기본 요건\n이 빠른 시작을 실행하려면 다음이 필요합니다.\nRuby 2.0 이상\n인터넷 및 웹브라우저 액세스\nGoogle 계정\n1단계: YouTube Data API 사용 설정하기\n이 마법사 [https://console.developers.google.com/start/api?id=youtube&hl=ko]를 사용하여 Google Developers Console에서 프로젝트를 만들거나 선택하고 API를 자동으로 사용 설정하세요. 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭합니다.\n사용자 인증 정보 만들기 페이지에서 취소 버튼을 클릭합니다.'
 'YouTube에서 Shorts 동영상의 조회수를 집계하는 방식에 맞게 Data API를 업데이트하고 있습니다. 자세히 알아보기 [https://developers.google.com/youtube/v3/revision_history?hl=ko#march-26,-2025]\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nYouTube [https://developers.google.com/youtube?hl=ko]\nData API [https://developers.google.com/youtube/v3?hl=ko]\n가이드 [https://developers.google.com/youtube/v3/getting-started?hl=ko]\nNode.js 빠른 시작\nbookmark_border\n이 페이지의 내용\n기본 요건\n1단계: YouTube Data API 사용 설정\n2단계: 클라이언트 라이브러리 설치\n3단계: 샘플 설정\n4단계: 샘플 실행\n참고\n추가 자료\n이 페이지의 나머지 부분에 설명된 단계를 완료하면 약 5분 내에 YouTube Data API를 요청하는 간단한 Node.js 명령줄 애플리케이션이 생성됩니다.\n이 가이드에서 사용된 샘플 코드는 GoogleDevelopers YouTube 채널의 channel 리소스를 가져와 해당 리소스의 일부 기본 정보를 출력합니다.\n기본 요건\n이 빠른 시작을 실행하려면 다음이 필요합니다.\nNode.js가 설치되었습니다.\nnpm [https://www.npmjs.com/] 패키지 관리 도구 (Node.js와 함께 제공됨)\n인터넷 및 웹브라우저 액세스\nGoogle 계정\n1단계: YouTube Data API 사용 설정\n이 마법사 [https://console.developers.google.com/start/api?id=youtube&hl=ko]를 사용하여 Google Developers Console에서 프로젝트를 만들거나 선택하고 API를 자동으로 사용 설정합니다. 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭합니다.'
 'YouTube에서 Shorts 동영상의 조회수를 집계하는 방식에 맞게 Data API를 업데이트하고 있습니다. 자세히 알아보기 [https://developers.google.com/youtube/v3/revision_history?hl=ko#march-26,-2025]\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nYouTube [https://developers.google.com/youtube?hl=ko]\nData API [https://developers.google.com/youtube/v3?hl=ko]\n가이드 [https://developers.google.com/youtube/v3/getting-started?hl=ko]\n동영상 업로드\nbookmark_border\n이 페이지의 내용\n요구사항\n샘플 요청\n스크립트 호출\n샘플 코드\n추가 리소스\n이 가이드에서는 YouTube Data API를 사용하여 YouTube 동영상을 업로드하는 Python 스크립트를 제공하고 설명합니다. 이 코드는 Python용 Google API 클라이언트 라이브러리를 사용합니다. (기타 많이 사용되는 프로그래밍 언어의 클라이언트 라이브러리도 제공됩니다.)\n참고: 샘플 스크립트는 오류를 처리하지 않습니다.\n요구사항\nPython 2.5 이상\nPython용 Google API 클라이언트 라이브러리 [https://developers.google.com/api-client-library/python/start/installation?hl=ko] (google-api-python-client)를 설치합니다.\nOAuth 2.0 [http://oauth.net/2/] 프로토콜을 사용하여 사용자 데이터에 대한 액세스를 승인할 수 있도록 Google에 애플리케이션을 등록 [https://developers.google.com/youtube/registering_an_application?hl=ko]합니다.'
 'YouTube에서 Shorts 동영상의 조회수를 집계하는 방식에 맞게 Data API를 업데이트하고 있습니다. 자세히 알아보기 [https://developers.google.com/youtube/v3/revision_history?hl=ko#march-26,-2025]\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nYouTube [https://developers.google.com/youtube?hl=ko]\nData API [https://developers.google.com/youtube/v3?hl=ko]\n가이드 [https://developers.google.com/youtube/v3/getting-started?hl=ko]\n도움이 되었나요?\nAndroid 빠른 시작\nbookmark_border\n이 페이지의 내용\n기본 요건 [https://developers.google.com/youtube/v3/quickstart/android?hl=ko#prerequisites]\n1단계: SHA1 지문 획득 [https://developers.google.com/youtube/v3/quickstart/android?hl=ko#step_1_acquire_a_sha1_fingerprint]\n2단계: YouTube Data API 사용 설정 [https://developers.google.com/youtube/v3/quickstart/android?hl=ko#step_2_turn_on_the]\n3단계: 새 Android 프로젝트 만들기 [https://developers.google.com/youtube/v3/quickstart/android?hl=ko#step_3_create_a_new_android_project]\n4단계: 프로젝트 준비 [https://developers.google.com/youtube/v3/quickstart/android?hl=ko#step_4_prepare_the_project]'
 ""휴대전화, 태블릿, 기타 기기로 OAuth 2.0 사용\n개발자는 Android 애플리케이션을 작성할 때 Google Play services [http://developer.android.com/google/play-services/index.html?hl=ko]를 활용하여 승인 세부정보를 처리할 수 있습니다. Google Play 서비스는 YouTube 플랫폼용 API를 비롯한 모든 Google API의 표준 승인 흐름 [http://developer.android.com/google/play-services/auth.html?hl=ko]을 제공합니다. 이 접근 방식을 사용하면 ClientLogin를 사용하는 맞춤 인증보다 Android 애플리케이션 사용자에게 훨씬 우수한 사용자 환경을 제공할 수 있습니다.\niOS 기기의 경우 Google은 다음과 같은 2가지 옵션을 제공합니다.\nGoogle 제품의 로그인을 통합하고 소셜 기능을 사용 설정하는 Google+ Platform for iOS [https://developers.google.com/+/mobile/ios/?hl=ko]\n승인 UIWebView를 제공하고 토큰을 관리하는 gtm-oauth2 toolkit [https://github.com/google/gtm-oauth2]\n'보조 화면' 기기 또는 사용하기 쉬운 입력 메커니즘이 없는 TV와 같은 기기의 경우 기기용 OAuth 2.0 [https://developers.google.com/accounts/docs/OAuth2ForDevices?hl=ko]이 권장됩니다. 기기용 OAuth 2.0은 승인 요청이 필요할 때 사용자에게 고유한 코드를 표시하여 작동합니다. 이때 사용자에게 노트북이나 휴대전화와 같은 다른 기기에서 http://google.com/device [http://google.com/device?hl=ko]로 이동하여 고유 코드를 입력하라는 메시지가 표시됩니다. 애플리케이션에서는 다음과 같은 화면을 표시합니다.""
 ""4단계: 프로젝트 준비 [https://developers.google.com/youtube/v3/quickstart/android?hl=ko#step_4_prepare_the_project]\n이 가이드에서는 YouTube Data API에 요청을 보내는 간단한 Android 애플리케이션을 설정하는 방법을 설명합니다.\n참고: 이 빠른 시작에서는 Android 애플리케이션에서 YouTube Data API를 사용하는 방법을 보여줍니다. Data API를 사용하는 많은 애플리케이션은 YouTube Android Player API [https://developers.google.com/youtube/android/player?hl=ko]도 사용합니다. 이 API를 사용하면 Android 애플리케이션에 동영상 재생 기능을 통합할 수 있습니다.\n기본 요건\n이 빠른 시작을 실행하려면 다음이 필요합니다.\nAndroid 스튜디오 SDK 1.2 이상 [https://developer.android.com/sdk/index.html?hl=ko]\nAPI 23 이상의 Android SDK 패키지 [https://developer.android.com/sdk/installing/adding-packages.html?hl=ko](최신 버전의 Google 저장소, Android 지원 라이브러리, Google Play 서비스 포함)\n테스트 기기에서 인터넷에 액세스할 수 있어야 합니다.\nGoogle 계정\n이 빠른 시작에서는 독립형 SDK 도구가 아닌 Android 스튜디오 [https://developer.android.com/tools/studio/index.html?hl=ko] IDE를 사용하고 스튜디오 프로젝트 내에서 파일을 찾고, 만들고, 수정하는 데 익숙하다고 가정합니다.\n1단계: SHA1 지문 획득\n터미널에서 다음 Keytool 유틸리티 [https://developer.android.com/guide/publishing/app-signing.html?hl=ko] 명령어를 실행하여 API를 사용 설정하는 데 사용할 SHA1 지문을 가져옵니다.\nkeytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore -list -v\n키 저장소 비밀번호를 묻는 메시지가 표시되면 'android'를 입력합니다.""
 '4단계: 승인된 요청 실행 [https://developers.google.com/youtube/v3/quickstart/java?hl=ko#step_4_run_an_authorized_request]\n추가 자료 [https://developers.google.com/youtube/v3/quickstart/java?hl=ko#further_reading]\n이 빠른 시작 가이드에서는 YouTube Data API에 요청하는 간단한 자바 명령줄 애플리케이션을 설정하는 방법을 설명합니다. 이 빠른 시작에서는 실제로 두 가지 API 요청을 수행하는 방법을 설명합니다.\n애플리케이션을 식별하는 API 키를 사용하여 GoogleDevelopers YouTube 채널에 대한 정보를 검색합니다.\nOAuth 2.0 클라이언트 ID를 사용하여 YouTube 채널에 대한 정보를 검색하는 승인된 요청을 제출합니다.\n참고: 일반적으로 API 키를 사용하는 모든 사용 사례의 경우 첫 번째 예시의 안내를 따르고 OAuth 2.0을 사용한 승인이 필요한 사용 사례의 경우 두 번째 예시의 안내를 따르면 됩니다. 더 많은 예는 사용 사례 및 코드 샘플 도구 [https://developers.google.com/youtube/v3/code_samples/code_snippets?hl=ko]를 참고하세요.\n기본 요건\n이 빠른 시작을 실행하려면 다음이 필요합니다.\n자바 1.7 이상\nGradle 2.3 이상 [http://gradle.org/downloads].\n인터넷 및 웹브라우저 액세스\nGoogle 계정\n1단계: 프로젝트 및 사용자 인증 정보 설정하기\nAPI 콘솔 [https://console.cloud.google.com/?hl=ko]에서 프로젝트를 만들거나 선택합니다. API 콘솔에서 프로젝트의 다음 작업을 완료합니다.\n라이브러리 패널 [https://console.developers.google.com/apis/library?hl=ko]에서 YouTube Data API v3를 검색합니다. 해당 API의 등록정보를 클릭하고 프로젝트에 API가 사용 설정되어 있는지 확인합니다.\n사용자 인증 정보 패널 [https://console.developers.google.com/apis/credentials?hl=ko]에서 두 개의 사용자 인증 정보를 만듭니다.'
 'YouTube에서 Shorts 동영상의 조회수를 집계하는 방식에 맞게 Data API를 업데이트하고 있습니다. 자세히 알아보기 [https://developers.google.com/youtube/v3/revision_history?hl=ko#march-26,-2025]\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nYouTube [https://developers.google.com/youtube?hl=ko]\nData API [https://developers.google.com/youtube/v3?hl=ko]\n가이드 [https://developers.google.com/youtube/v3/getting-started?hl=ko]\n클라이언트 라이브러리\nbookmark_border\nGoogle API 클라이언트 라이브러리는 여러 프로그래밍 언어로 사용할 수 있으며 YouTube API 구현을 단순화하는 데 크게 도움이 됩니다.\n다음 표에서 첫 번째 열은 각 라이브러리의 개발 단계를 나타내며 (일부 라이브러리는 초기 단계임) 라이브러리의 문서로 연결됩니다. 두 번째 열은 각 라이브러리의 사용 가능한 샘플로 연결됩니다.\n문서 샘플\nJava용 Google API 클라이언트 라이브러리 [https://developers.google.com/api-client-library/java/?hl=ko] 자바 샘플 [https://developers.google.com/api-client-library/java/apis?hl=ko]\n자바스크립트용 Google API 클라이언트 라이브러리 [https://developers.google.com/api-client-library/javascript/start/start-js?hl=ko] 자바스크립트 샘플 [https://developers.google.com/api-client-library/javascript/samples/samples?hl=ko]'
 ""dependencies {\n    compile 'com.google.api-client:google-api-client:1.23.0'\n    compile 'com.google.oauth-client:google-oauth-client-jetty:1.23.0'\n    compile 'com.google.apis:google-api-services-youtube:v3-revREVISION-CL_VERSION'\n}\nbuild.gradle 파일에서 REVISION 및 CL_VERSION 변수를 YouTube Data API에 대한 클라이언트 라이브러리 문서 [https://developers.google.com/resources/api-libraries/documentation/youtube/v3/java/latest/?hl=ko]의 2개 값으로 바꿔야 합니다. YouTube 분석 API 문서를 보여주는 아래 스크린샷에서는 두 변수가 페이지에 표시되는 위치를 보여줍니다.\n3단계: 샘플 설정 및 실행\n측면 패널의 API 탐색기 위젯을 사용하여 GoogleDevelopers YouTube 채널에 대한 정보를 가져오는 샘플 코드를 가져옵니다. 이 요청은 API 키를 사용하여 애플리케이션을 식별하며 사용자 승인이나 샘플을 실행하는 사용자의 특별한 권한이 필요하지 않습니다.\nAPI의 channels.list [https://developers.google.com/youtube/v3/docs/channels/list?hl=ko] 메서드 문서를 엽니다.\n이 페이지의 '일반적인 사용 사례' 섹션에는 메서드가 사용되는 몇 가지 일반적인 방법을 설명하는 표가 있습니다. 표의 첫 번째 목록은 채널 ID별로 결과를 나열하는 것입니다.\n첫 번째 등록정보의 코드 기호를 클릭하여 전체 화면 API 탐색기를 열고 채웁니다.\nFullscreen API Explorer의 왼쪽에는 다음이 표시됩니다.\n요청 매개변수 헤더 아래에 메서드에서 지원하는 매개변수 목록이 있습니다. part 및 id 매개변수 값을 설정해야 합니다. id 매개변수 값인 UC_x5XG1OV2P6uZZ5FSM9Ttw는 GoogleDevelopers YouTube 채널의 ID입니다.""
 'YouTube에서 Shorts 동영상의 조회수를 집계하는 방식에 맞게 Data API를 업데이트하고 있습니다. 자세히 알아보기 [https://developers.google.com/youtube/v3/revision_history?hl=ko#march-26,-2025]\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nYouTube [https://developers.google.com/youtube?hl=ko]\nData API [https://developers.google.com/youtube/v3?hl=ko]\n가이드 [https://developers.google.com/youtube/v3/getting-started?hl=ko]\n자바스크립트 빠른 시작\nbookmark_border\n이 페이지의 내용\n기본 요건\n1단계: 프로젝트 및 사용자 인증 정보 설정하기\n2단계: 샘플 설정 및 실행\n3단계: 승인된 요청 실행\n추가 자료\n이 빠른 시작 가이드에서는 YouTube Data API에 요청하는 간단한 페이지를 설정하는 방법을 설명합니다. 이 빠른 시작에서는 실제로 두 가지 API 요청을 수행하는 방법을 설명합니다.\n애플리케이션을 식별하는 API 키를 사용하여 GoogleDevelopers YouTube 채널에 대한 정보를 검색합니다.\nOAuth 2.0 클라이언트 ID를 사용하여 YouTube 채널에 대한 정보를 검색하는 승인된 요청을 제출합니다.\n참고: 일반적으로 API 키를 사용하는 모든 사용 사례의 경우 첫 번째 예시의 안내를 따르고 OAuth 2.0을 사용한 승인이 필요한 사용 사례의 경우 두 번째 예시의 안내를 따르면 됩니다. 더 많은 예는 사용 사례 및 코드 샘플 도구 [https://developers.google.com/youtube/v3/code_samples/code_snippets?hl=ko]를 참고하세요.\n기본 요건\n이 빠른 시작을 실행하려면 다음이 필요합니다.\nPython 2.4 이상 (웹 서버 제공용)\n인터넷 및 웹브라우저 액세스\nGoogle 계정'
 'YouTube에서 Shorts 동영상의 조회수를 집계하는 방식에 맞게 Data API를 업데이트하고 있습니다. 자세히 알아보기 [https://developers.google.com/youtube/v3/revision_history?hl=ko#march-26,-2025]\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\n제품 [https://developers.google.com/products?hl=ko]\nYouTube [https://developers.google.com/youtube?hl=ko]\nData API [https://developers.google.com/youtube/v3?hl=ko]\n가이드 [https://developers.google.com/youtube/v3/getting-started?hl=ko]\nPython 빠른 시작\nbookmark_border\n이 페이지의 내용\n기본 요건\n1단계: 프로젝트 및 사용자 인증 정보 설정하기\n2단계: 샘플 설정 및 실행\n3단계: 승인된 요청 실행\n추가 자료\n이 빠른 시작 가이드에서는 YouTube Data API에 요청하는 간단한 Python 명령줄 애플리케이션을 설정하는 방법을 설명합니다. 이 빠른 시작에서는 실제로 두 가지 API 요청을 수행하는 방법을 설명합니다.\n애플리케이션을 식별하는 API 키를 사용하여 GoogleDevelopers YouTube 채널에 대한 정보를 검색합니다.\nOAuth 2.0 클라이언트 ID를 사용하여 YouTube 채널에 대한 정보를 검색하는 승인된 요청을 제출합니다.\n참고: 일반적으로 API 키를 사용하는 모든 사용 사례의 경우 첫 번째 예시의 안내를 따르고 OAuth 2.0을 사용한 승인이 필요한 사용 사례의 경우 두 번째 예시의 안내를 따르면 됩니다. 더 많은 예는 사용 사례 및 코드 샘플 도구 [https://developers.google.com/youtube/v3/code_samples/code_snippets?hl=ko]를 참고하세요.\n기본 요건\n이 빠른 시작을 실행하려면 다음이 필요합니다.\nPython 2.7 또는 Python 3.5 이상\npip 패키지 관리 도구'
 ""If you are not using a client library, you need to set the access_type HTTP query parameter to offline when redirecting the user to Google's OAuth 2.0 server [https://developers.google.com/youtube/v3/guides/auth/server-side-web-apps?hl=ko#redirecting]. In that case, Google's authorization server returns a refresh token when you exchange an authorization code [https://developers.google.com/youtube/v3/guides/auth/server-side-web-apps?hl=ko#exchange-authorization-code] for an access token. Then, if the access token expires (or at any other time), you can use a refresh token to obtain a new access token.\nRequesting offline access is a requirement for any application that needs to access a Google API when the user is not present. For example, an app that performs backup services or executes actions at predetermined times needs to be able to refresh its access token when the user is not present. The default style of access is called online.\nServer-side web applications, installed applications, and devices all obtain refresh tokens during the authorization process. Refresh tokens are not typically used in client-side (JavaScript) web applications.\n--- 탭: PHP ---""
 ""if __name__ == '__main__':\n  # When running locally, disable OAuthlib's HTTPs verification.\n  # ACTION ITEM for developers:\n  #     When running in production *do not* leave this option enabled.\n  os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'\n\n  # This disables the requested scopes and granted scopes check.\n  # If users only grant partial request, the warning would not be thrown.\n  os.environ['OAUTHLIB_RELAX_TOKEN_SCOPE'] = '1'\n\n  # Specify a hostname and port that are set as a valid redirect URI\n  # for your API project in the Google API Console.\n  app.run('localhost', 8080, debug=True)\n\n--- 탭: Ruby ---\n이 예시에서는 Sinatra [http://www.sinatrarb.com/] 프레임워크를 사용합니다.\n\nrequire 'googleauth'\nrequire 'googleauth/web_user_authorizer'\nrequire 'googleauth/stores/redis_token_store'\n\nrequire 'google/apis/youtube_v3'\n\nrequire 'sinatra'\n\nconfigure do\n  enable :sessions\n\n  # Required, call the from_file method to retrieve the client ID from a\n  # client_secret.json file.\n  set :client_id, Google::Auth::ClientId.from_file('/path/to/client_secret.json')""
 'mProgress = new ProgressDialog(this);\n        mProgress.setMessage(""Calling YouTube Data API ..."");\n\n        setContentView(activityLayout);\n\n        // Initialize credentials and service object.\n        mCredential = GoogleAccountCredential.usingOAuth2(\n                getApplicationContext(), Arrays.asList(SCOPES))\n                .setBackOff(new ExponentialBackOff());\n    }\n\n    \n\n    /**\n     * Attempt to call the API, after verifying that all the preconditions are\n     * satisfied. The preconditions are: Google Play Services installed, an\n     * account was selected and the device currently has online access. If any\n     * of the preconditions are not satisfied, the app will prompt the user as\n     * appropriate.\n     */\n    private void getResultsFromApi() {\n        if (! isGooglePlayServicesAvailable()) {\n            acquireGooglePlayServices();\n        } else if (mCredential.getSelectedAccountName() == null) {\n            chooseAccount();\n        } else if (! isDeviceOnline()) {\n            mOutputText.setText(""No network connection available."");\n        } else {\n            new MakeRequestTask(mCredential).execute();\n        }\n    }'
 'if credentials.nil?\n    # Generate a url that asks the user to authorize requested scope(s).\n    # Then, redirect user to the url.\n    redirect settings.authorizer.get_authorization_url(request: request)\n  end\n  \n  # User authorized read-only YouTube Data API permission.\n  # Example of using YouTube Data API to list user\'s YouTube channel\n  youtube = Google::Apis::YoutubeV3::YouTubeService.new\n  channel = youtube.list_channels(part, :mine => mine, options: { authorization: auth_client })\n  \n  ""<pre>#{JSON.pretty_generate(channel.to_h)}</pre>""\nend\n\n# Receive the callback from Google\'s OAuth 2.0 server.\nget \'/oauth2callback\' do\n  # Handle the result of the oauth callback. Defers the exchange of the code by\n  # temporarily stashing the results in the user\'s session.\n  target_url = Google::Auth::WebUserAuthorizer.handle_auth_callback_deferred(request)\n  redirect target_url\nend\n\n--- 탭: Node.js ---\n이 예시를 실행하려면 다음 안내를 따르세요.'
 'def print_index_table():\n  return (\'<table>\' +\n          \'<tr><td><a href=""/test"">Test an API request</a></td>\' +\n          \'<td>Submit an API request and see a formatted JSON response. \' +\n          \'    Go through the authorization flow if there are no stored \' +\n          \'    credentials for the user.</td></tr>\' +\n          \'<tr><td><a href=""/authorize"">Test the auth flow directly</a></td>\' +\n          \'<td>Go directly to the authorization flow. If there are stored \' +\n          \'    credentials, you still might not be prompted to reauthorize \' +\n          \'    the application.</td></tr>\' +\n          \'<tr><td><a href=""/revoke"">Revoke current credentials</a></td>\' +\n          \'<td>Revoke the access token associated with the current user \' +\n          \'    session. After revoking credentials, if you go to the test \' +\n          \'    page, you should see an <code>invalid_grant</code> error.\' +\n          \'</td></tr>\' +\n          \'<tr><td><a href=""/clear"">Clear Flask session credentials</a></td>\' +\n          \'<td>Clear the access token currently stored in the user session. \' +\n          \'    After clearing the token, if you <a href=""/test"">test the \' +'
 '/**\n     * Display an error dialog showing that Google Play Services is missing\n     * or out of date.\n     * @param connectionStatusCode code describing the presence (or lack of)\n     *     Google Play Services on this device.\n     */\n    void showGooglePlayServicesAvailabilityErrorDialog(\n            final int connectionStatusCode) {\n        GoogleApiAvailability apiAvailability = GoogleApiAvailability.getInstance();\n        Dialog dialog = apiAvailability.getErrorDialog(\n                MainActivity.this,\n                connectionStatusCode,\n                REQUEST_GOOGLE_PLAY_SERVICES);\n        dialog.show();\n    }\n\n    /**\n     * An asynchronous task that handles the YouTube Data API call.\n     * Placing the API calls in their own task ensures the UI stays responsive.\n     */\n    private class MakeRequestTask extends AsyncTask<Void, Void, List<String>> {\n        private com.google.api.services.youtube.YouTube mService = null;\n        private Exception mLastError = null;'
 '# Call the API\'s videos.insert method to create and upload the video.\n  insert_request = youtube.videos().insert(\n    part="","".join(body.keys()),\n    body=body,\n    # The chunksize parameter specifies the size of each chunk of data, in\n    # bytes, that will be uploaded at a time. Set a higher value for\n    # reliable connections as fewer chunks lead to faster uploads. Set a lower\n    # value for better recovery on less reliable connections.\n    #\n    # Setting ""chunksize"" equal to -1 in the code below means that the entire\n    # file will be uploaded in a single HTTP request. (If the upload fails,\n    # it will still be retried where it left off.) This is usually a best\n    # practice, but if you\'re using Python older than 2.6 or if you\'re\n    # running on App Engine, you should set the chunksize to something like\n    # 1024 * 1024 (1 megabyte).\n    media_body=MediaFileUpload(options.file, chunksize=-1, resumable=True)\n  )\n\n  resumable_upload(insert_request)'
 ""# Required, scope value\n  # Access scopes for retrieving data about the user's YouTube channel.\n  scope = 'Google::Apis::YoutubeV3::AUTH_YOUTUBE_FORCE_SSL'\n\n  # Required, Authorizers require a storage instance to manage long term persistence of\n  # access and refresh tokens.\n  set :token_store, Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\n\n  # Required, indicate where the API server will redirect the user after the user completes\n  # the authorization flow. The redirect URI is required. The value must exactly\n  # match one of the authorized redirect URIs for the OAuth 2.0 client, which you\n  # configured in the API Console. If this value doesn't match an authorized URI,\n  # you will get a 'redirect_uri_mismatch' error.\n  set :callback_uri, '/oauth2callback'""
 ""require 'googleauth'\nrequire 'googleauth/web_user_authorizer'\nrequire 'googleauth/stores/redis_token_store'\n\nrequire 'google/apis/youtube_v3'\n\n# Required, call the from_file method to retrieve the client ID from a\n# client_secret.json file.\nclient_id = Google::Auth::ClientId.from_file('/path/to/client_secret.json')\n\n# Required, scope value \nscope = 'https://www.googleapis.com/auth/youtube.force-ssl'\n\n# Required, Authorizers require a storage instance to manage long term persistence of\n# access and refresh tokens.\ntoken_store = Google::Auth::Stores::RedisTokenStore.new(redis: Redis.new)\n\n# Required, indicate where the API server will redirect the user after the user completes\n# the authorization flow. The redirect URI is required. The value must exactly\n# match one of the authorized redirect URIs for the OAuth 2.0 client, which you\n# configured in the API Console. If this value doesn't match an authorized URI,\n# you will get a 'redirect_uri_mismatch' error.\ncallback_uri = '/oauth2callback'""
 'Q: YouTube Data API를 사용 설정하는 방법은 무엇인가요?\nA: 이 마법사 [https://console.developers.google.com/start/api?id=youtube&hl=ko]를 사용하여 Google Developers Console에서 프로젝트를 만들거나 선택하고 API를 자동으로 사용 설정하세요. 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭합니다.'
 'Q: YouTube Data API를 사용 설정하는 방법은 무엇인가요?\nA: YouTube Data API를 사용 설정하려면 Google Developers Console에서 프로젝트를 만들거나 선택하고 API를 자동으로 사용 설정하는 마법사를 사용해야 합니다. 이후 사용자 인증 정보로 이동하여 OAuth 동의 화면을 설정하고, 사용자 인증 정보를 생성하여 OAuth 클라이언트 ID를 만들어야 합니다.'
 'Q: YouTube Data API를 사용 설정하기 위한 첫 번째 단계는 무엇인가요?\nA: 이 마법사 (https://console.developers.google.com/start/api?id=youtube&hl=ko)를 사용하여 Google Developers Console에서 프로젝트를 만들거나 선택하고 API를 자동으로 사용 설정하세요. 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭합니다.'
 'Q: YouTube Data API를 사용 설정하는 첫 번째 단계는 무엇인가요?\nA: 이 마법사를 사용하여 Google Developers Console에서 프로젝트를 만들거나 선택하고 API를 자동으로 사용 설정하세요. 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭합니다.'
 'Q: YouTube Data API를 사용 설정하기 위한 첫 번째 단계는 무엇인가요?\nA: Google Developers Console에서 프로젝트를 만들거나 선택하고 API를 자동으로 사용 설정하는 마법사를 사용합니다. 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭합니다.'
 'Q: Google API를 호출하는 애플리케이션에서 API를 사용 설정하는 방법은 무엇인가요?\nA: Google API를 호출하는 애플리케이션은 API Console에서 해당 API를 사용 설정해야 합니다. 프로젝트에서 API를 사용 설정하려면 Google API Console에서 API Library를 열고, YouTube Data API를 찾아 사용 설정합니다.'
 'Q: Google API Console에서 YouTube Data API를 사용 설정하는 방법은 무엇인가요?\nA: Google API Console에서 YouTube Data API를 사용 설정하려면 다음 단계를 따르세요.\n1. Google API Console에서 API Library를 엽니다.\n2. 프로젝트를 선택하거나 새 프로젝트를 만듭니다.\n3. 라이브러리 페이지를 사용하여 YouTube Data API를 찾아 사용 설정합니다.'
 'Q: YouTube Data API를 사용하기 위해 API를 사용 설정하는 방법은 무엇인가요?\nA: YouTube Data API를 사용하기 위해서는 Google API Console에서 해당 API를 사용 설정해야 합니다. 다음 단계를 따르세요:\n1. Google API Console에서 API Library를 엽니다.\n2. 프로젝트를 선택하거나 새 프로젝트를 만듭니다.\n3. 라이브러리 페이지를 사용하여 YouTube Data API를 찾아 사용 설정합니다.'
 'Q: Google API를 호출하는 애플리케이션에서 API를 사용 설정하는 방법은 무엇인가요?\nA: Google API를 호출하는 애플리케이션은 API Console에서 해당 API를 사용 설정해야 합니다. 프로젝트에서 API를 사용 설정하려면 다음 단계를 따르세요: Google API Console에서 Open the API Library을 사용합니다. If prompted, select a project, or create a new one. 라이브러리 페이지를 사용하여 YouTube Data API를 찾아 사용 설정합니다.'
 'Q: YouTube Data API를 사용하기 위해 API를 사용 설정하는 방법은 무엇인가요?\nA: Google API를 호출하는 애플리케이션은 API Console에서 해당 API를 사용 설정해야 합니다. 프로젝트에서 API를 사용 설정하려면 다음 단계를 따르세요.\n1. Google API Console에서 Open the API Library을 사용합니다.\n2. If prompted, select a project, or create a new one.\n3. 라이브러리 페이지를 사용하여 YouTube Data API를 찾아 사용 설정합니다. 애플리케이션에서 사용할 다른 API를 찾아 사용 설정합니다.'
 'Q: Google API를 호출하는 애플리케이션에서 API를 사용 설정하는 방법은 무엇인가요?\nA: Google API를 호출하는 애플리케이션은 API Console에서 해당 API를 사용 설정해야 합니다. 이를 위해 다음 단계를 따르세요: 1. Google API Console에서 API Library를 엽니다. 2. 프롬프트가 표시되면 프로젝트를 선택하거나 새 프로젝트를 생성합니다. 3. 라이브러리 페이지에서 YouTube Data API를 찾아 사용 설정합니다. 4. 애플리케이션에서 사용할 다른 API를 찾아 사용 설정합니다.'
 'Q: YouTube Data API를 사용하기 위해 프로젝트에서 API를 사용 설정하는 방법은 무엇인가요?\nA: 프로젝트에서 API를 사용 설정하려면 다음 단계를 따르세요.\n1. Google API Console에서 Open the API Library을 사용합니다.\n2. If prompted, select a project, or create a new one.\n3. 라이브러리 페이지를 사용하여 YouTube Data API를 찾아 사용 설정합니다. 애플리케이션에서 사용할 다른 API를 찾아 사용 설정합니다.'
 'Q: YouTube Data API를 사용하기 위해 필요한 첫 번째 단계는 무엇인가요?\nA: YouTube Data API를 사용하기 위해서는 Google 계정이 필요하며, Google Developers Console에서 프로젝트를 만들고 API 키를 요청해야 합니다.'
 'Q: OAuth 2.0을 사용하여 YouTube Data API에 접근하기 위해 필요한 기본 요건은 무엇인가요?\nA: Google API를 호출하는 애플리케이션은 API Console에서 해당 API를 사용 설정해야 합니다. 프로젝트에서 API를 사용 설정하려면 Google API Console에서 API Library를 열고, YouTube Data API를 찾아 사용 설정해야 합니다.'
 'Q: Android 애플리케이션에서 OAuth 2.0 인증을 처리하는 방법은 무엇인가요?\nA: Android 애플리케이션을 작성할 때 Google Play services를 활용하여 승인 세부정보를 처리할 수 있습니다. Google Play 서비스는 YouTube 플랫폼용 API를 비롯한 모든 Google API의 표준 승인 흐름을 제공합니다.'
 'Q: YouTube Data API를 사용하기 위해 클라이언트 비밀 파일(client_secret.json)을 어떻게 설정하나요?\nA: 클라이언트 비밀 파일(client_secret.json)을 설정하려면, Google Developers Console에서 클라이언트 ID 오른쪽에 있는 file_download(JSON 다운로드) 버튼을 클릭하여 파일을 다운로드한 후, 작업 디렉터리로 이동하고 이름을 client_secret.json으로 바꿉니다.'
 'Q: API 콘솔에서 YouTube Data API v3를 사용 설정하는 방법은 무엇인가요?\nA: API 콘솔에서 프로젝트의 라이브러리 패널에서 YouTube Data API v3를 검색하고 해당 API의 등록정보를 클릭하여 프로젝트에 API가 사용 설정되어 있는지 확인합니다.'
 'Q: YouTube Data API v3를 프로젝트에 사용 설정하는 방법은 무엇인가요?\nA: API 콘솔에서 프로젝트를 만들거나 선택한 후, 라이브러리 패널 [https://console.developers.google.com/apis/library?hl=ko]에서 YouTube Data API v3를 검색하고 해당 API의 등록정보를 클릭하여 프로젝트에 API가 사용 설정되어 있는지 확인합니다.'
 'Q: API 콘솔에서 YouTube Data API v3를 사용 설정하는 방법은 무엇인가요?\nA: API 콘솔에서 프로젝트를 만들거나 선택한 후, 라이브러리 패널에서 YouTube Data API v3를 검색하고 해당 API의 등록정보를 클릭하여 프로젝트에 API가 사용 설정되어 있는지 확인해야 합니다.'
 'Q: API 콘솔에서 YouTube Data API v3를 사용 설정하는 방법은 무엇인가요?\nA: API 콘솔에서 프로젝트의 다음 작업을 완료합니다.\n1. 라이브러리 패널에서 YouTube Data API v3를 검색합니다.\n2. 해당 API의 등록정보를 클릭하고 프로젝트에 API가 사용 설정되어 있는지 확인합니다.'
 'Q: YouTube Data API를 처음 실행할 때 어떤 절차를 따라야 하나요?\nA: YouTube Data API를 처음 실행할 때는 다음 절차를 따라야 합니다:\n1. 샘플을 실행하면 액세스를 승인하라는 메시지가 표시됩니다.\n2. 웹브라우저에서 제공된 URL로 이동합니다.\n3. Google 계정에 로그인합니다.\n4. 수락 버튼을 클릭합니다.\n5. 표시된 코드를 복사하여 명령줄 프롬프트에 붙여넣고 Enter 키를 누릅니다.'
 'Q: OAuth 2.0 흐름에서 사용자의 동의를 얻기 위해 애플리케이션이 수행해야 하는 첫 번째 단계는 무엇인가요?\nA: 애플리케이션이 사용자의 동의를 얻기 위해 수행해야 하는 첫 번째 단계는 사용자를 Google의 OAuth 2.0 서버로 리디렉션하는 것입니다. 이를 통해 사용자 데이터에 액세스할 권한을 요청합니다.'
 'Q: 악성 동영상을 신고하기 위해 어떤 첫 번째 단계를 수행해야 하나요?\nA: 악성 동영상을 신고하기 위해 videoAbuseReportReasons.list 메서드에 승인된 요청을 전송하여 동영상을 신고하는 유효한 이유 목록을 가져와야 합니다.'
 'Q: YouTube Data API v3를 사용하기 위해 API 콘솔에서 어떤 작업을 수행해야 하나요?\nA: API 콘솔에서 프로젝트를 만들거나 선택한 후, 라이브러리 패널에서 YouTube Data API v3를 검색하고 해당 API의 등록정보를 클릭하여 프로젝트에 API가 사용 설정되어 있는지 확인해야 합니다.'
 'Q: YouTube Data API (v3)를 사용하기 위해 필요한 첫 번째 단계는 무엇인가요?\nA: 애플리케이션에서 YouTube Data API를 사용하려면 먼저 승인 사용자 인증 정보를 획득해야 합니다.'
 'Q: 재생목록을 삭제하기 위해 필요한 첫 번째 단계는 무엇인가요?\nA: 재생목록을 삭제하기 위해서는 먼저 playlists.list 메서드를 호출하여 현재 인증된 사용자의 채널에 있는 재생목록을 가져와야 합니다. 이 단계에서 재생목록 ID를 확보해야 합니다.'
 'Q: OAuth 2.0 흐름에서 사용자가 승인한 후 애플리케이션이 수행해야 할 작업은 무엇인가요?\nA: 이 단계에서는 액세스 권한이 부여되었는지 여부를 나타내는 Google의 OAuth 2.0 서버의 응답을 기다리므로 애플리케이션에서 아무것도 하지 않아도 됩니다.'
 'Q: 재생목록의 공개 범위를 업데이트하기 위해 필요한 첫 번째 단계는 무엇인가요?\nA: 재생목록의 공개 범위를 업데이트하기 위해서는 먼저 playlists.list 메서드를 호출하여 현재 인증된 사용자의 채널에 있는 재생목록을 가져와야 합니다. 이 단계에서 각 재생목록의 ID를 확인할 수 있습니다.'
 ""Q: Google Apps Script에서 스프레드시트의 첫 번째 행에 헤더를 추가하는 조건은 무엇인가요?\nA: 스프레드시트의 첫 번째 행에 헤더를 추가하는 조건은 첫 번째 셀의 값이 'ID'가 아닐 때입니다. 이 조건은 `if (firstCell != 'ID')`로 확인합니다.""
 'Q: YouTube Data API에서 OAuth 2.0 승인을 구현하기 위해 필요한 첫 번째 단계는 무엇인가요?\nA: OAuth 2.0 승인을 사용하려면 Google API Console에서 승인 사용자 인증 정보를 가져와야 합니다.'
 'Q: YouTube Data API에서 삽입, 업데이트 및 삭제 요청을 할 때 반드시 필요한 것은 무엇인가요?\nA: 모든 삽입, 업데이트 및 삭제 요청 시에는 반드시 인증 토큰을 전송해야 합니다. 또한 인증된 사용자의 비공개 데이터를 검색하는 모든 요청 시에도 인증 토큰을 전송해야 합니다.'
 'Q: 업로드를 재개하기 위한 요청의 첫 번째 바이트는 어떻게 결정하나요?\nA: 재개된 업로드에서 업로드되는 첫 번째 바이트는 이미 YouTube에 성공적으로 업로드된 마지막 바이트 다음에 오는 바이트여야 합니다. 예를 들어, Range 헤더의 마지막 바이트가 999999이면 업로드를 재개하기 위한 요청의 첫 번째 바이트는 바이트 1000000이어야 합니다.'
 'Q: 재개 가능한 업로드에서 업로드되는 첫 번째 바이트는 어떻게 결정되나요?\nA: 재개 가능한 업로드에서 업로드되는 첫 번째 바이트는 이미 YouTube에 성공적으로 업로드된 마지막 바이트 다음에 오는 바이트여야 합니다. 예를 들어 Range 헤더의 마지막 바이트가 999999이면 업로드를 재개하기 위한 요청의 첫 번째 바이트는 바이트 1000000이어야 합니다.'
 'Q: 재생목록에 동영상을 추가하기 위해 필요한 첫 번째 단계는 무엇인가요?\nA: 재생목록에 동영상을 추가하기 위해 필요한 첫 번째 단계는 playlists.list 메서드를 호출하여 현재 인증된 사용자의 채널에 있는 재생목록을 가져오는 것입니다.'
 'Q: 재생목록 항목을 업데이트하기 위해 필요한 첫 번째 단계는 무엇인가요?\nA: 재생목록 항목을 업데이트하기 위해 필요한 첫 번째 단계는 playlists.list 메서드를 호출하여 현재 인증된 사용자의 채널에 있는 재생목록을 가져오는 것입니다.'
 'Q: OAuth 2.0 승인 요청을 만들기 위한 첫 번째 단계는 무엇인가요?\nA: 첫 번째 단계는 승인 요청을 만드는 것입니다. 이 요청은 애플리케이션을 식별하고 사용자에게 애플리케이션에 부여하도록 요청할 권한을 정의하는 매개변수를 설정합니다.'
 ""Q: Node.js에서 사용자가 부여한 범위를 확인하는 방법은 무엇인가요?\nA: // User authorized the request. Now, check which scopes were granted.\nif (tokens.scope.includes('https://www.googleapis.com/auth/youtube.force-ssl'))\n{\n  // User authorized permission to see, edit, and permanently delete the\n  // YouTube videos, ratings, comments and captions.\n  // Calling the APIs, etc.\n}\nelse\n{\n  // User didn't authorize read-only Drive activity permission.\n  // Update UX and application accordingly\n}""
 ""Q: Python에서 OAuth 2.0 승인 요청을 구성하는 방법은 무엇인가요?\nA: 다음 코드 스니펫은 google-auth-oauthlib.flow 모듈을 사용하여 승인 요청을 구성합니다.\n\n```python\nimport google.oauth2.credentials\nimport google_auth_oauthlib.flow\n\n# Required, call the from_client_secrets_file method to retrieve the client ID from a\n# client_secret.json file. The client ID (from that file) and access scopes are required. (You can\n# also use the from_client_config method, which passes the client configuration as it originally\n# appeared in a client secrets file but doesn't access the file itself.)\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file('client_secret.json',\n    scopes=['https://www.googleapis.com/auth/youtube.force-ssl'])\n\n# Required, indicate where the API server will redirect the user after the user completes\n# the authorization flow. The redirect URI is required. The value must exactly\n# match one of the authorized redirect URIs for the OAuth 2.0 client, which you\n# configured in the API Console. If this value doesn't match an authorized URI,\n# you will get a 'redirect_uri_mismatch' error.\nflow.redirect_uri = 'https://www.example.com/oauth2callback'\n\n# Generate URL for request to Google's OAuth 2.0 server.\n# Use kwargs to set optional request parameters.\nauthorization_url, state = flow.authorization_url(\n    # Recommended, enable offline access so that you can refresh an access token without\n    # re-prompting the user for permission. Recommended for web server apps.\n    access_type='offline',\n    # Optional, enable incremental authorization. Recommended as a best practice.\n    include_granted_scopes='true',\n    # Optional, if your application knows which user is trying to authenticate, it can use this\n    # parameter to provide a hint to the Google Authentication\n)\n```""
 'Q: PHP에서 OAuth 2.0 승인 요청의 매개변수를 설정하는 방법은 무엇인가요?\nA: 다음 코드 스니펫은 승인 요청의 매개변수를 정의하는 Google\\Client() 객체를 만듭니다.\n\n```php\nuse Google\\Client;\n\n$client = new Client();\n\n// Required, call the setAuthConfig function to load authorization credentials from\n// client_secret.json file.\n$client->setAuthConfig(\'client_secret.json\');\n\n// Required, to set the scope value, call the addScope function\n$client->addScope(GOOGLE_SERVICE_YOUTUBE::YOUTUBE_FORCE_SSL);\n\n// Required, call the setRedirectUri function to specify a valid redirect URI for the\n// provided client_id\n$client->setRedirectUri(\'http://\' . $_SERVER[\'HTTP_HOST\'] . \'/oauth2callback.php\');\n\n// Recommended, offline access will give you both an access and refresh token so that\n// your app can refresh the access token without user interaction.\n$client->setAccessType(\'offline\');\n\n// Recommended, call the setState function. Using a state value can increase your assurance that\n// an incoming connection is the result of an authentication request.\n$client->setState($sample_passthrough_value);\n\n// Optional, if your application knows which user is trying to authenticate, it can use this\n// parameter to provide a hint to the Google Authentication Server.\n$client->setLoginHint(\'hint@example.com\');\n\n// Optional, call the setPrompt function to set ""consent"" will prompt the user for consent\n$client->setPrompt(\'consent\');\n\n// Optional, call the setIncludeGrantedScopes function with true to enable incremental\n// authorization\n$client->setIncludeGrantedScopes(true);\n```'
 ""Q: Ruby에서 사용자가 부여한 범위를 확인하는 방법은 무엇인가요?\nA: # User authorized the request. Now, check which scopes were granted.\nif credentials.scope.include?(Google::Apis::YoutubeV3::AUTH_YOUTUBE_FORCE_SSL)\n  # User authorized permission to see, edit, and permanently delete the\n  # YouTube videos, ratings, comments and captions.\n  # Calling the APIs, etc\nelse\n  # User didn't authorize the permission.\n  # Update UX and application accordingly\nend""
 ""Q: JavaScript에서 액세스 토큰을 취소하기 위한 요청을 어떻게 구성하나요?\nA: 다음 JavaScript 스니펫은 JavaScript용 Google API 클라이언트 라이브러리를 사용하지 않고 JavaScript에서 토큰을 취소하는 방법을 보여줍니다. 토큰을 취소하기 위한 Google의 OAuth 2.0 엔드포인트는 교차 출처 리소스 공유 (CORS)를 지원하지 않으므로 코드는 XMLHttpRequest() 메서드를 사용하여 요청을 게시하는 대신 양식을 만들어 엔드포인트에 양식을 제출합니다.\n\n```javascript\nfunction revokeAccess(accessToken) {\n  // Google's OAuth 2.0 endpoint for revoking access tokens.\n  var revokeTokenEndpoint = 'https://oauth2.googleapis.com/revoke';\n\n  // Create <form> element to use to POST data to the OAuth 2.0 endpoint.\n  var form = document.createElement('form');\n  form.setAttribute('method', 'post');\n  form.setAttribute('action', revokeTokenEndpoint);\n\n  // Add access token to the form so it is set as value of 'token' parameter.\n  // This corresponds to the sample curl request, where the URL is:\n  //      https://oauth2.googleapis.com/revoke?token={token}\n  var tokenField = document.createElement('input');\n  tokenField.setAttribute('type', 'hidden');\n  tokenField.setAttribute('name', 'token');\n  tokenField.setAttribute('value', accessToken);\n  form.appendChild(tokenField);\n\n  // Add form to page and submit it to actually revoke the token.\n  document.body.appendChild(form);\n  form.submit();\n}\n```\n참고: 취소 응답이 성공한 후 취소가 완전히 적용되기까지 시간이 걸릴 수 있습니다.""
 ""Q: PHP에서 OAuth 2.0 승인 요청의 매개변수를 정의하는 방법은 무엇인가요?\nA: 다음 코드는 승인 요청의 매개변수를 정의하는 Google\\Client() 객체를 만듭니다. 이 객체는 client_secret.json 파일의 정보를 사용하여 애플리케이션을 식별합니다. 이 객체는 애플리케이션이 액세스 권한을 요청하는 범위와 Google OAuth 2.0 서버의 응답을 처리하는 애플리케이션 인증 엔드포인트의 URL도 식별합니다. 마지막으로 코드는 선택적 access_type 및 include_granted_scopes 매개변수를 설정합니다.\n\n```php\nuse Google\\Client;\n\n$client = new Client();\n\n// Required, call the setAuthConfig function to load authorization credentials from\n// client_secret.json file.\n$client->setAuthConfig('client_secret.json');\n\n// Required, to set the scope value, call the addScope function\n$client->addScope(GOOGLE_SERVICE_YOUTUBE::YOUTUBE_FORCE_SSL);\n\n// Required, call the setRedirectUri function to specify a valid redirect URI for the\n// provided client_id\n$client->setRedirectUri('http://' . $_SERVER['HTTP_HOST'] . '/oauth2callback.php');\n\n// Recommended, offline access will give you both an access and refresh token so that\n// your app can refresh the access token without user interaction.\n$client->\n```""
 'Q: 동영상 업로드를 위한 스크립트에서 비디오 파일의 유효성을 어떻게 확인하나요?\nA: 비디오 파일의 유효성은 다음과 같이 확인합니다: \n```python\nif not os.path.exists(args.file):\n    exit(""Please specify a valid file using the --file= parameter."")\n```'
 ""Q: Ruby 언어에서 채널 구독을 추가하는 방법은 무엇인가요?\nA: Ruby 언어에서 채널 구독을 추가하려면 `subscriptions.insert` 메서드를 사용해야 합니다. 아래는 채널 구독을 추가하는 코드 샘플입니다.\n\n```ruby\n# Create a subscription\nsubscription = Google::Apis::YoutubeV3::Subscription.new(\n  snippet: Google::Apis::YoutubeV3::SubscriptionSnippet.new(\n    resource_id: Google::Apis::YoutubeV3::ResourceId.new(\n      kind: 'youtube#channel',\n      channel_id: 'CHANNEL_ID'\n    )\n  )\n)\n\n# Call the API to insert the subscription\nresponse = youtube.subscriptions.insert(subscription, 'snippet')\n```""
 'Q: Node.js에서 프로그래매틱 방식으로 토큰을 취소하는 방법은 무엇인가요?\nA: 프로그래매틱 방식으로 토큰을 취소하려면 /revoke 엔드포인트에 HTTPS POST 요청을 실행합니다.\n\n```javascript\nconst https = require(\'https\');\n\n// Build the string for the POST request\nlet postData = ""token="" + userCredential.access_token;\n\n// Options for POST request to Google\'s OAuth 2.0 server to revoke a token\nlet postOptions = {\n  host: \'oauth2.googleapis.com\',\n  port: \'443\',\n  path: \'/revoke\',\n  method: \'POST\',\n  headers: {\n    \'Content-Type\': \'application/x-www-form-urlencoded\',\n    \'Content-Length\': Buffer.byteLength(postData)\n  }\n};\n\n// Set up the request\nconst postReq = https.request(postOptions, function (res) {\n  res.setEncoding(\'utf8\');\n  res.on(\'data\', d => {\n    console.log(\'Response: \' + d);\n  });\n});\n\npostReq.on(\'error\', error => {\n  console.log(error)\n});\n\n// Post the request with data\npostReq.write(postData);\npostReq.end();\n```'
 ""Q: JavaScript에서 액세스 토큰을 취소하기 위한 요청을 어떻게 구성하나요?\nA: JavaScript에서 액세스 토큰을 취소하기 위해서는 Google의 OAuth 2.0 엔드포인트인 `https://oauth2.googleapis.com/revoke`에 POST 요청을 보내야 합니다. 다음은 이를 위한 코드 예시입니다:\n\n```javascript\nfunction revokeAccess(accessToken) {\n  // Google's OAuth 2.0 endpoint for revoking access tokens.\n  var revokeTokenEndpoint = 'https://oauth2.googleapis.com/revoke';\n\n  // Create <form> element to use to POST data to the OAuth 2.0 endpoint.\n  var form = document.createElement('form');\n  form.setAttribute('method', 'post');\n  form.setAttribute('action', revokeTokenEndpoint);\n\n  // Add access token to the form so it is set as value of 'token' parameter.\n  var tokenField = document.createElement('input');\n  tokenField.setAttribute('type', 'hidden');\n  tokenField.setAttribute('name', 'token');\n  tokenField.setAttribute('value', accessToken);\n  form.appendChild(tokenField);\n\n  // Add form to page and submit it to actually revoke the token.\n  document.body.appendChild(form);\n  form.submit();\n}\n```\n이 코드는 액세스 토큰을 포함한 양식을 생성하고 이를 제출하여 토큰을 취소합니다.""
 ""Q: JavaScript에서 토큰 취소 요청을 보내기 위해 CORS를 피하는 방법은 무엇인가요?\nA: JavaScript에서 토큰 취소 요청을 보내기 위해 CORS를 피하려면 XMLHttpRequest() 메서드를 사용하여 요청을 게시하는 대신 양식을 만들어 엔드포인트에 양식을 제출해야 합니다. 다음은 이를 위한 코드 예시입니다:\n\n```javascript\nfunction revokeAccess(accessToken) {\n  // Google's OAuth 2.0 endpoint for revoking access tokens.\n  var revokeTokenEndpoint = 'https://oauth2.googleapis.com/revoke';\n\n  // Create <form> element to use to POST data to the OAuth 2.0 endpoint.\n  var form = document.createElement('form');\n  form.setAttribute('method', 'post');\n  form.setAttribute('action', revokeTokenEndpoint);\n\n  // Add access token to the form so it is set as value of 'token' parameter.\n  var tokenField = document.createElement('input');\n  tokenField.setAttribute('type', 'hidden');\n  tokenField.setAttribute('name', 'token');\n  tokenField.setAttribute('value', accessToken);\n  form.appendChild(tokenField);\n\n  // Add form to page and submit it to actually revoke the token.\n  document.body.appendChild(form);\n  form.submit();\n}\n```\n이 코드는 CORS 문제를 피하기 위해 양식을 사용하여 요청을 전송합니다.""
 'Q: Go 언어에서 동영상을 업로드하는 방법은 무엇인가요?\nA: Go 언어에서 동영상을 업로드하려면 `videos.insert` 메서드를 사용해야 합니다. 아래는 동영상을 업로드하는 코드 샘플입니다.\n\n```go\n// Upload a video\nvideo := &youtube.Video{\n    Title:       ""My Video Title"",\n    Description: ""My Video Description"",\n    Tags:        []string{""tag1"", ""tag2""},\n    CategoryId:  ""22"",\n    Status: &youtube.VideoStatus{\n        PrivacyStatus: ""public"",\n    },\n}\n\n// Call the API to insert the video\ncall := service.Videos.Insert(video, ""snippet,status"", media)\n```'
 'Q: YouTube 채널 정보를 가져오는 쿼리를 어떻게 작성하나요?\nA: - (void)fetchChannelResource {\n    GTLRYouTubeQuery_ChannelsList *query =\n    [GTLRYouTubeQuery_ChannelsList queryWithPart:@""snippet,statistics""];\n    query.identifier = @""UC_x5XG1OV2P6uZZ5FSM9Ttw"";\n    // To retrieve data for the current user\'s channel, comment out the previous\n    // line (query.identifier ...) and uncomment the next line (query.mine ...).\n    // query.mine = true;\n    [self.service executeQuery:query\n                    delegate:self\n            didFinishSelector:@selector(displayResultWithTicket:finishedWithObject:error:)];\n}'
 'Q: Node.js에서 액세스 토큰을 취소하기 위한 HTTP 요청의 구조는 어떻게 되나요?\nA: Node.js에서 액세스 토큰을 취소하기 위해서는 /revoke 엔드포인트에 HTTPS POST 요청을 실행해야 합니다. 아래는 그 코드 예시입니다.\n\n```javascript\nconst https = require(\'https\');\n\n// Build the string for the POST request\nlet postData = ""token="" + userCredential.access_token;\n\n// Options for POST request to Google\'s OAuth 2.0 server to revoke a token\nlet postOptions = {\n  host: \'oauth2.googleapis.com\',\n  port: \'443\',\n  path: \'/revoke\',\n  method: \'POST\',\n  headers: {\n    \'Content-Type\': \'application/x-www-form-urlencoded\',\n    \'Content-Length\': Buffer.byteLength(postData)\n  }\n};\n\n// Set up the request\nconst postReq = https.request(postOptions, function (res) {\n  res.setEncoding(\'utf8\');\n  res.on(\'data\', d => {\n    console.log(\'Response: \' + d);\n  });\n});\n\npostReq.on(\'error\', error => {\n  console.log(error)\n});\n\n// Post the request with data\npostReq.write(postData);\npostReq.end();\n```\n\n이 코드는 액세스 토큰을 취소하는 요청을 구성하고 실행합니다.'
 ""Q: 현재 사용자의 업로드된 동영상을 Ruby로 검색하는 방법은 무엇인가요?\nA: 현재 사용자의 업로드된 동영상을 Ruby로 검색하려면 `channels.list`와 `playlistItems.list` 메서드를 사용해야 합니다. 아래는 업로드된 동영상을 검색하는 코드 샘플입니다.\n\n```ruby\n# Get the channel ID\nchannel_response = youtube.channels.list(\n  'id',\n  mine: true\n)\nchannel_id = channel_response.items[0].id\n\n# Get the uploads playlist ID\nplaylist_response = youtube.playlists.list(\n  'id',\n  channel_id: channel_id\n)\nuploads_playlist_id = playlist_response.items[0].id\n\n# List the videos in the uploads playlist\nplaylist_items_response = youtube.playlist_items.list(\n  'snippet',\n  playlist_id: uploads_playlist_id\n)\n```""
 'Q: YouTube Data API를 사용하여 GoogleDevelopers YouTube 채널의 정보를 가져오는 샘플 코드는 어떻게 되나요?\nA: 다음은 GoogleDevelopers YouTube 채널의 정보를 가져오는 샘플 코드입니다. 이 요청은 API 키를 사용하여 애플리케이션을 식별하며 사용자 승인이나 특별한 권한이 필요하지 않습니다.\n\n```java\n// Import necessary libraries\nimport com.google.api.services.youtube.YouTube;\nimport com.google.api.services.youtube.model.ChannelListResponse;\n\n// Create a YouTube object\nYouTube youtubeService = new YouTube.Builder(httpTransport, jsonFactory, credential)\n    .setApplicationName(""YOUR_APPLICATION_NAME"")\n    .build();\n\n// Define the API request\nYouTube.Channels.List request = youtubeService.channels().list(""snippet"").setId(""UC_x5XG1OV2P6uZZ5FSM9Ttw"");\n\n// Execute the request\nChannelListResponse response = request.execute();\nSystem.out.println(response);\n```'
 ""Q: YouTube Data API를 사용하기 위해 Google Apps Script에서 스크립트를 어떻게 만들어야 하나요?\nA: 웹브라우저에서 Google Drive를 열고, 새로 만들기 > Google Sheets를 클릭합니다. 새 스프레드시트에서 확장 프로그램 > Apps Script를 클릭합니다. 스크립트 편집기의 내용을 다음 코드로 바꿉니다.\n```javascript\n// Note: Apps Script automatically requests authorization\n// based on the API's used in the code.\n\nfunction channelsListByUsername(part, params) {\n  var response = YouTube.Channels.list(part,\n                                       params);\n  var channel = response.items[0];\n  var dataRow = [channel.id, channel.snippet.title, channel.statistics.viewCount];\n  SpreadsheetApp.getActiveSpreadsheet().appendRow(dataRow);\n}\n```""
 'Q: 현재 사용자의 업로드된 동영상을 .NET으로 검색하는 방법은 무엇인가요?\nA: 현재 사용자의 업로드된 동영상을 .NET으로 검색하려면 `channels.list`와 `playlistItems.list` 메서드를 사용해야 합니다. 아래는 업로드된 동영상을 검색하는 코드 샘플입니다.\n\n```csharp\n// Get the channel ID\nvar channelsListResponse = youtubeService.Channels.List(""id"");\nchannelsListResponse.Mine = true;\nvar channelsList = channelsListResponse.Execute();\nvar channelId = channelsList.Items[0].Id;\n\n// Get the uploads playlist ID\nvar playlistsListResponse = youtubeService.Playlists.List(""id"");\nplaylistsListResponse.ChannelId = channelId;\nvar playlistsList = playlistsListResponse.Execute();\nvar uploadsPlaylistId = playlistsList.Items[0].Id;\n\n// List the videos in the uploads playlist\nvar playlistItemsListResponse = youtubeService.PlaylistItems.List(""snippet"");\nplaylistItemsListResponse.PlaylistId = uploadsPlaylistId;\nvar playlistItemsList = playlistItemsListResponse.Execute();\n```'
 'Q: YouTube Data API를 사용하기 위해 필요한 기본 요건은 무엇인가요?\nA: 이 빠른 시작을 실행하려면 다음이 필요합니다.\n- Ruby 2.0 이상\n- 인터넷 및 웹브라우저 액세스\n- Google 계정'
 'Q: Flask에서 API 요청을 테스트하는 방법은 무엇인가요?\nA: Flask에서 API 요청을 테스트하려면, \'/test\' 경로를 설정하고 다음과 같은 코드를 사용합니다:\n\n```python\n@app.route(\'/test\')\ndef test_api_request():\n  if \'credentials\' not in flask.session:\n    return (\'You need to <a href=""/authorize"">authorize</a> before \' +\n            \'testing the API request.\')\n\n  credentials = google.oauth2.credentials.Credentials(\n    **flask.session[\'credentials\'])\n\n  # API 요청을 수행하는 코드\n  # 예를 들어, YouTube API를 호출하여 데이터를 가져올 수 있습니다.\n```\n이 코드는 사용자가 인증을 완료한 후 API 요청을 수행할 수 있도록 합니다.'
 'Q: YouTube Data API 샘플 코드를 설정하기 위해 필요한 Ruby 코드의 주요 구성 요소는 무엇인가요?\nA: # Sample Ruby code for user authorization\n\nrequire \'rubygems\'\ngem \'google-api-client\', \'>0.7\'\nrequire \'google/apis\'\nrequire \'google/apis/youtube_v3\'\nrequire \'googleauth\'\nrequire \'googleauth/stores/file_token_store\'\n\nrequire \'fileutils\'\nrequire \'json\'\n\n# REPLACE WITH VALID REDIRECT_URI FOR YOUR CLIENT\nREDIRECT_URI = \'http://localhost\'\nAPPLICATION_NAME = \'YouTube Data API Ruby Tests\'\n\n# REPLACE WITH NAME/LOCATION OF YOUR client_secrets.json FILE\nCLIENT_SECRETS_PATH = \'client_secret.json\'\n\n# REPLACE FINAL ARGUMENT WITH FILE WHERE CREDENTIALS WILL BE STORED\nCREDENTIALS_PATH = File.join(Dir.home, \'.credentials\',\n                             ""youtube-quickstart-ruby-credentials.yaml"")\n\n# SCOPE FOR WHICH THIS SCRIPT REQUESTS AUTHORIZATION\nSCOPE = Google::Apis::YoutubeV3::AUTH_YOUTUBE_READONLY\n\ndef authorize\n  FileUtils.mkdir_p(File.dirname(CREDENTIALS_PATH))\n\n  client_id = Google::Auth::ClientId.from_file(CLIENT_SECRETS_PATH)\n  token_store = Google::Auth::Stores::FileTokenStore.new(file: CREDENTIALS_PATH)\n  authorizer = Google::Auth::UserAuthorizer.new(\n    client_id, SCOPE, token_store)\n  user_id = \'default\'\n  credentials = authorizer.get_credentials(user_id)\n  if credentials.nil?\n    url = authorizer.get_authorization_url(base_url: REDIRECT_URI)\n    puts ""Open the following URL in the browser and enter the "" +\n         ""resulting code after authorization""\n    puts url\n    code = gets\n    credentials = authorizer.get_and_store_credentials_from_code(\n      user_id: user_id, code: code, base_url: REDIRECT_URI)\n  end\n  credentials\nend\n\n# Initialize the API\nservice = Google::Apis::YoutubeV3::YouTubeService.new\nservice.client_options.application_name = APPLICATION_NAME\nservice.authorization = authorize'
 ""Q: Python에서 승인 코드를 액세스 토큰으로 교환하는 방법은 무엇인가요?\nA: 콜백 페이지에서 google-auth 라이브러리를 사용하여 승인 서버 응답을 확인한 후, flow.fetch_token 메서드를 사용하여 해당 응답의 승인 코드를 액세스 토큰으로 교환합니다. 아래는 코드 예시입니다.\n\n```python\nstate = flask.session['state']\nflow = google_auth_oauthlib.flow.Flow.from_client_secrets_file(\n    'client_secret.json',\n    scopes=['https://www.googleapis.com/auth/youtube.force-ssl'],\n    state=state)\nflow.redirect_uri = flask.url_for('oauth2callback', _external=True)\n\nauthorization_response = flask.request.url\nflow.fetch_token(authorization_response=authorization_response)\n\n# Store the credentials in the session.\n# ACTION ITEM for developers:\n#     Store user's access and refresh tokens in your data store if\n#     incorporating this code into your real app.\ncredentials = flow.credentials\nflask.session['credentials'] = {\n    'token': credentials.token,\n    'refresh_token': credentials.refresh_token,\n    'token_uri': credentials.token_uri,\n    'client_id': credentials.client_id,\n    'client_secret': credentials.client_secret,\n    'granted_scopes': credentials.granted_scopes}\n```""]","YouTube Data API를 사용 설정하기 위해 Google Developers Console을 활용하는 절차는 다음과 같습니다:

1. Google Developers Console에서 프로젝트를 만들거나 선택합니다.
2. API를 자동으로 사용 설정하는 마법사를 사용합니다. 이 마법사는 [여기](https://console.developers.google.com/start/api?id=youtube&hl=ko)에서 찾을 수 있습니다.
3. 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭합니다.

첫 번째 단계에서 반드시 수행해야 하는 작업은 Google Developers Console에서 프로젝트를 만들거나 선택하고, API를 자동으로 사용 설정하는 것입니다.","YouTube Data API를 사용 설정하기 위한 첫 번째 단계는 Google Developers Console에서 프로젝트를 만들거나 선택하고, API를 자동으로 사용 설정하는 마법사를 사용하는 것입니다. 이후 계속을 클릭한 다음 사용자 인증 정보로 이동을 클릭해야 합니다."
firsetore users 데이타 가져오려면 어떻게하나요? users 콜렉션에서 모든 users 정보 뽑는 코드 알려주세요.,"['users_ref = firestore.col collection_path\nusers_ref.get do |user|\nputs ""#{user.document_id} data: #{user.data}.""\nend\n\n다음 단계\n\n다음 주제를 자세히 알아보세요.\n\n데이터 모델 [https://cloud.google.com/firestore/native/docs/data-model?hl=ko] - 계층적 데이터와 하위 컬렉션을 비롯한 Firestore에서 데이터가 구조화되는 방식을 자세히 알아보세요.\n데이터 추가 [https://cloud.google.com/firestore/native/docs/manage-data/add-data?hl=ko] - Firestore에서 데이터를 만들고 업데이트하는 방법을 자세히 알아보세요.\n데이터 가져오기 [https://cloud.google.com/firestore/native/docs/query-data/get-data?hl=ko] - 데이터를 검색하는 방법을 자세히 알아보세요.\n단순 쿼리 및 복합 쿼리 실행 [https://cloud.google.com/firestore/native/docs/query-data/queries?hl=ko] - 단순 쿼리 및 복합 쿼리 실행 방법을 알아보세요.\n쿼리 순서 지정 및 제한 [https://cloud.google.com/firestore/native/docs/query-data/order-limit-data?hl=ko] - 쿼리에서 반환된 데이터의 순서를 지정하고 제한하는 방법을 알아보세요.\n\n의견 보내기'
 '데이터 읽기\n\nFirebase Console [https://console.firebase.google.com/project/_/firestore/data?hl=ko]의 데이터 뷰어를 사용하여 Firestore에 추가한 데이터를 빠르게 확인합니다.\n\nget 메서드를 사용하여 전체 컬렉션을 검색할 수도 있습니다.\n\n웹 버전 9\nimport { collection, getDocs } from ""firebase/firestore"";\n\nconst querySnapshot = await getDocs(collection(db, ""users""));\nquerySnapshot.forEach((doc) => {\nconsole.log(`${doc.id} => ${doc.data()}`);\n});get_all_users.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/snippets/firestore-next/test-firestore/get_all_users.js#L8-L13]\n\n웹 버전 8\n\n트리 쉐이킹 작업이 가능한 모듈식 웹 API에 대해 자세히 알아보고 [https://firebase.google.com/docs/web/learn-more?hl=ko#modular-version] 네임스페이스화된 API에 비해 갖는 이점을 살펴보세요.\ndb.collection(""users"").get().then((querySnapshot) => {\nquerySnapshot.forEach((doc) => {\nconsole.log(`${doc.id} => ${doc.data()}`);\n});\n});test.firestore.js [https://github.com/firebase/snippets-web/blob/467eaa165dcbd9b3ab15711e76fa52237ba37f8b/firestore/test.firestore.js#L143-L147]\n\nSwift\n\n참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.'
 '/forums/{forumid}/posts/{postid}\n{\nauthor: ""some_auth_id"",\nauthorname: ""some_username"",\ncontent: ""I just read a great story."",\n}\n\n이 애플리케이션에서는 소유자가 글을 편집하고 인증된 사용자가 글을 읽을 수 있도록 합니다.\nservice cloud.firestore {\nmatch /databases/{database}/documents {\nmatch /forums/{forumid}/posts/{post} {\n// Only authenticated users can read\nallow read: if request.auth != null;\n// Only the post author can write\nallow write: if request.auth != null && request.auth.uid == resource.data.author;\n}\n}\n}\n\n모든 인증된 사용자는 단일 포럼의 글을 검색할 수 있습니다.\ndb.collection(""forums/technology/posts"").get()\n\n그런데 현재 사용자에게 모든 포럼에 있는 자신의 글을 표시하려면 어떻게 해야 할까요?\n컬렉션 그룹 쿼리 [https://firebase.google.com/docs/firestore/query-data/queries?hl=ko#collection-group-query]를 사용하여 모든 posts 컬렉션에서 결과를 검색할 수 있습니다.\nvar user = firebase.auth().currentUser;\n\ndb.collectionGroup(""posts"").where(""author"", ""=="", user.uid).get()\n참고: 이 쿼리에는 컬렉션 그룹 범위가 지정된 posts 컬렉션에서 필드 author에 대한 색인이 필요합니다. 이 색인을 사용 설정하지 않은 경우 쿼리가 오류 링크를 반환하며, 이 링크를 따라가면 필요한 색인을 만들 수 있습니다.\n보안 규칙에서 posts 컬렉션 그룹에 대한 read 또는 list 규칙을 작성하여 이 쿼리를 허용해야 합니다.\nrules_version = \'2\';\nservice cloud.firestore {'
 '/forums/{forumid}/posts/{postid}\n{\nauthor: ""some_auth_id"",\nauthorname: ""some_username"",\ncontent: ""I just read a great story."",\n}\n\n이 애플리케이션에서는 소유자가 글을 편집하고 인증된 사용자가 글을 읽을 수 있도록 합니다.\nservice cloud.firestore {\nmatch /databases/{database}/documents {\nmatch /forums/{forumid}/posts/{post} {\n// Only authenticated users can read\nallow read: if request.auth != null;\n// Only the post author can write\nallow write: if request.auth != null && request.auth.uid == resource.data.author;\n}\n}\n}\n\n모든 인증된 사용자는 단일 포럼의 글을 검색할 수 있습니다.\ndb.collection(""forums/technology/posts&quot;).get()\n\n그런데 현재 사용자에게 모든 포럼에 있는 자신의 글을 표시하려면 어떻게 해야 할까요?\n컬렉션 그룹 쿼리 [https://cloud.google.com/firestore/native/docs/query-data/queries?hl=ko#collection-group-query]를 사용하여 모든 posts 컬렉션에서 결과를 검색할 수 있습니다.\nvar user = firebase.auth().currentUser;\n\ndb.collectionGroup(""posts"").where(""author"", &quot;=="", user.uid).get()\n참고: 이 쿼리에는 컬렉션 그룹 범위가 지정된 posts 컬렉션에서 필드 author에 대한 색인이 필요합니다. 이 색인을 사용 설정하지 않은 경우 쿼리가 오류 링크를 반환하며, 이 링크를 따라가면 필요한 색인을 만들 수 있습니다.\n보안 규칙에서 posts 컬렉션 그룹에 대한 read 또는 list 규칙을 작성하여 이 쿼리를 허용해야 합니다.\nrules_version = \'2\';\nservice cloud.firestore {'
 'Python\n\nusers_ref = db.collection(""users"")snippets.py [https://github.com/GoogleCloudPlatform/python-docs-samples/blob/5426f6198e20bb76f4b0d005d2e2f26449b4f5d8/firestore/cloud-async-client/snippets.py#L283-L283]\n\nC++\nCollectionReference users_collection_reference = db->Collection(""users"");snippets.cpp [https://github.com/firebase/snippets-cpp/blob/778b6bcc8e8e8fcabb1c2e3a8d11ab51a26aa77b/firestore/android/FirestoreSnippetsCpp/app/src/main/cpp/snippets.cpp#L50-L50]\n\nNode.js\n\nconst usersCollectionRef = db.collection(\'users\');index.js [https://github.com/firebase/snippets-node/blob/f1869eeb97c2bbb713aff3deb5a67666da7bcb6b/firestore/main/index.js#L136-L136]\n\nGo\n\nimport (\n""cloud.google.com/go/firestore""\n)\n\nfunc createCollectionReference(client *firestore.Client) {\nusersRef := client.Collection(""users"")\n\n_ = usersRef\n}\nretrieve_data_reference_collection.go [https://github.com/GoogleCloudPlatform/golang-samples/blob/1420c71e05f2a1aef5eb07e90da7294ffe82a75c/firestore/retrieve_data_reference_collection.go#L18-L28]\n\nPHP\n\nPHP\n\nCloud Firestore 클라이언트 설치 및 생성에 관한 자세한 내용은 Cloud Firestore 클라이언트 라이브러리 [https://firebase.google.com/firestore/docs/reference/libraries?hl=ko]를 참조하세요.'
 'class alovelace\n\nname :\nfirst : ""Ada""\nlast : ""Lovelace""\nborn : 1815\n\n문서가 JSON과 매우 비슷해졌는데, 사실 기본적으로는 JSON과 유사합니다.\n문서가 추가적인 데이터 유형을 지원하고 크기가 1MB로 제한되는 등의 몇 가지 차이점이 있기는 하지만, 일반적으로는 문서를 간단한 JSON 레코드로 취급해도 무방합니다.\n\n컬렉션\n\n문서는 단순히 문서의 컨테이너인 컬렉션에 저장됩니다. 예를 들어 각각 문서로 표현되는 여러 사용자를 포함하는 users 컬렉션이 있을 수 있습니다.\n\ncollections_bookmark users\n\nclass alovelace\n\nfirst : ""Ada""\nlast : ""Lovelace""\nborn : 1815\nclass aturing\n\nfirst : ""Alan""\nlast : ""Turing""\nborn : 1912\n\nFirestore는 스키마를 사용하지 않으므로 각 문서에 어떤 필드를 넣을지와 각 필드에 어떤 유형의 데이터를 저장할지는 완전히 사용자의 재량입니다.\n같은 컬렉션에 포함된 여러 문서는 서로 다른 필드를 포함하거나 서로 다른 유형의 데이터를 필드에 저장할 수 있습니다. 그러나 문서를 보다 쉽게\n쿼리할 수 있도록 여러 문서에서 동일한 필드와 데이터 유형을 사용하는 것이\n좋습니다.\n\n컬렉션은 오로지 문서만 포함합니다. 값이 있는 원시 필드를 직접 포함할 수 없고 다른 컬렉션을 포함할 수도 없습니다. Firestore에서 보다 복잡한 데이터를 구조화하는 방법은 계층적 데이터 [https://cloud.google.com/firestore/native/docs/data-model?hl=ko#hierarchical-data]를 참조하세요.\n\n컬렉션 내의 문서 이름은 고유합니다. 사용자 ID와 같은 고유한 키를 제공하거나 Firestore에서 임의 ID를 자동으로 만들도록 할 수 있습니다.\n\n컬렉션을 \'생성\' 또는 \'삭제\'할 필요는 없습니다. 컬렉션에\n첫 번째 문서를 만들면 컬렉션이 생성됩니다. 컬렉션의 모든 문서를\n삭제하면 컬렉션도 삭제됩니다.\n\n참조\n\nFirestore의 모든 문서는 데이터베이스 내 위치에 따라 고유하게 식별됩니다. 앞의 예시의 alovelace 문서는 users 컬렉션에 속했습니다. 코드에서 이 위치를 참조하려면 위치를 가리키는 참조를 만드세요.'
 'class alovelace\n\nname :\nfirst : ""Ada""\nlast : ""Lovelace""\nborn : 1815\n\n문서가 JSON과 매우 비슷해졌는데, 사실 기본적으로는 JSON과 유사합니다.\n문서가 추가적인 데이터 유형을 지원하고 크기가 1MB로 제한되는 등의 몇 가지 차이점이 있기는 하지만, 일반적으로는 문서를 간단한 JSON 레코드로 취급해도 무방합니다.\n\n컬렉션\n\n문서는 단순히 문서의 컨테이너인 컬렉션에 저장됩니다. 예를 들어 각각 문서로 표현되는 여러 사용자를 포함하는 users 컬렉션이 있을 수 있습니다.\n\n사용자 collections_bookmark명\n\nclass alovelace\n\nfirst : ""Ada""\nlast : ""Lovelace""\nborn : 1815\nclass aturing\n\nfirst : ""Alan""\nlast : ""Turing""\nborn : 1912\n\nCloud Firestore는 스키마를 사용하지 않으므로 각 문서에 어떤 필드를 넣을지와 각 필드에 어떤 유형의 데이터를 저장할지는 완전히 사용자의 재량입니다.\n같은 컬렉션에 포함된 여러 문서가 서로 다른 필드를 포함하거나 이러한 필드에 서로 다른 유형의 데이터를 저장할 수도 있습니다. 그러나 문서를 보다 쉽게\n쿼리할 수 있도록 여러 문서에서 동일한 필드와 데이터 유형을 사용하는 것이\n좋습니다.\n\n컬렉션은 오로지 문서만 포함합니다. 값이 있는 원시 필드를 직접 포함하거나 다른 컬렉션을 포함할 수 없습니다. Cloud Firestore에서 보다 복잡한 데이터를 구조화하는 방법은 계층적 데이터 [https://firebase.google.com/docs/firestore/data-model?hl=ko#hierarchical-data]를 참조하세요.\n\n컬렉션 내의 문서 이름은 고유합니다. 사용자 ID와 같은 고유한 키를 제공하거나 Cloud Cloud Firestore에서 임의 ID를 자동으로 만들도록 할 수 있습니다.\n\n컬렉션을 직접 \'생성\' 또는 \'삭제\'할 필요는 없습니다. 컬렉션에\n첫 번째 문서를 만들면 컬렉션이 생성됩니다. 컬렉션의 모든 문서를\n삭제하면 컬렉션도 삭제됩니다.\n\n참조\n\nCloud Firestore의 모든 문서는 데이터베이스 내 위치에 따라 고유하게 식별됩니다. 앞의 예시에 나왔던 alovelace 문서는 users 컬렉션에 속했습니다. 코드에서 이 위치를 참조하려면 위치를 가리키는 참조를 만드세요.'
 'Google Cloud CLI\n\ngcloud CLI [https://cloud.google.com/sdk/gcloud/reference/firestore?hl=ko]를 사용하여 Firestore에 액세스할 때 gcloud CLI 명령어에서 사용하는 사용자 인증 정보를 제공하는 사용자 계정으로 gcloud CLI에 로그인 [https://cloud.google.com/sdk/docs/authorizing?hl=ko]합니다.\n\n조직의 보안 정책으로 인해 사용자 계정에 필요한 권한이 없는 경우 서비스 계정 가장 [https://cloud.google.com/firestore/native/docs/authentication?hl=ko#sa-impersonation]을 사용할 수 있습니다.\n\n자세한 내용은 gcloud CLI 사용을 위한 인증 [https://cloud.google.com/docs/authentication/gcloud?hl=ko]을 참조하세요.\nFirestore에서 gcloud CLI를 사용하는 방법에 대한 자세한 내용은 gcloud CLI 참조 페이지 [https://cloud.google.com/sdk/gcloud/reference/firestore?hl=ko]를 확인하세요.\n\nFirestore 인증 설정\n\n인증 설정 방법은 코드를 실행 중인 환경에 따라 달라집니다.\n\n인증 설정을 위한 가장 일반적인 옵션은 다음과 같습니다. 인증에 대한 추가 옵션 및 자세한 내용은 인증 방법 [https://cloud.google.com/docs/authentication?hl=ko]을 참조하세요.\n\n로컬 개발 환경용\n\n다음 방법으로 로컬 개발 환경의 사용자 인증 정보를 설정할 수 있습니다.\n\n클라이언트 라이브러리 또는 서드 파티 도구의 사용자 인증 정보 [https://cloud.google.com/firestore/native/docs/authentication?hl=ko#client-libs]\n\n서비스 계정 가장 [https://cloud.google.com/firestore/native/docs/authentication?hl=ko#sa-impersonation]\n\n클라이언트 라이브러리 또는 서드 파티 도구'
 'DocumentReference docRef = db.Collection(""users"").Document(""alovelace"");\nDictionary<string, object> user = new Dictionary<string, object>\n{\n{ ""First"", ""Ada"" },\n{ ""Last"", ""Lovelace"" },\n{ ""Born"", 1815 }\n};\nawait docRef.SetAsync(user);\n\nRuby\n\nFirestore에 인증하려면 애플리케이션 기본 사용자 인증 정보를 설정합니다.\n자세한 내용은 로컬 개발 환경의 인증 설정 [https://cloud.google.com/docs/authentication/set-up-adc-local-dev-environment?hl=ko]을 참조하세요.\n\ndoc_ref = firestore.doc ""#{collection_path}/alovelace""\n\ndoc_ref.set(\n{\nfirst: ""Ada"",\nlast:  ""Lovelace"",\nborn:  1815\n}\n)\n\nputs ""Added data to the alovelace document in the users collection.""\n\n이제 users 컬렉션에 다른 문서를 추가합니다. 첫 번째 문서에는 나타나지 않는 키-값 쌍(중간 이름)이 문서에 포함된다는 점에 유의하세요. 컬렉션의 문서에는 다른 정보 집합이 포함될 수 있습니다.\n\nJava\n\nFirestore에 인증하려면 애플리케이션 기본 사용자 인증 정보를 설정합니다.\n자세한 내용은 로컬 개발 환경의 인증 설정 [https://cloud.google.com/docs/authentication/set-up-adc-local-dev-environment?hl=ko]을 참조하세요.\n\nDocumentReference docRef = db.collection(""users"").document(""aturing"");\n// Add document data with an additional field (""middle"")\nMap<String, Object> data = new HashMap<>();\ndata.put(""first"", ""Alan"");\ndata.put(""middle"", ""Mathison"");\ndata.put(""last"", ""Turing"");\ndata.put(""born"", 1912);'
 'const docRef = db.collection(\'users\').doc(\'alovelace\');\n\nawait docRef.set({\nfirst: \'Ada\',\nlast: \'Lovelace\',\nborn: 1815\n});\n\nGo\n\nFirestore에 인증하려면 애플리케이션 기본 사용자 인증 정보를 설정합니다.\n자세한 내용은 로컬 개발 환경의 인증 설정 [https://cloud.google.com/docs/authentication/set-up-adc-local-dev-environment?hl=ko]을 참조하세요.\n\n_, _, err := client.Collection(""users"").Add(ctx, map[string]interface{}{\n""first"": ""Ada"",\n""last"":  ""Lovelace"",\n""born"":  1815,\n})\nif err != nil {\nlog.Fatalf(""Failed adding alovelace: %v"", err)\n}\n\nPHP\n\nFirestore에 인증하려면 애플리케이션 기본 사용자 인증 정보를 설정합니다.\n자세한 내용은 로컬 개발 환경의 인증 설정 [https://cloud.google.com/docs/authentication/set-up-adc-local-dev-environment?hl=ko]을 참조하세요.\n\n$docRef = $db->collection(\'samples/php/users\')->document(\'alovelace\');\n$docRef->set([\n\'first\' => \'Ada\',\n\'last\' => \'Lovelace\',\n\'born\' => 1815\n]);\nprintf(\'Added data to the lovelace document in the users collection.\' . PHP_EOL);\n\nC#\n\nFirestore에 인증하려면 애플리케이션 기본 사용자 인증 정보를 설정합니다.\n자세한 내용은 로컬 개발 환경의 인증 설정 [https://cloud.google.com/docs/authentication/set-up-adc-local-dev-environment?hl=ko]을 참조하세요.'
 'get 메서드를 사용하여 전체 컬렉션을 검색할 수도 있습니다.\n\n--- 탭: Java [https://cloud.google.com/firestore/native/docs/create-database-server-client-library?hl=ko#java] ---\n```\n// asynchronously retrieve all users\nApiFuture<QuerySnapshot> query = db.collection(""users"").get();\n// ...\n// query.get() blocks on response\nQuerySnapshot querySnapshot = query.get();\nList<QueryDocumentSnapshot> documents = querySnapshot.getDocuments();\nfor (QueryDocumentSnapshot document : documents) {\nSystem.out.println(""User: "" + document.getId());\nSystem.out.println(""First: "" + document.getString(""first""));\nif (document.contains(""middle"")) {\nSystem.out.println(""Middle: "" + document.getString(""middle""));\n}\nSystem.out.println(""Last: "" + document.getString(""last""));\nSystem.out.println(""Born: "" + document.getLong(""born""));\n}\n```\n\n--- 탭: Python [https://cloud.google.com/firestore/native/docs/create-database-server-client-library?hl=ko#python] ---\n```\nusers_ref = db.collection(""users"")\ndocs = users_ref.stream()\n\nfor doc in docs:\nprint(f""{doc.id} => {doc.to_dict()}"")\n```'
 'May 07, 2019\n\nCloud Firestore now supports collection group queries [https://cloud.google.com/firestore/docs/query-data/queries#collection-group-query]. A collection group consists of all collections with the same ID. By default, queries retrieve results from a single collection in your database. Use a collection group query to retrieve documents from a collection group instead of from a single collection.\n\nApril 18, 2019\n\nSupport for asia-northeast2 region (Osaka) [https://cloud.google.com/firestore/docs/locations].\n\nApril 15, 2019\n\nSupport for europe-west6 region (Zürich) [https://cloud.google.com/firestore/docs/locations].\n\nMarch 28, 2019\n\nYou can now use the increment operation [https://cloud.google.com/firestore/docs/manage-data/add-data#increment_a_numeric_value] to increase or decrease the current value of a numeric field by a given amount. For more on this feature, see our announcement [https://firebase.googleblog.com/2019/03/increment-server-side-cloud-firestore.html?linkId=65365800].\n\nJanuary 31, 2019'
 ""이러한 제한사항을 보안 규칙에 적용하고 user 필드에 대한 데이터 유효성 검사를 포함합니다.\nrules_version = '2';\nservice cloud.firestore {\n\nmatch /databases/{database}/documents {\n\nmatch /{path=**}/transactions/{transaction} {\n// Authenticated users can retrieve only their own transactions\nallow read: if resource.data.user == request.auth.uid;\n}\n\nmatch /users/{userid}/exchange/{exchangeid}/transactions/{transaction} {\n// Authenticated users can write to their own transactions subcollections\n// Writes must populate the user field with the correct auth id\nallow write: if userid == request.auth.uid && request.data.user == request.auth.uid\n}\n}\n}\n\n다음 단계\n\n역할 기반 액세스 제어의 자세한 예는 사용자 및 그룹에 대한 데이터 액세스 보안 [https://firebase.google.com/docs/firestore/solutions/role-based-access?hl=ko]을 참조하세요.\n보안 규칙 참조 [https://firebase.google.com/docs/reference/rules/rules?hl=ko] 읽어보기\n\n의견 보내기""
 ""이러한 제한사항을 보안 규칙에 적용하고 user 필드에 대한 데이터 유효성 검사를 포함합니다.\nrules_version = '2';\nservice cloud.firestore {\n\nmatch /databases/{database}/documents {\n\nmatch /{path=**}/transactions/{transaction} {\n// Authenticated users can retrieve only their own transactions\nallow read: if resource.data.user == request.auth.uid;\n}\n\nmatch /users/{userid}/exchange/{exchangeid}/transactions/{transaction} {\n// Authenticated users can write to their own transactions subcollections\n// Writes must populate the user field with the correct auth id\nallow write: if userid == request.a&&uth.uid  request.data.user == request.auth.uid\n}\n}\n}\n\n다음 단계\n\n역할 기반 액세스 제어의 자세한 예는 사용자 및 그룹에 대한 데이터 액세스 보안 [https://cloud.google.com/firestore/native/docs/solutions/role-based-access?hl=ko]을 참조하세요.\n보안 규칙 참조 [https://firebase.google.com/docs/reference/rules/rules?hl=ko] 읽어보기\n\n도움이 되었나요?\n\n의견 보내기""
 'REST Resource: v1.projects.databases.userCreds [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.databases.userCreds]\n\n| Methods |\n| --- |\n| create | POST /v1/{parent=projects/*/databases/*}/userCreds Create a user creds. |\n| delete | DELETE /v1/{name=projects/*/databases/*/userCreds/*} Deletes a user creds. |\n| disable | POST /v1/{name=projects/*/databases/*/userCreds/*}:disable Disables a user creds. |\n| enable | POST /v1/{name=projects/*/databases/*/userCreds/*}:enable Enables a user creds. |\n| get | GET /v1/{name=projects/*/databases/*/userCreds/*} Gets a user creds resource. |\n| list | GET /v1/{parent=projects/*/databases/*}/userCreds List all user creds in the database. |\n| resetPassword | POST /v1/{name=projects/*/databases/*/userCreds/*}:resetPassword Resets the password of a user creds. |\n\nREST Resource: v1.projects.locations [https://cloud.google.com/firestore/docs/reference/rest/v1/projects.locations]\n\n| Methods |\n| --- |\n| get | GET /v1/{name=projects/*/locations/*} Gets information about a location. |\n| list | GET /v1/{name=projects/*}/locations Lists information about the supported locations for this service. |'
 'REST Resource: v1.projects.databases.userCreds [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.databases.userCreds]\n\n| Methods |\n| --- |\n| create | POST /v1/{parent=projects/*/databases/*}/userCreds Create a user creds. |\n| delete | DELETE /v1/{name=projects/*/databases/*/userCreds/*} Deletes a user creds. |\n| disable | POST /v1/{name=projects/*/databases/*/userCreds/*}:disable Disables a user creds. |\n| enable | POST /v1/{name=projects/*/databases/*/userCreds/*}:enable Enables a user creds. |\n| get | GET /v1/{name=projects/*/databases/*/userCreds/*} Gets a user creds resource. |\n| list | GET /v1/{parent=projects/*/databases/*}/userCreds List all user creds in the database. |\n| resetPassword | POST /v1/{name=projects/*/databases/*/userCreds/*}:resetPassword Resets the password of a user creds. |\n\nREST Resource: v1.projects.locations [https://firebase.google.com/docs/firestore/reference/rest/v1/projects.locations]\n\n| Methods |\n| --- |\n| get | GET /v1/{name=projects/*/locations/*} Gets information about a location. |\n| list | GET /v1/{name=projects/*}/locations Lists information about the supported locations for this service. |'
 'Q: Cloud Firestore에서 전체 컬렉션을 가져오는 방법은 무엇인가요?\nA: 전체 컬렉션을 가져오려면 \'get\' 메서드를 사용합니다. 다음은 웹에서 \'users\' 컬렉션을 가져오는 예제입니다:\n\n```javascript\nimport { collection, getDocs } from ""firebase/firestore"";\n\nconst querySnapshot = await getDocs(collection(db, ""users""));\nquerySnapshot.forEach((doc) => {\n  console.log(`${doc.id} => ${doc.data()}`);\n});\n```'
 ""Q: Node.js에서 Firestore의 모든 사용자 데이터를 읽는 방법은 무엇인가요?\nA: const snapshot = await db.collection('users').get();\nsnapshot.forEach((doc) => {\nconsole.log(doc.id, '=>', doc.data());\n});""
 ""Q: Node.js에서 Firestore의 모든 사용자 데이터를 읽는 방법은 무엇인가요?\nA: const snapshot = await db.collection('users').get();\nsnapshot.forEach((doc) => {\n    console.log(doc.id, '=>', doc.data());\n});""
 'Q: Java에서 Firestore에서 모든 사용자 데이터를 비동기적으로 검색하는 방법은 무엇인가요?\nA: // asynchronously retrieve all users\nApiFuture<QuerySnapshot> query = db.collection(""users"").get();\n// ...\n// query.get() blocks on response\nQuerySnapshot querySnapshot = query.get();\nList<QueryDocumentSnapshot> documents = querySnapshot.getDocuments();\nfor (QueryDocumentSnapshot document : documents) {\nSystem.out.println(""User: "" + document.getId());\nSystem.out.println(""First: "" + document.getString(""first""));\nif (document.contains(""middle"")) {\nSystem.out.println(""Middle: "" + document.getString(""middle""));\n}\nSystem.out.println(""Last: "" + document.getString(""last""));\nSystem.out.println(""Born: "" + document.getLong(""born""));\n}'
 'Q: Java에서 Firestore의 모든 사용자 데이터를 비동기적으로 검색하는 방법은 무엇인가요?\nA: // asynchronously retrieve all users\nApiFuture<QuerySnapshot> query = db.collection(""users"").get();\n// ...\n// query.get() blocks on response\nQuerySnapshot querySnapshot = query.get();\nList<QueryDocumentSnapshot> documents = querySnapshot.getDocuments();\nfor (QueryDocumentSnapshot document : documents) {\n    System.out.println(""User: "" + document.getId());\n    System.out.println(""First: "" + document.getString(""first""));\n    if (document.contains(""middle"")) {\n        System.out.println(""Middle: "" + document.getString(""middle""));\n    }\n    System.out.println(""Last: "" + document.getString(""last""));\n    System.out.println(""Born: "" + document.getLong(""born""));\n}'
 ""Q: Node.js에서 Firestore에서 'cities' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 무엇인가요?\nA: Node.js에서 Firestore에서 'cities' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 다음과 같습니다:\n\n```javascript\nconst citiesRef = db.collection('cities');\nconst snapshot = await citiesRef.get();\nsnapshot.forEach(doc => {\n    console.log(doc.id, '=>', doc.data());\n});\n```""
 'Q: Cloud Firestore에서 컬렉션(collection)의 역할은 무엇인가요?\nA: 컬렉션은 문서의 컨테이너 역할을 하며, 여러 문서를 포함할 수 있습니다. 예를 들어, 사용자 정보를 담고 있는 users 컬렉션이 있을 수 있습니다. 각 문서는 고유한 이름으로 식별됩니다.'
 'Q: Dart에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 무엇인가요?\nA: Dart에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 다음과 같습니다:\n\n```dart\ndb.collection(""cities"").get().then(\n    (querySnapshot) {\n        print(""Successfully completed"");\n        for (var docSnapshot in querySnapshot.docs) {\n            print(\'\x1b[32m${docSnapshot.id} => ${docSnapshot.data()}\x1b[0m\');\n        }\n    },\n    onError: (e) => print(""Error completing: $e""),\n);\n```'
 ""Q: Cloud Firestore에서 사용자 인증 정보를 생성하기 위해 필요한 권한은 무엇인가요?\nA: 사용자 인증 정보를 생성하기 위해서는 'datastore.userCreds.create' 권한이 필요합니다.""
 'Q: Cloud Firestore에서 사용자 인증 정보를 나열하기 위해 필요한 권한은 무엇인가요?\nA: 사용자 인증 정보를 나열하기 위해 필요한 권한은 `datastore.userCreds.list`입니다.'
 'Q: Firestore에서 문서 경로를 지정할 때 유효한 예시는 무엇인가요?\nA: 다음은 유효한 문서 경로의 몇 가지 예시입니다:\n\n- users/marie: 단일 문서 /users/marie를 모니터링합니다.\n- users/{username}: 모든 사용자 문서를 모니터링합니다.\n- users/{username}/addresses/home: 모든 사용자의 집 주소 문서를 모니터링합니다.\n- users/{username}/addresses/{addressId}: 모든 주소 문서를 모니터링합니다.\n- users/{user=**}: 모든 사용자 문서와 /users/userID/address/home 또는 /users/userID/phone/work 등 각 사용자 문서에 포함된 하위 컬렉션의 문서를 모니터링합니다.'
 'Q: Kotlin에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 무엇인가요?\nA: Kotlin에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 다음과 같습니다:\n\n```kotlin\ndb.collection(""cities"")\n    .get()\n    .addOnSuccessListener { result ->\n        for (document in result) {\n            Log.d(TAG, ""${document.id} => ${document.data}"")\n        }\n    }\n    .addOnFailureListener { exception ->\n        Log.d(TAG, ""Error getting documents: "", exception)\n    }\n```'
 'Q: Ruby에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 가져오는 방법은 무엇인가요?\nA: Ruby에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 가져오려면 다음과 같이 작성할 수 있습니다.\n\n```ruby\ncities_ref = firestore.col collection_path\n\nquery = cities_ref.where ""capital"", ""="", true\n\nquery.get do |city|\n  puts ""#{city.document_id} data: #{city.data}.""\nend\n```'
 'Q: Ruby에서 Firestore의 \'cities\' 컬렉션의 모든 문서를 가져오는 방법은 무엇인가요?\nA: 다음 코드를 사용하여 Ruby에서 Firestore의 \'cities\' 컬렉션의 모든 문서를 가져올 수 있습니다.\n\n```ruby\ncities_ref = firestore.col collection_path\ncities_ref.get do |city|\n  puts ""#{city.document_id} data: #{city.data}.""\nend\n```'
 'Q: Dart에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 가져오는 방법은 무엇인가요?\nA: Dart에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 가져오려면 다음과 같이 작성할 수 있습니다.\n\n```dart\ndb.collection(""cities"").get().then(\n  (querySnapshot) {\n    print(""Successfully completed"");\n    for (var docSnapshot in querySnapshot.docs) {\n      print(\'\x1b[32m${docSnapshot.id} => ${docSnapshot.data()}\x1b[0m\');\n    }\n  },\n  onError: (e) => print(""Error completing: $e""),\n);\n```'
 ""Q: Node.js에서 Firestore에서 'cities' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 무엇인가요?\nA: const citiesRef = db.collection('cities');\nconst snapshot = await citiesRef.get();\nsnapshot.forEach(doc => {\nconsole.log(doc.id, '=>', doc.data());\n});""
 'Q: C++에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 무엇인가요?\nA: C++에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 다음과 같습니다:\n\n```cpp\ndb->Collection(""cities"").Get().OnCompletion(\n    [](const Future<QuerySnapshot>& future) {\n        if (future.error() == Error::kErrorOk) {\n            for (const DocumentSnapshot& document :\n                future.result()->documents()) {\n                std::cout << document << std::endl;\n            }\n        } else {\n            std::cout << ""Error getting documents: "" << future.error_message()\n                << std::endl;\n        }\n    });\n```'
 'Q: Swift에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 가져오는 방법은 무엇인가요?\nA: Swift에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 가져오려면 다음과 같이 작성할 수 있습니다.\n\n```swift\ndo {\n    let querySnapshot = try await db.collection(""cities"").getDocuments()\n    for document in querySnapshot.documents {\n        print(""\\(document.documentID) => \\(document.data())"")\n    }\n} catch {\n    print(""Error getting documents: \\(error)"")\n}\n```'
 'Q: Java에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 무엇인가요?\nA: Java에서 Firestore에서 \'cities\' 컬렉션의 모든 문서를 비동기적으로 가져오는 방법은 다음과 같습니다:\n\n```java\ndb.collection(""cities"")\n    .get()\n    .addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {\n        @Override\n        public void onComplete(@NonNull Task<QuerySnapshot> task) {\n            if (task.isSuccessful()) {\n                for (QueryDocumentSnapshot document : task.getResult()) {\n                    Log.d(TAG, document.getId() + "" => "" + document.getData());\n                }\n            } else {\n                Log.d(TAG, ""Error getting documents: "", task.getException());\n            }\n        }\n    });\n```'
 ""Q: Node.js에서 Cloud Firestore의 문서가 삭제될 때 사용자 인증 정보를 가져오는 방법은 무엇인가요?\nA: Node.js에서 Cloud Firestore의 문서가 삭제될 때 사용자 인증 정보를 가져오려면, `onDocumentDeletedWithAuthContext` 메서드를 사용하여 다음과 같이 정의할 수 있습니다:\n\n```javascript\nconst {onDocumentDeletedWithAuthContext} = require('firebase-functions/v2/firestore');\n\nexports.myfunction = onDocumentDeletedWithAuthContext('users/{userId}', (event) => {\n    const user_auth_type = event.auth_type;\n    const user_auth_id = event.auth_id;\n});\n```""
 'Q: Firestore에서 인덱스 정보를 가져오는 API 메서드는 무엇인가요?\nA: Firestore에서 인덱스 정보를 가져오는 API 메서드는 `projects.databases.indexes.get`입니다. 이 메서드를 사용하여 특정 인덱스의 정보를 조회할 수 있습니다.'
 'Q: PHP에서 Firestore에 인증하기 위한 기본 사용자 인증 정보를 설정하는 방법은 무엇인가요?\nA: Firestore에 인증하려면 애플리케이션 기본 사용자 인증 정보를 설정합니다. 자세한 내용은 로컬 개발 환경의 인증 설정을 참조하세요.'
 ""Q: Python에서 Cloud Firestore의 문서가 생성될 때 사용자 인증 정보를 가져오는 방법은 무엇인가요?\nA: Python에서 Cloud Firestore의 문서가 생성될 때 사용자 인증 정보를 가져오려면, `on_document_created_with_auth_context` 데코레이터를 사용하여 다음과 같이 정의할 수 있습니다:\n\n```python\n@on_document_created_with_auth_context(document='users/{userId}')\ndef myfunction(event: Event[Change[DocumentSnapshot]]) -> None:\n    # Get the auth context from the event\n    user_auth_type = event.auth_type\n    user_auth_id = event.auth_id\n```""
 'Q: Firestore에서 특정 필드의 정보를 가져오는 방법은 무엇인가요?\nA: 특정 필드의 정보를 가져오기 위해서는 GetFieldRequest를 사용해야 합니다.'
 'Q: Firestore에서 데이터베이스의 소스 정보를 가져오는 방법은 무엇인가요?\nA: Firestore에서 데이터베이스의 소스 정보를 가져오기 위해서는 `Database.SourceInfo` 메시지를 사용하여 데이터베이스의 소스 정보를 확인할 수 있습니다.'
 ""Q: PHP에서 Firestore의 모든 사용자 데이터를 읽는 방법은 무엇인가요?\nA: PHP에서 Firestore의 모든 사용자 데이터를 읽으려면 다음과 같이 코드를 작성할 수 있습니다.\n\n```php\n$usersRef = $db->collection('samples/php/users');\n$snapshot = $usersRef->documents();\nforeach ($snapshot as $user) {\n    printf('User: %s' . PHP_EOL, $user->id());\n    printf('First: %s' . PHP_EOL, $user['first']);\n    if (!empty($user['middle'])) {\n        printf('Middle: %s' . PHP_EOL, $user['middle']);\n    }\n    printf('Last: %s' . PHP_EOL, $user['last']);\n    printf('Born: %d' . PHP_EOL, $user['born']);\n    printf(PHP_EOL);\n}\nprintf('Retrieved and printed out all documents from the users collection.' . PHP_EOL);\n```""
 ""Q: Firestore에서 사용자가 자신의 거래(transaction) 문서만 검색할 수 있도록 보안 규칙을 설정하는 방법은 무엇인가요?\nA: 사용자가 자신의 거래 문서만 검색할 수 있도록 보안 규칙을 다음과 같이 설정할 수 있습니다.\n\n```plaintext\nrules_version = '2';\nservice cloud.firestore {\n\nmatch /databases/{database}/documents {\n\nmatch /{path=**}/transactions/{transaction} {\n// Authenticated users can retrieve only their own transactions\nallow read: if resource.data.user == request.auth.uid;\n}\n\nmatch /users/{userid}/exchange/{exchangeid}/transactions/{transaction} {\n// Authenticated users can write to their own transactions subcollections\n// Writes must populate the user field with the correct auth id\nallow write: if userid == request.auth.uid  request.data.user == request.auth.uid;\n}\n}\n}\n```""
 ""Q: Firestore에서 거래(transaction) 문서의 보안 규칙을 어떻게 설정하나요?\nA: Firestore에서 거래(transaction) 문서의 보안 규칙을 설정할 때는 다음과 같이 작성할 수 있습니다. 이 규칙은 인증된 사용자가 자신의 거래만 읽을 수 있도록 제한합니다.\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n\nmatch /databases/{database}/documents {\n\nmatch /{path=**}/transactions/{transaction} {\n// Authenticated users can retrieve only their own transactions\nallow read: if resource.data.user == request.auth.uid;\n}\n\nmatch /users/{userid}/exchange/{exchangeid}/transactions/{transaction} {\n// Authenticated users can write to their own transactions subcollections\n// Writes must populate the user field with the correct auth id\nallow write: if userid == request.auth.uid && request.data.user == request.auth.uid\n}\n}\n}\n```""
 ""Q: Firestore에서 사용자가 자신의 거래(transaction) 문서를 읽고 쓸 수 있도록 보안 규칙을 설정하는 방법은 무엇인가요?\nA: Firestore에서 사용자가 자신의 거래(transaction) 문서를 읽고 쓸 수 있도록 보안 규칙을 설정하려면, 다음과 같은 규칙을 작성해야 합니다. 이 규칙은 인증된 사용자가 자신의 거래만 읽고 쓸 수 있도록 제한합니다.\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n\nmatch /databases/{database}/documents {\n\nmatch /{path=**}/transactions/{transaction} {\n// Authenticated users can retrieve only their own transactions\nallow read: if resource.data.user == request.auth.uid;\n}\n\nmatch /users/{userid}/exchange/{exchangeid}/transactions/{transaction} {\n// Authenticated users can write to their own transactions subcollections\n// Writes must populate the user field with the correct auth id\nallow write: if userid == request.auth.uid && request.data.user == request.auth.uid\n}\n}\n}\n```""
 ""Q: Cloud Firestore에서 게시물의 published 상태에 따라 쿼리를 허용하는 보안 규칙은 어떻게 작성하나요?\nA: 다음과 같이 published 상태에 따라 쿼리를 허용하는 보안 규칙을 작성할 수 있습니다.\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n\nmatch /databases/{database}/documents {\n// Returns `true` if the requested post is 'published'\n// or the user authored the post\nfunction authorOrPublished() {\nreturn resource.data.published == true || request.auth.uid == resource.data.author;\n}\n\nmatch /{path=**}/posts/{post} {\n// Anyone can query published posts\n// Authors can query their unpublished posts\nallow list: if authorOrPublished();\n// Anyone can retrieve a published post\n// Authors can retrieve an unpublished post\nallow get: if authorOrPublished();\n}\n}\n}\n```""
 ""Q: Firestore에서 컬렉션 그룹 쿼리를 보호하기 위해 published 필드를 사용하는 방법은 무엇인가요?\nA: 컬렉션 그룹 쿼리를 보호하기 위해 published 필드를 사용할 수 있습니다. 예를 들어, 다음과 같은 규칙을 작성할 수 있습니다.\n\n```plaintext\nrules_version = '2';\nservice cloud.firestore {\n\nmatch /databases/{database}/documents {\n\n// Returns `true` if the requested post is 'published'\n// or the user authored the post\nfunction authorOrPublished() {\nreturn resource.data.published == true || request.auth.uid == resource.data.author;\n}\n\nmatch /{path=**}/posts/{post} {\n\n// Anyone can query published posts\n// Authors can query their unpublished posts\nallow list: if authorOrPublished();\n\n// Anyone can retrieve a published post\n// Authors can retrieve an unpublished post\nallow get: if authorOrPublished();\n}\n\nmatch /forums/{forumid}/posts/{postid} {\n// Only a post's author can write to a post\nallow write: if request.auth.uid == resource.data.author;\n}\n}\n}\n```""
 'Q: Firestore 인덱스의 query_scope 필드는 어떤 역할을 하나요?\nA: | query_scope | QueryScope Indexes with a collection query scope specified allow queries against a collection that is the child of a specific document, specified at query time, and that has the same collection ID. Indexes with a collection group query scope specified allow queries against all collections descended from a specific document, specified at query time, and that have the same collection ID as this index.'
 ""Q: FirestoreAdmin API에서 ImportDocumentsRequest의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Required. Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to import. Unspecified means all collections included in the import. Each collection ID in this list must be unique. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique. |""
 ""Q: FirestoreAdmin API에서 인덱스의 QueryScope는 어떤 값이 있나요?\nA: | Enums |\n| --- |\n| QUERY_SCOPE_UNSPECIFIED | The query scope is unspecified. Not a valid option. |\n| COLLECTION | Indexes with a collection query scope specified allow queries against a collection that is the child of a specific document, specified at query time, and that has the collection ID specified by the index. |\n| COLLECTION_GROUP | Indexes with a collection group query scope specified allow queries against all collections that has the collection ID specified by the index. |\n| COLLECTION_RECURSIVE | Include all the collections's ancestor in the index. Only available for Datastore Mode databases. |""
 ""Q: FirestoreAdmin API에서 인덱스의 쿼리 범위(QueryScope) 값은 무엇이 있나요?\nA: | Enums |\n| --- |\n| QUERY_SCOPE_UNSPECIFIED | The query scope is unspecified. Not a valid option. |\n| COLLECTION | Indexes with a collection query scope specified allow queries against a collection that is the child of a specific document, specified at query time, and that has the collection ID specified by the index. |\n| COLLECTION_GROUP | Indexes with a collection group query scope specified allow queries against all collections that has the collection ID specified by the index. |\n| COLLECTION_RECURSIVE | Include all the collections's ancestor in the index. Only available for Datastore Mode databases.""
 'Q: Index의 query_scope 필드는 어떤 의미인가요?\nA: | Fields |\n| --- |\n| query_scope | QueryScope Indexes with a collection query scope specified allow queries against a collection that is the child of a specific document, specified at query time, and that has the same collection id. Indexes with a collection group query scope specified allow queries against all collections descended from a specific document, specified at query time, and that have the same collection id as this index.'
 'Q: 리소스 Location에서 지원하는 메서드는 무엇이 있나요?\nA: | Methods |\n| --- |\n| get | Gets information about a location. |\n| list | Lists information about the supported locations for this service. |'
 ""Q: FirestoreAdmin API에서 ImportDocumentsRequest의 요청 구조는 어떻게 되나요?\nA: ImportDocumentsRequest의 요청 구조는 다음과 같습니다:\n\n| Fields |\n| --- |\n| name | string Required. Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection IDs to import. Unspecified means all collections included in the import. Each collection ID in this list must be unique. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1.ExportDocumentsResponse.output_uri_prefix. |\n| namespace_ids[] | string An empty list represents all namespaces. This is the preferred usage for databases that don't use namespaces. An empty string element represents the default namespace. This should be used if the database has data in non-default namespaces, but doesn't want to include them. Each namespace in this list must be unique.""
 'Q: Cloud Firestore에서 문서를 가져오는 ImportDocuments 요청의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection ids to import. Unspecified means all collections included in the import. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an'
 ""Q: Firestore에서 거래(transaction) 문서의 user 필드에 대한 데이터 유효성 검사는 어떻게 수행하나요?\nA: Firestore에서 거래(transaction) 문서의 user 필드에 대한 데이터 유효성 검사는 보안 규칙을 통해 수행할 수 있습니다. 예를 들어, 다음과 같은 규칙을 사용하여 user 필드가 인증된 사용자의 UID와 일치하는지 확인할 수 있습니다.\n\n```javascript\nrules_version = '2';\nservice cloud.firestore {\n\nmatch /databases/{database}/documents {\n\nmatch /users/{userid}/exchange/{exchangeid}/transactions/{transaction} {\n// Authenticated users can write to their own transactions subcollections\n// Writes must populate the user field with the correct auth id\nallow write: if userid == request.auth.uid && request.data.user == request.auth.uid\n}\n}\n}\n```""
 'Q: Unity에서 Firestore에 새 문서를 추가하는 방법은 무엇인가요?\nA: DocumentReference docRef = db.Collection(""users"").Document(""alovelace"");\nDictionary<string, object> user = new Dictionary<string, object>\n{\n    { ""First"", ""Ada"" },\n    { ""Last"", ""Lovelace"" },\n    { ""Born"", 1815 },\n};\ndocRef.SetAsync(user).ContinueWithOnMainThread(task => {\n    Debug.Log(""Added data to the alovelace document in the users collection."");\n});'
 'Q: ListDocumentsRequest를 사용하여 Firestore에서 문서를 나열할 때 사용할 수 있는 선택적 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| parent | string Required. The parent resource name. In the format: projects/{project_id}/databases/{database_id}/documents or projects/{project_id}/databases/{database_id}/documents/{document_path}. For example: projects/my-project/databases/my-database/documents or projects/my-project/databases/my-database/documents/chatrooms/my-chatroom |\n| collection_id | string Optional. The collection ID, relative to parent, to list. For example: chatrooms or messages. This is optional, and when not provided, Firestore will list documents from all collections under the provided parent. |\n| page_size | int32 Optional. The maximum number of documents to return in a single response. Firestore may return fewer than this value. |\n| page_token | string Optional. A page token, received from a previous ListDocuments response. Provide this to retrieve the subsequent page. When paginating, all other parameters (with the exception of page_size) must match the values set in the request that generated the page token. |\n| order_by | string Optional. The optional ordering of the documents to return. For example: priority desc, __name__ desc. This mirrors the ORDER BY used in Firestore queries but in a string representation. When absent, documents are ordered based on __name__ ASC. |\n| mask | DocumentMask Optional. The fields to return. If not set, returns all fields. If a document has a field that is not present in this mask, that field will not be returned in the response. |\n| show_missing | bool If the list should show missing documents. A document is missing if it does not exist, but there are sub-documents nested underneath it.'
 'Q: Cloud Firestore Security Rules에서 역할 기반 액세스를 설정하는 방법은 무엇인가요?\nA: service cloud.firestore {\nmatch /databases/{database}/documents {\n// Assign roles to all users and refine access based on user roles\nmatch /some_collection/{document} {\nallow read: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == ""Reader""\nallow write: if request.auth != null && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == ""Writer""\n\n// Note: Checking for roles in your database using `get` (as in the code\n// above) or `exists` carry standard charges for read operations.\n}\n}\n}'
 'Q: Cloud Firestore에서 ImportDocuments 요청의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection ids to import. Unspecified means all collections included in the import. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1beta1.ExportDocumentsResponse.output_uri_prefix.'
 'Q: Cloud Firestore에서 ImportDocuments 요청의 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection ids to import. Unspecified means all collections included in the import. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1beta1.ExportDocumentsResponse.output_uri_prefix. |'
 'Q: ImportDocumentsRequest를 사용하여 문서를 가져올 때 필요한 필드는 무엇인가요?\nA: | Fields |\n| --- |\n| name | string Database to import into. Should be of the form: projects/{project_id}/databases/{database_id}. |\n| collection_ids[] | string Which collection ids to import. Unspecified means all collections included in the import. |\n| input_uri_prefix | string Location of the exported files. This must match the output_uri_prefix of an ExportDocumentsResponse from an export that has completed successfully. See: google.firestore.admin.v1beta2.ExportDocumentsResponse.output_uri_prefix.']","Firestore에서 `users` 컬렉션의 모든 사용자 정보를 가져오려면 `get` 메서드를 사용해야 합니다. 다음은 JavaScript와 Node.js에서 `users` 컬렉션의 모든 문서를 가져오는 예제입니다.

JavaScript (웹):
```javascript
import { collection, getDocs } from ""firebase/firestore"";

const querySnapshot = await getDocs(collection(db, ""users""));
querySnapshot.forEach((doc) => {
  console.log(`${doc.id} => ${doc.data()}`);
});
```

Node.js:
```javascript
const snapshot = await db.collection('users').get();
snapshot.forEach((doc) => {
  console.log(doc.id, '=>', doc.data());
});
```

이 코드는 Firestore에서 `users` 컬렉션의 모든 문서를 비동기적으로 가져와 각 문서의 ID와 데이터를 콘솔에 출력합니다.","Firestore에서 users 콜렉션의 모든 users 정보를 가져오려면 다음과 같은 코드를 사용할 수 있습니다:

```javascript
await db.collection(""users"").get().then((event) => {
    for (var doc in event.docs) {
        print(""${doc.id} => ${doc.data()}"");
    }
});
```"
Python에서 Cloud Firestore 초기화 방법,"['참고: 코드 샘플에서는 여러 언어를 다루지만 샘플을 설명하는 텍스트는 웹 메서드 이름을 참조합니다.시작하기 전에\n\n데이터를 설정, 추가 또는 업데이트하도록 Cloud Firestore를 초기화하려면 다음 단계를 완료해야 합니다.\n\nCloud Firestore 데이터베이스 만들기 자세한 내용은 Cloud Firestore 시작하기 [https://firebase.google.com/docs/firestore/quickstart?hl=ko]를 참조하세요.\n웹 또는 모바일 클라이언트 라이브러리를 사용하는 경우 보안 규칙으로 인증합니다. 자세한 내용은 보안 규칙 시작하기 [https://firebase.google.com/docs/firestore/manage-data/firestore/docs/security/get-started?hl=ko]를 참조하세요.\n서버 클라이언트 라이브러리 또는 REST API를 사용하는 경우 Identity and Access Management(IAM)로 인증합니다. 자세한 내용은 서버 클라이언트 라이브러리의 보안 [https://firebase.google.com/firestore/docs/security/iam?hl=ko]을 참조하세요.\n\nCloud Firestore 초기화\n\nCloud Firestore의 인스턴스를 초기화합니다.\n\nWeb\n\nimport { initializeApp } from ""firebase/app"";\nimport { getFirestore } from ""firebase/firestore"";\n\n// TODO: Replace the following with your app\'s Firebase project configuration\n// See: https://support.google.com/firebase/answer/7015592\nconst firebaseConfig = {\nFIREBASE_CONFIGURATION\n};\n\n// Initialize Firebase\nconst app = initializeApp(firebaseConfig);\n\n// Initialize Cloud Firestore and get a reference to the service\nconst db = getFirestore(app);'
 'Cloud Firestore의 인스턴스를 초기화합니다.\n\nWeb\n\nimport { initializeApp } from ""firebase/app"";\nimport { getFirestore } from ""firebase/firestore"";\n\n// TODO: Replace the following with your app\'s Firebase project configuration\n// See: https://support.google.com/firebase/answer/7015592\nconst firebaseConfig = {\nFIREBASE_CONFIGURATION\n};\n\n// Initialize Firebase\nconst app = initializeApp(firebaseConfig);\n\n// Initialize Cloud Firestore and get a reference to the service\nconst db = getFirestore(app);\n\nFIREBASE_CONFIGURATION을 웹 앱의 firebaseConfig [https://support.google.com/firebase/answer/7015592?hl=ko]로 바꿉니다.\n\n기기의 연결이 끊겨도 데이터를 유지하려면 오프라인 데이터 사용 설정 [https://firebase.google.com/docs/firestore/manage-data/enable-offline?hl=ko] 문서를 참조하세요.\n\nWeb\n\nimport firebase from ""firebase/app"";\nimport ""firebase/firestore"";\n\n// TODO: Replace the following with your app\'s Firebase project configuration\n// See: https://support.google.com/firebase/answer/7015592\nconst firebaseConfig = {\nFIREBASE_CONFIGURATION\n};\n\n// Initialize Firebase\nfirebase.initializeApp(firebaseConfig);\n\n// Initialize Cloud Firestore and get a reference to the service\nconst db = firebase.firestore();'
 'Python\n\nCloud Firestore SDK는 환경에 따라 다양한 방식으로 초기화됩니다. 가장 일반적인 방법은 아래와 같습니다. 전체 참조를 보려면 Admin SDK 초기화 [https://firebase.google.com/docs/admin/setup?hl=ko#initialize-sdk]를 참조하세요.\n\nGoogle Cloud에서 초기화import firebase_admin\nfrom firebase_admin import firestore_async\n\n# Application Default credentials are automatically created.\napp = firebase_admin.initialize_app()\ndb = firestore_async.client()firestore_async.py [https://github.com/firebase/firebase-admin-python/blob/3d3ef0c9b5f99044c92072b241f470d2dc9fe9d2/snippets/firestore/firestore_async.py#L22-L27]\n\n기존 애플리케이션 기본 사용자 인증 정보를 사용하여 SDK를 초기화할 수도 있습니다.\nimport firebase_admin\nfrom firebase_admin import credentials\nfrom firebase_admin import firestore_async\n\n# Use the application default credentials.\ncred = credentials.ApplicationDefault()\n\nfirebase_admin.initialize_app(cred)\ndb = firestore_async.client()firestore_async.py [https://github.com/firebase/firebase-admin-python/blob/3d3ef0c9b5f99044c92072b241f470d2dc9fe9d2/snippets/firestore/firestore_async.py#L32-L40]\n\n자체 서버에서 초기화\n자체 서버에서 Firebase Admin SDK를 사용하려면 서비스 계정 [https://cloud.google.com/compute/docs/authentication?hl=ko]을 사용합니다.'
 'import com.google.firebase.FirebaseApp;\nimport com.google.firebase.FirebaseOptions;\n\n// Use a service account\nInputStream serviceAccount = new FileInputStream(""path/to/serviceAccount.json"");\nGoogleCredentials credentials = GoogleCredentials.fromStream(serviceAccount);\nFirebaseOptions options = new FirebaseOptions.Builder()\n.setCredentials(credentials)\n.build();\nFirebaseApp.initializeApp(options);\n\nFirestore db = FirestoreClient.getFirestore();\n\nPython\n\nCloud Firestore SDK는 환경에 따라 다양한 방식으로 초기화됩니다. 가장 일반적인 방법은 아래와 같습니다. 전체 참조를 보려면 Admin SDK 초기화 [https://firebase.google.com/docs/admin/setup?hl=ko#initialize-sdk]를 참조하세요.\n\nGoogle Cloud에서 초기화import firebase_admin\nfrom firebase_admin import firestore\n\n# Application Default credentials are automatically created.\napp = firebase_admin.initialize_app()\ndb = firestore.client()firestore.py [https://github.com/firebase/firebase-admin-python/blob/3d3ef0c9b5f99044c92072b241f470d2dc9fe9d2/snippets/firestore/firestore.py#L20-L25]\n\n기존 애플리케이션 기본 사용자 인증 정보를 사용하여 SDK를 초기화할 수도 있습니다.\nimport firebase_admin\nfrom firebase_admin import credentials\nfrom firebase_admin import firestore'
 '기본 모드에서 Firestore 초기화\n\nFirestore의 인스턴스를 초기화합니다.\n\n--- 탭: 자바 [https://cloud.google.com/firestore/native/docs/create-database-server-client-library?hl=ko#%EC%9E%90%EB%B0%94] ---\nimport com.google.cloud.firestore.Firestore [https://cloud.google.com/java/docs/reference/google-cloud-firestore/latest/com.google.cloud.firestore.Firestore.html?hl=ko];\nimport com.google.cloud.firestore.FirestoreOptions [https://cloud.google.com/java/docs/reference/google-cloud-firestore/latest/com.google.cloud.firestore.FirestoreOptions.html?hl=ko];\nFirestoreOptions firestoreOptions =\nFirestoreOptions.getDefaultInstance().toBuilder()\n.setProjectId(projectId)\n.setCredentials(GoogleCredentials.getApplicationDefault())\n.build();\nFirestore db = firestoreOptions.getService();\nQuickstart.java [https://github.com/googleapis/java-firestore/blob/02c1372447e22b3e635f5997ce9a6113144b3734/samples/snippets/src/main/java/com/example/firestore/Quickstart.java#L47-L52]\n\n--- 탭: Python [https://cloud.google.com/firestore/native/docs/create-database-server-client-library?hl=ko#python] ---\nfrom google.cloud import firestore'
 '클라이언트가 Realtime Database에 데이터를 쓸 때마다 Cloud Firestore에 신규 또는 변경 데이터를 쓰는 함수를 작성합니다. Cloud Functions의 Realtime Database 트리거 [https://firebase.google.com/docs/functions/database-events?hl=ko]에 대해 자세히 알아보세요.\n\nCloud Firestore를 마이그레이션된 데이터의 기본 데이터베이스로 설정\n\nCloud Firestore를 일부 데이터의 기본 데이터베이스로 사용하기로 결정했다면 설정한 모든 데이터 미러링 함수를 고려하고 Cloud Firestore Security Rules를 검증합니다.\n\nCloud Functions를 사용하여 데이터베이스를 일치시키려는 경우 루프 내에서 두 데이터베이스의 쓰기 작업이 중복되지 않도록 주의합니다. 단일 데이터베이스에 쓰도록 함수를 전환하거나, 함수를 완전히 삭제하고 아직 Realtime Database에 연결된 앱의 마이그레이션된 데이터에 대한 쓰기 기능을 단계적으로 종료할 수도 있습니다. 앱에서 이 문제를 처리하는 방법은 구체적인 요구사항과 사용자에 따라 다릅니다.\n데이터가 올바르게 보호되는지 확인합니다. Cloud Firestore Security Rules 또는 IAM 설정을 검증합니다.\n\n의견 보내기'
 'Source URL: https://firebase.google.com/docs/firestore/vector-search?hl=ko\nTitle: 벡터 임베딩으로 검색\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\n벡터 임베딩으로 검색\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지에서는 Cloud Firestore를 사용하여 다음 기법을 사용하여 K-최근접 이웃(KNN) 벡터 검색을 수행하는 방법을 보여줍니다.\n\n벡터 값 저장\nKNN 벡터 색인 만들기 및 관리\n지원되는 벡터 거리 측정 중 하나를 사용하여 K-최근접 이웃(KNN) 쿼리 수행\n\n시작하기 전에\n\nCloud Firestore에 임베딩을 저장하기 전에 벡터 임베딩을 생성해야 합니다. Cloud Firestore는 임베딩을 생성하지 않습니다. Vertex\xa0AI와 같은 서비스를 사용하여 Cloud Firestore 데이터에서 텍스트 임베딩 [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings?hl=ko]과 같은 벡터 값을 만들 수 있습니다. 그런 다음 이러한 임베딩을 Cloud Firestore 문서에 다시 저장할 수 있습니다.\n\n임베딩에 대해 자세히 알아보려면 임베딩이란 무엇인가요? [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings?hl=ko#embedding-types]를 참고하세요.\n\nVertex\xa0AI로 텍스트 임베딩을 가져오는 방법을 알아보려면 텍스트 임베딩 가져오기 [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings?hl=ko]를 참고하세요.\n\n벡터 임베딩 저장\n\n다음 예는 Cloud Firestore에 벡터 임베딩을 저장하는 방법을 보여줍니다.\n\n벡터 임베딩을 사용한 쓰기 작업\n\n다음 예시는 Cloud Firestore 문서에 벡터 임베딩을 저장하는 방법을 보여줍니다.'
 'Source URL: https://cloud.google.com/firestore/docs/langchain?hl=ko\nTitle: LangChain을 사용하여 LLM 기반 애플리케이션 빌드\nbookmark_border\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\n\n의견 보내기\n\n이 페이지의 내용LangChain이란 무엇인가요? [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#what-is-langchain-mysql]Firestore용 LangChain 구성요소 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#langchain-components]Firestore용 벡터 저장소 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#vector-store]벡터 저장소 절차 가이드 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#vector_store_procedure_guide]Firestore용 문서 로더 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#document-loader]문서 로더 절차 가이드 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#document_loader_procedure_guide]Firestore의 채팅 메시지 기록 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#chat-message-history]채팅 메시지 기록 절차 가이드 [https://cloud.google.com/firestore/native/docs/langchain?hl=ko#chat_message_history_procedure_guide]\n\nLangChain을 사용하여 LLM 기반 애플리케이션 빌드\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n프리뷰'
 'Source URL: https://firebase.google.com/docs/firestore/use-rest-api?hl=ko\nTitle: Cloud Firestore REST API 사용\n\n이제 MongoDB 호환성을 갖춘 Cloud Firestore Enterprise 버전을 사용할 수 있습니다. 자세히 알아보기 [https://firebase.google.com/docs/firestore/enterprise/mongodb-compatibility-overview?hl=ko]\n\n의견 보내기\n\nCloud Firestore REST API 사용\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\nCloud Firestore를 사용하는 가장 쉬운 방법은 기본 클라이언트 라이브러리 중 하나를 사용하는 것이지만, 경우에 따라서는 REST API를 직접 호출하는 방법이 유용할 수 있습니다.\n\n다음과 같은 사용 사례에서는 REST API가 유용할 수 있습니다.\n\n사물 인터넷(IoT) 기기와 같이 리소스가 제한되어 전체 클라이언트 라이브러리를 실행할 수 없는 환경에서 Cloud Firestore에 액세스할 때\n데이터베이스 관리를 자동화하거나 상세한 데이터베이스 메타데이터를 검색할 때\n\ngRPC 지원 언어 [https://grpc.io/about/#osp]를 사용한다면 REST API 대신 RPC API [https://firebase.google.com/docs/firestore/reference/rpc/?hl=ko]를 사용해 보세요.\n\n인증 및 승인\n\nCloud Firestore REST API는 인증에 Firebase Authentication [https://firebase.google.com/docs/auth/?hl=ko] ID 토큰이나 Google ID OAuth 2.0 [https://developers.google.com/identity/protocols/OAuth2?hl=ko] 토큰을 허용합니다. 개발자가 제공한 토큰이 요청의 승인에 영향을 미칩니다.'
 '벡터 임베딩으로 검색\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지에서는 Firestore를 사용하여 다음 기법을 사용하여 K-최근접 이웃 (KNN) 벡터 검색을 수행하는 방법을 보여줍니다.\n\n벡터 값 저장\nKNN 벡터 색인 만들기 및 관리\n지원되는 벡터 거리 측정 중 하나를 사용하여 K-최근접 이웃(KNN) 쿼리 수행\n\n시작하기 전에\n\nFirestore에 임베딩을 저장하기 전에 벡터 임베딩을 생성해야 합니다. Firestore는 임베딩을 생성하지 않습니다. Vertex AI와 같은 서비스를 사용하여 Firestore 데이터에서 텍스트 임베딩 [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings?hl=ko]과 같은 벡터 값을 만들 수 있습니다. 그런 다음 이러한 임베딩을 Firestore 문서에 다시 저장할 수 있습니다.\n\n임베딩에 대해 자세히 알아보려면 임베딩이란 무엇인가요? [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings?hl=ko#embedding-types]를 참고하세요.\n\nVertex AI로 텍스트 임베딩을 가져오는 방법을 알아보려면 텍스트 임베딩 가져오기 [https://cloud.google.com/vertex-ai/generative-ai/docs/embeddings/get-text-embeddings?hl=ko]를 참고하세요.\n\n벡터 임베딩 저장\n\n다음 예는 Firestore에 벡터 임베딩을 저장하는 방법을 보여줍니다.\n\n벡터 임베딩을 사용한 쓰기 작업\n\n다음 예시는 Firestore 문서에 벡터 임베딩을 저장하는 방법을 보여줍니다.\n\n--- 탭: Python [https://cloud.google.com/firestore/native/docs/vector-search?hl=ko#python] ---\n```\nfrom google.cloud import firestore\nfrom google.cloud.firestore_v1.vector import Vector'
 ""client, err := app.Firestore(ctx)\nif err != nil {\nlog.Fatalln(err)\n}\ndefer client.Close()\n\nPHP\n\nPHP\n\nCloud Firestore 클라이언트 설치 및 생성에 관한 자세한 내용은 Cloud Firestore 클라이언트 라이브러리 [https://firebase.google.com/firestore/docs/reference/libraries?hl=ko]를 참조하세요.\n\nuse Google\\Cloud\\Firestore\\FirestoreClient;\n\n/**\n* Initialize Cloud Firestore with default project ID.\n*/\nfunction setup_client_create(string $projectId = null)\n{\n// Create the Cloud Firestore client\nif (empty($projectId)) {\n// The `projectId` parameter is optional and represents which project the\n// client will act on behalf of. If not supplied, the client falls back to\n// the default project inferred from the environment.\n$db = new FirestoreClient();\nprintf('Created Cloud Firestore client with default project ID.' . PHP_EOL);\n} else {\n$db = new FirestoreClient([\n'projectId' => $projectId,\n]);\nprintf('Created Cloud Firestore client with project ID: %s' . PHP_EOL, $projectId);\n}\n}setup_client_create.php [https://github.com/GoogleCloudPlatform/php-docs-samples/blob/5be36a7311875e7635e96a0cd9072cfb425c9e84/firestore/src/setup_client_create.php#L27-L47]""
 '의견 보내기\n\nCloud Firestore 시작하기\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지의 내용Cloud Firestore 데이터베이스 만들기 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#create]개발 환경 설정 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#set_up_your_development_environment](선택사항) Firebase Local Emulator Suite으로 프로토타입 제작 및 테스트 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#optional_prototype_and_test_with]Cloud Firestore 초기화 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#initialize]데이터 추가 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#add_data]데이터 읽기 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#read_data]데이터 보안 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#secure_your_data]동영상 튜토리얼 보기 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#watch_a_video_tutorial]다음 단계 [https://firebase.google.com/docs/firestore/quickstart?hl=ko#next_steps]\n\n이 빠른 시작에서는 Cloud Firestore를 설정하고 데이터를 추가한 후 Firebase Console에서 방금 추가한 데이터를 보는 방법을 보여줍니다.\n\nCloud Firestore 데이터베이스 만들기'
 '의견 보내기\n\nCloud Firestore 시작하기\n\nbookmark_borderbookmark\n\n컬렉션을 사용해 정리하기\n\n내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.\n\n이 페이지의 내용Cloud Firestore 데이터베이스 만들기 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#create]개발 환경 설정 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#set_up_your_development_environment](선택사항) Firebase Local Emulator Suite으로 프로토타입 제작 및 테스트 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#optional_prototype_and_test_with]Cloud Firestore 초기화 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#initialize]데이터 추가 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#add_data]데이터 읽기 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#read_data]데이터 보안 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#secure_your_data]동영상 튜토리얼 보기 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#watch_a_video_tutorial]다음 단계 [https://firebase.google.com/docs/firestore/quickstart?tab=ios%2B&hl=ko#next_steps]\n\n이 빠른 시작에서는 Cloud Firestore를 설정하고 데이터를 추가한 후 Firebase Console에서 방금 추가한 데이터를 보는 방법을 보여줍니다.\n\nCloud Firestore 데이터베이스 만들기'
 'initializeApp();\nconst db = getFirestore();\n\nexports.writetofirestore = onDocumentWritten(""some/doc"", (event) => {\ndb.doc(\'some/otherdoc\').set({ ... });\n});\n\nexports.writetofirestore = onDocumentWritten(\'users/{userId}\', (event) => {\ndb.doc(\'some/otherdoc\').set({\n// Update otherdoc\n});\n});\n\nPythonfrom firebase_admin import firestore, initialize_app\nimport google.cloud.firestore\n\ninitialize_app()\n\n@on_document_written(document=""some/doc"")\ndef myfunction(event: Event[Change[DocumentSnapshot | None]]) -> None:\nfirestore_client: google.cloud.firestore.Client = firestore.client()\nfirestore_client.document(""another/doc"").set({\n# ...\n})\n\n참고: Cloud Functions에서 수행되는 읽기 및 쓰기는 보안 규칙으로 제어되지 않으며 데이터베이스의 모든 부분에 액세스할 수 있습니다.\n제한사항\n\nCloud Functions용 Cloud Firestore 트리거의 다음 제한사항에 유의하세요.'
 ""서비스 계정 가장 [https://cloud.google.com/firestore/native/docs/authentication?hl=ko#sa-impersonation]\n\n클라이언트 라이브러리 또는 서드 파티 도구\n\n로컬 환경에서 애플리케이션 기본 사용자 인증 정보(ADC) [https://cloud.google.com/docs/authentication/application-default-credentials?hl=ko]를 설정합니다.\n\nInstall [https://cloud.google.com/sdk/docs/install?hl=ko] the Google Cloud CLI.\n\nAfter installation,\ninitialize [https://cloud.google.com/sdk/docs/initializing?hl=ko] the Google Cloud CLI by running the following command:\n\ngcloud init\n\nIf you're using an external identity provider (IdP), you must first\nsign in to the gcloud CLI with your federated identity [https://cloud.google.com/iam/docs/workforce-log-in-gcloud?hl=ko].\n\nIf you're using a local shell, then create local authentication credentials for your user\naccount:\n\ngcloud auth application-default login\n\nYou don't need to do this if you're using Cloud Shell.\n\nIf an authentication error is returned, and you are using an external identity provider\n(IdP), confirm that you have\nsigned in to the gcloud CLI with your federated identity [https://cloud.google.com/iam/docs/workforce-log-in-gcloud?hl=ko].""
 "". You'll learn first hand how Firebase's Firestore and Storage streamline data management and mediaYouTubeNon-relational databases design patterns: How Shopify leverages them to power their businessWhen your data outgrows the confines of traditional relational models, Google Cloud's databases offer the solution. This session will explore how to harness the power of distributed architectures and flexible schemas to handle massive datasets. We'llYouTubeCloud SQL, Cloud Spanner, or Firestore?Be a Cloud Digital Leader! https://goo.gle/CDL What's the difference between Cloud SQL, Cloud Spanner, and Firestore, and how do you know when to choose one over the other? This video breaks it down to help you on your journey to become Cloud DigitalYouTubeBuilding a next-generation scalable gaming platform using FirestoreGaming innovators rely on Firestore for its flexibility, simplified scalability and hands-free serverless management""
 ""YouTubeFirestore is now compatible with MongoDBLearn more: https://goo.gle/4klM1Bn This highly-requested capability is now available: Firestore is now compatible with MongoDB. This means you can use MongoDB's tools and drivers while taking advantage of Firestore's serverless features to buildYouTubeGen AI databases: speed, scale and securityReady to get started? → https://goo.gle/4icxI12 How do you choose the right database for generative AI? Learn about speed, scale, and security with AlloyDB, Spanner, Firestore, and Cloud SQL. Discover how to handle massive data, complex queries, andYouTubeVector-enabled databases: unlock semantic search!Enroll today! → https://goo.gle/4icxI12 Unlock the power of generative AI! Learn how vector embeddings and Google Cloud databases (AlloyDB, Spanner, Cloud SQL, BigQuery, Firestore) revolutionize data handling for AI applications. Discover how toYouTubeRelational vs. NoSQL: databases explained simplyReady to learn more? → https://goo.gle/4icxI12 Demystifying databases! Learn the core differences between relational and NoSQL databases on Google Cloud. We'll cover Cloud SQL, Spanner, Firestore, Bigtable, and more""
 ""BigQuery Sandbox → https://goo.gle/3RHQoZS Did you know there are multiple ways to store data on Google Cloud? In this episode of Google Cloud Platform Essentials, Ryan Matsumoto shows how youYouTubeGet started with FirestoreHere to bring you the latest news in the startup program by Google Cloud is Mirabel Tukiman! Welcome to the second season of the Google Cloud Technical Guides for Startups - the Build Series. Build Series - Episode 3: How to configure Firestore TuneYouTubeAsynchronous operations in UI using Workflows and FirestoreMany app operations take time. Long computations may take minutes or hours, perhaps waiting for limited resources and retrying failures. Connecting to real-world processes like 3D printing or a human approver can take days. When users perform theseYouTubeIntroduction to Google CloudCheckout this architecture in our NEW Architecture Diagramming Tool → https://goo.gle/3GUIztk When it comes to building your organization's app in the cloud you have many options. In this video Priyanka gives the complete overview of various GoogleYouTubeDesigning a serverless finance system on Google CloudIdentity Aware Proxy → https://goo.gle/3DqLybV""
 'August 09, 2018\n\nWe added two new features to help you work with arrays:\n\nArray contains queries [https://cloud.google.com/firestore/docs/query-data/queries#array_membership]: query for documents that contain a particular array value.\nArray transforms [https://cloud.google.com/firestore/docs/manage-data/add-data#update_elements_in_an_array]: the arrayUnion() and arrayRemove() functions allow you to directly modify array field values.\n\nAugust 08, 2018\n\nYou can now create a Cloud Firestore database in Datastore mode [https://cloud.google.com/firestore/docs/firestore-or-datastore#choosing_a_database]. Datastore mode allows you to use Cloud Datastore client libraries with an improved Cloud Firestore storage layer, removing eventual consistency limitations.\n\nCloud Firestore now supports the europe-west3 and us-east1 regions, see Cloud Firestore Locations [https://cloud.google.com/firestore/docs/locations].\n\nYou can now add single-field index exemptions [https://cloud.google.com/firestore/docs/concepts/index-overview#exemptions] to exempt specific fields from automatic indexing.'
 'Q: Python에서 Cloud Firestore를 초기화하기 위한 기본적인 코드 예시는 무엇인가요?\nA: Python에서 Cloud Firestore를 초기화하는 기본적인 방법은 다음과 같습니다.\n\n```python\nimport firebase_admin\nfrom firebase_admin import firestore\n\n# Application Default credentials are automatically created.\napp = firebase_admin.initialize_app()\ndb = firestore.client()\n```'
 'Q: Python에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Python에서 Cloud Firestore를 초기화하는 방법은 다음과 같습니다. Firestore 인스턴스를 가져오는 코드는 다음과 같습니다.\n\n```python\ndb = FirebaseFirestore.instance;\n```'
 'Q: Python에서 Cloud Firestore를 비동기적으로 초기화하는 방법은 무엇인가요?\nA: Python에서 Cloud Firestore를 비동기적으로 초기화하는 방법은 다음과 같습니다:\n\n```python\nimport firebase_admin\nfrom firebase_admin import firestore_async\n\n# Application Default credentials are automatically created.\napp = firebase_admin.initialize_app()\ndb = firestore_async.client()\n```'
 'Q: Python에서 Cloud Firestore를 비동기적으로 초기화하는 방법은 무엇인가요?\nA: Python에서 Cloud Firestore를 비동기적으로 초기화하는 방법은 다음과 같습니다. 전체 참조를 보려면 Admin SDK 초기화 [https://firebase.google.com/docs/admin/setup?hl=ko#initialize-sdk]를 참조하세요.\n\n```python\nimport firebase_admin\nfrom firebase_admin import firestore_async\n\n# Application Default credentials are automatically created.\napp = firebase_admin.initialize_app()\ndb = firestore_async.client()\n```'
 'Q: Python에서 Cloud Firestore를 비동기적으로 초기화하는 방법은 무엇인가요?\nA: 기존 애플리케이션 기본 사용자 인증 정보를 사용하여 SDK를 초기화할 수 있습니다.\n\n```python\nimport firebase_admin\nfrom firebase_admin import credentials\nfrom firebase_admin import firestore_async\n\n# Use the application default credentials.\ncred = credentials.ApplicationDefault()\n\nfirebase_admin.initialize_app(cred)\ndb = firestore_async.client()\n```'
 'Q: Swift에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Swift에서 Cloud Firestore를 초기화하는 방법은 다음과 같습니다:\n\n```swift\nimport FirebaseCore\nimport FirebaseFirestore\nFirebaseApp.configure()\n\nlet db = Firestore.firestore()\n```'
 'Q: Swift에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Swift에서 Cloud Firestore를 초기화하는 방법은 다음과 같습니다. \n\n```swift\nimport FirebaseCore\nimport FirebaseFirestore\nFirebaseApp.configure()\n\nlet db = Firestore.firestore()\n```'
 'Q: Swift에서 Firestore를 초기화하는 방법은 무엇인가요?\nA: Swift에서 Firestore를 초기화하는 방법은 다음과 같습니다: \n```swift\nimport FirebaseCore\nimport FirebaseFirestore\nFirebaseApp.configure()\n\nlet db = Firestore.firestore()\n```'
 'Q: Objective-C에서 Firestore를 초기화하는 방법은 무엇인가요?\nA: Objective-C에서 Firestore를 초기화하는 방법은 다음과 같습니다: \n```objective-c\n@import FirebaseCore;\n@import FirebaseFirestore;\n\n[FIRApp configure];\nFIRFirestore *defaultFirestore = [FIRFirestore firestore];\n```'
 'Q: Java에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Java에서 Cloud Firestore를 초기화하는 방법은 다음과 같습니다. FirebaseFirestore 인스턴스를 가져오는 코드는 다음과 같습니다.\n\n```java\n// Access a Cloud Firestore instance from your Activity\nFirebaseFirestore db = FirebaseFirestore.getInstance();\n```'
 'Q: Swift에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Swift에서 Cloud Firestore를 초기화하는 방법은 다음과 같습니다. FirebaseCore와 FirebaseFirestore를 임포트한 후, FirebaseApp을 구성하고 Firestore 인스턴스를 가져옵니다.\n\n```swift\nimport FirebaseCore\nimport FirebaseFirestore\nFirebaseApp.configure()\n\nlet db = Firestore.firestore()\n```'
 ""Q: Node.js에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Node.js에서 Cloud Firestore를 초기화하는 방법은 다음과 같습니다.\n\n```javascript\nconst { initializeApp, applicationDefault } = require('firebase-admin/app');\nconst { getFirestore } = require('firebase-admin/firestore');\ninitializeApp();\n\nconst db = getFirestore();\n```""
 'Q: Python에서 기존 애플리케이션 기본 사용자 인증 정보를 사용하여 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: 기존 애플리케이션 기본 사용자 인증 정보를 사용하여 SDK를 초기화하는 방법은 다음과 같습니다.\n\n```python\nimport firebase_admin\nfrom firebase_admin import credentials\nfrom firebase_admin import firestore\n\n# Use the application default credentials.\ncred = credentials.ApplicationDefault()\n\nfirebase_admin.initialize_app(cred)\ndb = firestore.client()\n```'
 'Q: Swift에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Swift에서 Cloud Firestore를 초기화하려면 다음 코드를 사용합니다.\n```\nimport FirebaseCore\nimport FirebaseFirestore\nFirebaseApp.configure()\n\nlet db = Firestore.firestore()\n```'
 'Q: Swift에서 Firestore를 초기화하는 방법은 무엇인가요?\nA: Swift에서 Firestore를 초기화하는 방법은 다음과 같습니다.\n\n```swift\nimport FirebaseCore\nimport FirebaseFirestore\n\nFirebaseApp.configure()\n\nlet db = Firestore.firestore()\n```\n\n참고: 이 제품은 watchOS 및 앱 클립 대상에서 사용할 수 없습니다.'
 'Q: Objective-C에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Objective-C에서 Cloud Firestore를 초기화하는 방법은 다음과 같습니다. FirebaseCore와 FirebaseFirestore를 임포트한 후, FIRApp을 구성하고 Firestore 인스턴스를 가져옵니다.\n\n```objective-c\n@import FirebaseCore;\n@import FirebaseFirestore;\n\n// Use Firebase library to configure APIs\n[FIRApp configure];\n\nFIRFirestore *defaultFirestore = [FIRFirestore firestore];\n```'
 'Q: Swift에서 Firestore를 초기화하는 방법은 무엇인가요?\nA: 다음 코드를 사용하여 Firestore를 초기화합니다.\n```swift\nimport FirebaseCore\nimport FirebaseFirestore\n\nFirebaseApp.configure()\n\nlet db = Firestore.firestore()\n```'
 'Q: Java에서 Cloud Firestore를 초기화하는 방법은 무엇인가요?\nA: Java에서 Cloud Firestore를 초기화하려면 다음과 같은 코드를 사용합니다:\n\n```java\n// Access a Cloud Firestore instance from your Activity\nFirebaseFirestore db = FirebaseFirestore.getInstance();\n```'
 'Q: Swift에서 Firestore를 초기화하는 방법은 무엇인가요?\nA: Swift에서 Firestore를 초기화하려면, 다음과 같은 코드를 사용합니다.\n\n```swift\nimport FirebaseCore\nimport FirebaseFirestore\n\nFirebaseApp.configure()\n\nlet db = Firestore.firestore()\n```'
 'Q: Python에서 Firestore 클라이언트를 초기화하는 방법은 무엇인가요?\nA: Python에서 Firestore 클라이언트를 초기화하려면 다음 코드를 사용합니다:\n\n```python\nfrom google.cloud import firestore\n\ndb = firestore.Client(project=""my-project-id"")\n```'
 'Q: Firestore 데이터베이스를 만들기 위해 필요한 첫 번째 단계는 무엇인가요?\nA: Firestore 데이터베이스를 만들기 위해서는 먼저 Google Cloud 계정에 로그인하고, Google Cloud 콘솔에서 프로젝트를 선택하거나 새 프로젝트를 생성해야 합니다.'
 'Q: Cloud Firestore를 Android 앱에 추가하는 방법은 무엇인가요?\nA: 다음과 같이 dependencies 블록에 Cloud Firestore 라이브러리를 추가합니다:\n```\ndependencies {\n// Import the BoM for the Firebase platform\nimplementation(platform(""com.google.firebase:firebase-bom:34.2.0""))\n\n// Declare the dependency for the Cloud Firestore library\n// When using the BoM, you don\'t specify versions in Firebase library dependencies\nimplementation(""com.google.firebase:firebase-firestore"")\n}\n```'
 'Q: Cloud Firestore를 Android 앱에 추가하는 방법은 무엇인가요?\nA: ```\ndependencies {\n// Import the BoM for the Firebase platform\nimplementation(platform(""com.google.firebase:firebase-bom:34.2.0""))\n\n// Declare the dependency for the Cloud Firestore library\n// When using the BoM, you don\'t specify versions in Firebase library dependencies\nimplementation(""com.google.firebase:firebase-firestore"")\n}\n```'
 'Q: Cloud Firestore를 Android 앱에 추가하기 위해 필요한 Gradle 설정은 무엇인가요?\nA: ```\ndependencies {\n// Import the BoM for the Firebase platform\nimplementation(platform(""com.google.firebase:firebase-bom:34.2.0""))\n\n// Declare the dependency for the Cloud Firestore library\n// When using the BoM, you don\'t specify versions in Firebase library dependencies\nimplementation(""com.google.firebase:firebase-firestore"")\n}\n```'
 'Q: Cloud Firestore를 Android 앱에 추가하는 방법은 무엇인가요?\nA: Android 앱에 Cloud Firestore를 추가하려면 다음과 같은 종속성을 build.gradle 파일에 추가해야 합니다: \n```\ndependencies {\n    // Import the BoM for the Firebase platform\n    implementation(platform(""com.google.firebase:firebase-bom:34.2.0""))\n\n    // Declare the dependency for the Cloud Firestore library\n    // When using the BoM, you don\'t specify versions in Firebase library dependencies\n    implementation(""com.google.firebase:firebase-firestore"")\n}\n```'
 ""Q: iOS에서 Cloud Firestore SDK의 빌드 시간을 개선하는 방법은 무엇인가요?\nA: iOS에서 Cloud Firestore SDK의 빌드 시간을 개선하려면 Podfile의 target 'Runner' do 블록에 다음 줄을 추가하여 사전 컴파일된 버전을 사용합니다.\n```\ntarget 'Runner' do\n  use_frameworks!\n  use_modular_headers!\n\n  pod 'FirebaseFirestore',\n    :git => 'https://github.com/invertase/firestore-ios-sdk-frameworks.git',\n    :tag => 'IOS_SDK_VERSION'\n\n  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))\n  target 'RunnerTests' do\n    inherit! :search_paths\n  end\nend\n```\nIOS_SDK_VERSION을 firebase_core의 firebase_sdk_version.rb 파일에 지정된 Firebase iOS SDK 버전으로 바꿉니다.""
 'Q: RestoreDatabaseMetadata의 progressPercentage 필드는 어떤 정보를 포함하나요?\nA: progressPercentage | object (Progress) How far along the restore is as an estimated percentage of remaining time.'
 'Q: RestoreDatabaseMetadata에서 progressPercentage 필드는 어떤 정보를 제공하나요?\nA: progressPercentage | object (Progress) How far along the restore is as an estimated percentage of remaining time.'
 'Q: C++에서 Firestore 클라이언트를 생성하는 방법은 무엇인가요?\nA: // Make sure the call to `Create()` happens some time before you call Firestore::GetInstance().\nApp::Create();\nFirestore* db = Firestore::GetInstance();'
 'Q: C++에서 Firestore 인스턴스를 초기화하는 방법은 무엇인가요?\nA: 다음은 C++에서 Firestore 인스턴스를 초기화하는 코드입니다.\n\n```cpp\n// Make sure the call to `Create()` happens some time before you call Firestore::GetInstance().\nApp::Create();\nFirestore* db = Firestore::GetInstance();\n```'
 'Q: Kotlin에서 카운터를 생성하는 createCounter 함수는 어떻게 구현되나요?\nA: Kotlin에서 카운터를 생성하는 createCounter 함수는 다음과 같이 구현됩니다:\n\n```kotlin\nfun createCounter(ref: DocumentReference, numShards: Int): Task<Void> {\n    // Initialize the counter document, then initialize each shard.\n    return ref.set(Counter(numShards))\n        .continueWithTask { task ->\n            if (!task.isSuccessful) {\n                throw task.exception!!\n            }\n\n            val tasks = arrayListOf<Task<Void>>()\n\n            // Initialize each shard with count=0\n            for (i in 0 until numShards) {\n                val makeShard = ref.collection(""shards"")\n                    .document(i.toString())\n                    .set(Shard(0))\n\n                tasks.add(makeShard)\n            }\n\n            Tasks.whenAll(tasks)\n        }\n}\n```'
 ""Q: Node.js에서 Cloud Firestore의 'regions' 배열 필드에 여러 지역을 원자적으로 추가하는 방법은 무엇인가요?\nA: Node.js에서 Cloud Firestore의 'regions' 배열 필드에 여러 지역을 원자적으로 추가하는 방법은 다음과 같습니다.\n\n```javascript\nconst multipleUnionRes = await washingtonRef.update({\n  regions: FieldValue.arrayUnion('south_carolina', 'texas')\n  // Alternatively, you can use spread operator in ES6 syntax\n  // const newRegions = ['south_carolina', 'texas']\n  // regions: FieldValue.arrayUnion(...newRegions)\n});\n```""
 'Q: Swift에서 Firestore에서 문서를 가져오는 방법은 무엇인가요?\nA: do {\nlet snapshot = try await db.collection(""users"").getDocuments()\nfor document in snapshot.documents {\nprint(""\\(document.documentID) => \\(document.data())"")\n}\n} catch {\nprint(""Error getting documents: \\(error)"")\n}'
 'Q: Python에서 Cloud Firestore에서 단일 문서의 내용을 검색하는 방법은 무엇인가요?\nA: 다음은 Python에서 Cloud Firestore에서 단일 문서의 내용을 검색하는 방법입니다.\n\n```python\n# Assume you have a Firestore client instance named \'db\'\ndoc_ref = db.collection(""cities"").document(""SF"")\ndoc_snap = doc_ref.get()\nif doc_snap.exists:\n    print(""Document data:"", doc_snap.to_dict())\nelse:\n    print(""No such document!"")\n```'
 ""Q: iOS용 Firestore SDK의 빌드 시간을 개선하기 위해 Podfile에 추가해야 하는 설정은 무엇인가요?\nA: Podfile의 target 'Runner' do 블록에 다음 줄을 추가하여 사전 컴파일된 버전을 사용하면 됩니다.\n```\ntarget 'Runner' do\n  use_frameworks!\n  use_modular_headers!\n\n  pod 'FirebaseFirestore',\n    :git => 'https://github.com/invertase/firestore-ios-sdk-frameworks.git',\n    :tag => 'IOS_SDK_VERSION'\n\n  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))\n  target 'RunnerTests' do\n    inherit! :search_paths\n  end\nend\n```\nIOS_SDK_VERSION을 firebase_core의 firebase_sdk_version.rb 파일에 지정된 Firebase iOS SDK 버전으로 바꿉니다.""
 'Q: Ruby에서 Firestore 컬렉션의 실시간 업데이트를 리슨할 때, 어떤 코드를 사용해야 하나요?\nA: Ruby에서 Firestore 컬렉션의 실시간 업데이트를 리슨하기 위해 다음과 같은 코드를 사용할 수 있습니다.\n\n```ruby\nquery = firestore.col(collection_path).where :state, :==, ""CA""\nadded = []\nmodified = []\nremoved = []\n\n# Watch the collection query.\nlistener = query.listen do |snapshot|\n  puts ""Callback received query snapshot.""\n  puts ""Current cities in California:""\n  snapshot.changes.each do |change|\n    if change.added?\n      puts ""New city: #{change.doc.document_id}""\n      added << snapshot\n    elsif change.modified?\n      puts ""Modified city: #{change.doc.document_id}""\n      modified << snapshot\n    elsif change.removed?\n      puts ""Removed city: #{change.doc.document_id}""\n      removed << snapshot\n    end\n  end\nend\n```'
 'Q: Swift에서 Cloud Firestore의 전체 컬렉션을 가져오는 방법은 무엇인가요?\nA: Swift에서 Cloud Firestore의 전체 컬렉션을 가져오려면 다음과 같은 코드를 사용할 수 있습니다.\n\n```swift\ndo {\n    let snapshot = try await db.collection(""users"").getDocuments()\n    for document in snapshot.documents {\n        print(""\\(document.documentID) => \\(document.data())"")\n    }\n} catch {\n    print(""Error getting documents: \\(error)"")\n}\n```'
 'Q: Swift에서 Cloud Firestore의 \'cities\' 컬렉션에서 모든 문서를 가져오는 방법은 무엇인가요?\nA: Swift에서 Cloud Firestore의 \'cities\' 컬렉션에서 모든 문서를 가져오는 방법은 다음과 같습니다:\n\n```swift\ndo {\n    let querySnapshot = try await db.collection(""cities"").getDocuments()\n    for document in querySnapshot.documents {\n        print(""\\(document.documentID) => \\(document.data())"")\n    }\n} catch {\n    print(""Error getting documents: \\(error)"")\n}\n```'
 'Q: Swift에서 Cloud Firestore의 \'users\' 컬렉션의 문서를 가져오는 방법은 무엇인가요?\nA: Swift에서 \'users\' 컬렉션의 문서를 가져오려면 다음과 같이 작성합니다:\n\n```swift\ndo {\n  let snapshot = try await db.collection(""users"").getDocuments()\n  for document in snapshot.documents {\n    print(""\\(document.documentID) => \\(document.data())"")\n  }\n} catch {\n  print(""Error getting documents: \\(error)"")\n}\n```'
 'Q: Swift에서 Firestore에서 여러 문서를 가져오는 방법은 무엇인가요?\nA: do {\n    let querySnapshot = try await db.collection(""cities"").whereField(""capital"", isEqualTo: true)\n        .getDocuments()\n    for document in querySnapshot.documents {\n        print(""\\(document.documentID) => \\(document.data())"")\n    }\n} catch {\n    print(""Error getting documents: \\(error)"")\n}'
 'Q: C++에서 Cloud Firestore를 초기화하는 기본 코드 예시는 무엇인가요?\nA: // Make sure the call to `Create()` happens some time before you call Firestore::GetInstance().\nApp::Create();\nFirestore* db = Firestore::GetInstance();']","Python에서 Cloud Firestore를 초기화하는 방법은 다음과 같습니다. 기본적인 초기화 방법은 아래 코드를 참고하세요:

```python
import firebase_admin
from firebase_admin import firestore

# Application Default credentials are automatically created.
app = firebase_admin.initialize_app()
db = firestore.client()
```

비동기적으로 초기화하려면 다음 코드를 사용할 수 있습니다:

```python
import firebase_admin
from firebase_admin import firestore_async

# Application Default credentials are automatically created.
app = firebase_admin.initialize_app()
db = firestore_async.client()
```

기존 애플리케이션 기본 사용자 인증 정보를 사용하여 초기화하려면 다음과 같이 할 수 있습니다:

```python
import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore

# Use the application default credentials.
cred = credentials.ApplicationDefault()

firebase_admin.initialize_app(cred)
db = firestore.client()
```

이 코드를 사용하여 Python 환경에서 Cloud Firestore를 초기화할 수 있습니다.","Cloud Firestore를 Python에서 서비스 계정을 사용하여 초기화하려면 다음 코드를 사용합니다:

import firebase_admin
from firebase_admin import credentials
from firebase_admin import firestore

# Use a service account.
cred = credentials.Certificate('path/to/serviceAccount.json')

app = firebase_admin.initialize_app(cred)
db = firestore.client()"
"BigQuery에서 쿼리 실행 단계의 병렬 입력 세그먼트 수를 확인하고자 할 때, 사용자가 참고해야 하는 필드는 무엇이며, 이 필드를 통해 어떤 정보를 얻을 수 있는지 상세히 설명해 주시겠습니까?","['입력: 표에서 데이터를 읽거나 특정 열을 선택\n조인: JOIN 조건을 기반으로 두 테이블의 데이터를 병합\n집계: SUM과 같은 계산 실행\n정렬: 결과 정렬\n스테이지는 스테이지 내에서 각 작업자가 실행하는 개별 작업을 설명하는 단계 [https://cloud.google.com/bigquery/docs/query-plan-explanation?hl=ko#per-stage_step_information]로 구성됩니다. 스테이지를 클릭하여 열고 단계를 볼 수 있습니다. 스테이지에는 상대 및 절대 타이밍 정보 [https://cloud.google.com/bigquery/docs/query-plan-explanation?hl=ko#per-stage_timing_classification]도 포함됩니다. 스테이지 이름은 수행하는 단계를 요약합니다. 예를 들어 이름에 join이 있는 스테이지는 스테이지의 기본 단계가 JOIN 작업임을 의미합니다. 끝에 +가 있는 스테이지 이름은 추가적인 중요한 단계를 실행한다는 의미입니다. 예를 들어 이름에 JOIN+가 있는 스테이지는 스테이지가 조인 작업과 기타 중요한 단계를 실행한다는 의미입니다.\n스테이지를 연결하는 선은 스테이지 간의 중간 데이터 교환을 나타냅니다. BigQuery는 스테이지가 실행되는 동안 셔플 메모리에 중간 데이터를 저장합니다. 가장자리의 숫자는 스테이지 간에 교환된 예상 행 수를 나타냅니다. 셔플 메모리 할당량은 계정에 할당된 슬롯 수와 상관관계가 있습니다. 셔플 할당량을 초과하면 셔플 메모리가 디스크로 유출되어 쿼리 성능이 크게 느려질 수 있습니다.\n쿼리 성능 통계 보기\n--- 탭: 콘솔 [https://cloud.google.com/bigquery/docs/query-insights?hl=ko#%EC%BD%98%EC%86%94] ---\n쿼리 성능 통계를 보려면 다음 단계를 수행합니다.'
 'maxResults — 반환할 결과의 최대 수입니다.\nselectedFields — 반환할 필드를 쉼표로 구분한 목록입니다. 지정하지 않으면 모든 열이 반환됩니다.\nstartIndex — 읽기를 시작할 행의 0부터 시작하는 색인입니다.\n\n참고: 마지막 행을 벗어나서 startIndex를 요청하면 메서드가 성공적으로 반환되지만 rows 속성은 반환되지 않습니다. tables.get [https://cloud.google.com/bigquery/docs/reference/rest/v2/tables/get?hl=ko] 메서드를 호출하고 numRows 속성을 검사하여 테이블의 행 수를 확인할 수 있습니다.\n반환되는 값은 JSON 객체에 래핑되므로 tabledata.list [https://cloud.google.com/bigquery/docs/reference/rest/v2/tabledata/list?hl=ko] 참조 문서의 설명에 따라 객체를 파싱해야 합니다.\n\n--- 탭: C# [https://cloud.google.com/bigquery/docs/managing-table-data?hl=ko#c] ---\n이 샘플을 사용해 보기 전에 BigQuery 빠른 시작: 클라이언트 라이브러리 사용 [https://cloud.google.com/bigquery/docs/quickstarts/quickstart-client-libraries?hl=ko]의 C# 설정 안내를 따르세요.\n        \n      \n      \n  자세한 내용은 BigQuery C# API 참고 문서 [https://cloud.google.com/dotnet/docs/reference/Google.Cloud.BigQuery.V2/latest?hl=ko]를 확인하세요.\n  \n    \n    \n      BigQuery에 인증하려면 애플리케이션 기본 사용자 인증 정보를 설정합니다.\n      자세한 내용은 클라이언트 라이브러리의 인증 설정 [https://cloud.google.com/bigquery/docs/authentication?hl=ko#client-libs]을 참조하세요.'
 '최적화\n타겟팅 필터링: WHERE 절을 전략적으로 사용하여 쿼리에서 최대한 빨리 관련 없는 데이터를 필터링합니다. 이렇게 하면 쿼리에서 처리해야 하는 데이터 양이 줄어듭니다.\n파티션 나누기 및 클러스터링: BigQuery는 테이블 파티션 나누기 및 클러스터링을 사용하여 특정 데이터 세그먼트를 효율적으로 찾습니다. READ 단계에서 스캔되는 데이터를 최소화하려면 일반적인 쿼리 패턴에 따라 테이블을 파티션하고 클러스터링해야 합니다.\n관련 열 선택: SELECT * 문을 사용하지 마세요. 대신 특정 열을 선택하거나 SELECT * EXCEPT를 사용하여 불필요한 데이터를 읽지 마세요.\n구체화된 뷰: 구체화된 뷰는 자주 사용되는 집계를 미리 계산하고 저장할 수 있으므로 이러한 뷰를 사용하는 쿼리의 READ 단계에서 기본 테이블을 읽을 필요가 줄어들 수 있습니다.\nCOMPUTE 단계\nCOMPUTE 단계에서 BigQuery는 데이터에 대해 다음 작업을 실행합니다.\n계산, 비교, 논리 연산을 비롯하여 쿼리의 SELECT, WHERE, HAVING 및 기타 절의 표현식을 평가합니다.\n내장 SQL 함수와 사용자 정의 함수를 실행합니다.\n쿼리의 조건에 따라 데이터 행을 필터링합니다.\n최적화\n쿼리 계획을 통해 COMPUTE 단계 내의 병목 현상을 파악할 수 있습니다. 계산이 많거나 처리되는 행 수가 많은 단계를 찾습니다.\nCOMPUTE 단계와 데이터 양의 연관성 비교: 한 단계에서 상당한 계산이 이루어지고 대량의 데이터가 처리되는 경우 최적화의 좋은 후보가 될 수 있습니다.\n왜곡된 데이터: 연산 최대값이 연산 평균보다 훨씬 높은 단계의 경우, 해당 단계에서 데이터 슬라이스를 몇 개 처리하는 데 불균형하게 많은 시간을 소비했음을 나타냅니다. 데이터 분포를 확인하여 데이터 편향이 있는지 살펴보는 것이 좋습니다.\n데이터 유형 고려: 열에 적절한 데이터 유형을 사용합니다. 예를 들어 문자열 대신 정수, 날짜-시간, 타임스탬프를 사용하면 성능을 개선할 수 있습니다.\nWRITE 단계\nWRITE 단계는 중간 데이터와 최종 출력에 대해 실행됩니다.\n셔플 메모리에 쓰기: 다단계 쿼리에서 WRITE 단계는 종종 추가 처리를 위해 처리된 데이터를 다른 단계로 전송하는 것을 포함합니다. 이는 여러 소스의 데이터를 결합하거나 집계하는 셔플 메모리의 일반적인 사례입니다. 이 단계에서 작성된 데이터는 일반적으로 최종 출력이 아닌 중간 결과입니다.'
 ""배경\nBigQuery는 쿼리 작업 실행 시 선언적 SQL 문을 실행 그래프로 변환하고 일련의 쿼리 스테이지로 세분화합니다. 각 쿼리 스테이지에는 더 세분화된 실행 단계 조합이 있습니다. BigQuery는 크게 분산된 병렬 아키텍처를 사용하여 이러한 쿼리를 실행하며, 스테이지는 많은 잠재적 작업자들이 동시에 실행할 수 있는 작업 단위를 모델링합니다. 스테이지는 빠른 분산 셔플 아키텍처를 사용하여 서로 통신합니다.\n쿼리 계획 내에서 작업 단위 및 작업자라는 용어는 특히 동시 로드에 대한 정보를 전달하기 위해 사용됩니다. BigQuery 내의 다른 곳에서는 컴퓨팅, 메모리, I/O 리소스를 비롯한 쿼리 실행의 여러 측면을 추상화한 '슬롯'이라는 용어가 사용될 수 있습니다. 최상위 작업 통계는 이 추상화된 계정을 통해 쿼리의 totalSlotMs 추정을 사용함으로써 개별 쿼리 비용의 추정치를 제공합니다.\n쿼리 실행 아키텍처의 또 다른 중요한 속성은 동적이라는 것입니다. 즉, 쿼리가 실행되는 동안 쿼리 계획이 수정될 수 있습니다. 쿼리가 실행 중인 동안에 스테이지를 도입하는 목적은 쿼리 작업자 전체의 데이터 배포를 향상시키기 위한 경우가 많습니다. 실제로 이러한 쿼리 계획에서 스테이지에는 일반적으로 리파티션 스테이지라는 라벨이 지정됩니다.\n쿼리 계획 외에도 쿼리 작업에는 쿼리 작업자 사이에서 완료, 보류, 활성 상태의 작업 단위에 대한 설명을 제공하는 실행 타임라인이 노출됩니다. 쿼리에는 활성 작업자를 포함한 여러 스테이지가 동시에 있을 수 있으므로, 타임라인은 쿼리의 전반적인 진행 상황을 보여주기 위한 것입니다.\nGoogle Cloud 콘솔에서 정보 보기\nGoogle Cloud 콘솔 [https://console.cloud.google.com/bigquery?hl=ko]에서 실행 세부정보 버튼(결과 버튼 근처)을 클릭하여 완료된 쿼리의 쿼리 계획 세부정보를 볼 수 있습니다.\n쿼리 계획 정보\nAPI 응답 내에서 쿼리 계획은 쿼리 스테이지 목록으로 표시됩니다. 목록의 각 항목은 스테이지별 개요 통계, 세부 단계 정보, 스테이지 타이밍 분류를 보여줍니다. Google Cloud 콘솔 내부에서 모든 세부정보가 렌더링되지는 않지만 API 응답 내에 모든 정보가 있을 수 있습니다.\n스테이지 개요\n각 스테이지의 개요 필드에 포함될 수 있는 항목은 다음과 같습니다.\nAPI 필드 설명\nid 스테이지의 고유 숫자 ID입니다.""
 'bookmark_border\n쿼리의 실행 그래프는 BigQuery에서 쿼리를 실행하는 데 필요한 단계를 시각적으로 나타낸 것입니다. 이 문서에서는 쿼리 실행 그래프를 사용하여 쿼리 성능 문제를 진단하고 쿼리 성능 통계를 확인하는 방법을 설명합니다.\nBigQuery는 강력한 쿼리 성능을 제공하지만 쿼리 속도에 영향을 줄 수 있는 많은 내부 및 외부 요소가 포함된 복잡한 분산 시스템이기도 합니다. SQL의 선언적 특성으로 인해 복잡한 쿼리 실행이 숨겨질 수도 있습니다. 즉, 쿼리가 예상보다 느리게 실행되거나 이전에 실행된 것보다 느려질 경우 원인을 파악하는 것이 어려울 수 있습니다.\n쿼리 실행 그래프는 쿼리 계획과 쿼리 성능 세부정보를 검사하기 위한 동적 그래픽 인터페이스를 제공합니다. 실행 중이거나 완료된 쿼리의 쿼리 실행 그래프를 검토할 수 있습니다.\n또한 쿼리 실행 그래프를 사용하여 쿼리에 대한 성능 통계를 얻을 수도 있습니다. 성능 통계는 쿼리 성능을 개선하는 데 도움이 되는 최선의 추천을 제공합니다. 쿼리 성능이 다면적이기 때문에 성능 통계는 전체 쿼리 성능 중 일부 그림만 제공할 수 있습니다.\n필수 권한\n쿼리 실행 그래프를 사용하려면 다음 권한이 있어야 합니다.\nbigquery.jobs.get\nbigquery.jobs.listAll\n이러한 권한은 다음 BigQuery 사전 정의된 Identity and Access Management(IAM) 역할을 통해 제공됩니다.\nroles/bigquery.admin\nroles/bigquery.resourceAdmin\nroles/bigquery.resourceEditor\nroles/bigquery.resourceViewer\n실행 그래프 구조\n쿼리 실행 그래프는 콘솔에서 쿼리 계획을 그래픽으로 보여줍니다. 각 상자는 다음과 같은 쿼리 계획의 스테이지 [https://cloud.google.com/bigquery/docs/query-plan-explanation?hl=ko#stage_overview]를 나타냅니다.\n입력: 표에서 데이터를 읽거나 특정 열을 선택\n조인: JOIN 조건을 기반으로 두 테이블의 데이터를 병합\n집계: SUM과 같은 계산 실행\n정렬: 결과 정렬'
 '쓰기 최적화된 스토리지의 데이터 쿼리 [https://cloud.google.com/bigquery/docs/querying-partitioned-tables?hl=ko#query_data_in_the_streaming_buffer]\n파티션 프루닝 권장사항 [https://cloud.google.com/bigquery/docs/querying-partitioned-tables?hl=ko#best_practices_for_partition_pruning]\n파티션을 나눈 테이블 쿼리\nbookmark_border\n이 문서에서는 BigQuery에서 파티션을 나눈 테이블 [https://cloud.google.com/bigquery/docs/partitioned-tables?hl=ko]을 쿼리하기 위한 몇 가지 특정 고려사항에 대해 설명합니다.\nBigQuery에서 쿼리 실행에 대한 일반적인 내용은 대화형 쿼리 및 일괄 쿼리 실행 [https://cloud.google.com/bigquery/docs/running-queries?hl=ko]을 참조하세요.\n개요\n쿼리에서 파티션 나누기 열의 값에 대해 한정 필터가 사용되는 경우 BigQuery가 필터와 일치하는 파티션을 스캔하고 남은 파티션을 건너뛸 수 있습니다. 이 프로세스를 파티션 프루닝이라고 합니다.\n파티션 프루닝은 입력 검색에서 불필요한 파티션을 제거하기 위해 BigQuery에서 사용하는 메커니즘입니다. 쿼리에서 검색되는 바이트 수를 계산할 때 프루닝된 파티션은 포함되지 않습니다. 일반적으로 파티션 프루닝은 쿼리 비용을 줄이는 데 도움이 됩니다.\n프루닝 동작은 여러 파티셔닝 유형에 따라 달라지므로, 서로 다르게 파티셔닝되었지만 그렇지 않으면 동일한 테이블을 쿼리할 때 처리된 바이트에서 차이를 볼 수 있습니다. 쿼리가 처리할 수 있는 바이트 수를 추정하려면 테스트 실행 [https://cloud.google.com/bigquery/docs/running-queries?hl=ko#dry-run]을 수행합니다.\n시간 단위 열로 파티션을 나눈 테이블 쿼리\n시간 단위 열로 파티션을 나눈 테이블 [https://cloud.google.com/bigquery/docs/partitioned-tables?hl=ko#date_timestamp_partitioned_tables]을 쿼리할 때 파티션을 프루닝하려면 파티션 나누기 열에 필터를 포함합니다.'
 '슬롯을 사용한 쿼리 실행\nBigQuery는 쿼리 작업 실행 시 선언적 SQL 문을 실행 그래프로 변환하고 일련의 쿼리 스테이지로 세분화합니다. 각 쿼리 스테이지에는 더 세분화된 실행 단계 조합이 있습니다. BigQuery는 크게 분산된 병렬 아키텍처를 사용하여 이러한 쿼리를 실행하며, 스테이지는 많은 잠재적 작업자들이 동시에 실행할 수 있는 작업 단위를 모델링합니다. 스테이지는 빠른 분산 셔플 아키텍처 [https://cloud.google.com/blog/products/gcp/separation-of-compute-and-state-in-google-bigquery-and-cloud-dataflow-and-why-it-matters?hl=ko]를 통해 서로 통신합니다. 이 아키텍처에 대한 자세한 내용은 Google Cloud 블로그 [https://cloud.google.com/blog/products/bigquery/in-memory-query-execution-in-google-bigquery?hl=ko]를 참조하세요.\nBigQuery 쿼리 실행은 동적입니다. 즉, 쿼리가 실행되는 동안 쿼리 계획이 수정될 수 있습니다. 쿼리가 실행 중인 동안에 스테이지를 도입하는 목적은 쿼리 작업자 전체의 데이터 배포를 향상시키기 위한 경우가 많습니다.\nBigQuery는 동시에 [https://en.wikipedia.org/wiki/Instruction_pipelining] 여러 스테이지를 실행할 수 있습니다. BigQuery는 쿼리 실행 속도를 높이기 위해 예측 실행 [https://en.wikipedia.org/wiki/Speculative_execution]을 활용하고, 동시 처리를 최적화하기 위해 스테이지의 파티션을 동적으로 나눌 [https://cloud.google.com/blog/products/gcp/no-shard-left-behind-dynamic-work-rebalancing-in-google-cloud-dataflow?hl=ko] 수 있습니다.\nBigQuery 슬롯은 쿼리의 각 스테이지별로 개별 작업 단위를 실행합니다. 예를 들어 BigQuery에서 스테이지의 최적 동시 처리 계수를 10으로 결정하면 해당 스테이지를 처리하기 위해 10개의 슬롯을 요청합니다.\nGoogleSQL 쿼리는 동적 DAG\n슬롯 리소스 절약 모드로 쿼리 실행'
 '""billingTier"": 1,\n    ""totalSlotMs"": ""50"",\n    ""cacheHit"": false,\n    ""referencedTables"": [\n      {\n        ""projectId"": ""publicdata"",\n        ""datasetId"": ""samples"",\n        ""tableId"": ""shakespeare""\n      }\n    ],\n    ""statementType"": ""SELECT""\n  },\n  ""totalSlotMs"": ""50""\n},\n실행 정보 사용\nBigQuery 쿼리 계획은 서비스의 쿼리 실행 방법에 대한 정보를 제공하지만, 서비스의 관리 특성에 따라 일부 세부정보의 직접적인 조치 가능 여부가 제한됩니다. 서비스를 사용하면 많은 최적화가 자동으로 수행되며, 이러한 최적화는 미세 조정, 프로비저닝 및 모니터링을 위해 전문 지식을 갖춘 전담 직원이 필요할 수 있는 다른 환경과 다를 수 있습니다.\n쿼리 실행과 성능을 향상시킬 수 있는 특정 기술에 대해서는 권장사항 문서 [https://cloud.google.com/bigquery/docs/best-practices-performance-overview?hl=ko]를 참조하세요. 쿼리 계획과 타임라인 통계는 어떤 스테이지에 리소스 사용이 집중되는지 이해하는 데 유용할 수 있습니다. 예를 들어 입력 행보다 훨씬 많은 출력 행을 생성하는 JOIN 스테이지는 쿼리에서 일찍 필터링하는 것이 좋습니다.\n또한 타임라인 정보는 지정된 쿼리가 독립적인 상태에서 느린 것인지 또는 같은 리소스를 놓고 경합하는 다른 쿼리의 영향으로 인해 느린 것인지 식별하는 데 유용할 수 있습니다. 쿼리 전체 기간 중에 활성 단위 수가 제한된 상태로 유지되지만 큐에 추가된 작업 단위 양이 높게 유지되는 것으로 관측될 경우 동시 쿼리 수를 줄이면 특정 쿼리의 전체 실행 시간을 크게 향상시킬 수 있습니다.\n참고: 일부 쿼리 처리는 모든 단계의 컨텍스트 외부에서 수행됩니다. 경우에 따라 첫 번째 단계가 전달되기 전이나 마지막 단계가 완료된 후에 상당한 지연 시간 또는 슬롯 사용량이 누적될 수 있습니다. 예를 들면 일부 형태의 파티션 프루닝, 다양한 메타데이터 작업, 과도한 슬롯 사용에 대한 보상 [https://cloud.google.com/bigquery/docs/slots?hl=ko#excess_slot_usage] 등이 있습니다.'
 '이 서비스 계정에 프로젝트에 대한 액세스 권한 부여 섹션에서 BigQuery 사용자 [https://cloud.google.com/bigquery/docs/access-control?hl=ko#bigquery] 역할을 선택합니다.\n완료를 클릭합니다.\n\n\n\nBigQuery는 snapshot-bot@PROJECT.iam.gserviceaccount.com 이메일 주소로 서비스 계정을 만듭니다.\nBigQuery에서 지정한 권한으로 서비스 계정이 생성되었는지 확인하기 위해 다음 단계를 수행합니다.\n--- 탭: 콘솔 [https://cloud.google.com/bigquery/docs/table-snapshots-scheduled?hl=ko#%EC%BD%98%EC%86%94] ---\nBigQuery에서 서비스 계정이 생성되었는지 확인합니다.\n\n\n Google Cloud 콘솔에서 서비스 계정 페이지로 이동합니다.\n\n서비스 계정으로 이동 [https://console.cloud.google.com/iam-admin/serviceaccounts?hl=ko] \nPROJECT 프로젝트를 선택합니다.\nsnapshot-bot@PROJECT.iam.gserviceaccount.com를 클릭합니다.\n서비스 계정 상태 메시지에서 서비스 계정이 활성 상태로 표시되는지 확인합니다.\n\n\nBigQuery에서 서비스 계정에 쿼리 실행에 필요한 권한이 부여되었는지 확인합니다.\n\n\n Google Cloud 콘솔에서 리소스 관리 페이지로 이동합니다.'
 '클러스터링된 테이블에서는 해당 테이블을 수정하는 각 작업과 관련하여 정렬 속성이 유지됩니다. 클러스터링된 열을 기준으로 필터링 또는 집계하는 쿼리는 전체 테이블 또는 테이블 파티션 대신 클러스터링된 열을 기준으로 관련 블록만 스캔합니다. 그 결과 BigQuery가 쿼리에 의해 처리되는 바이트나 쿼리 비용을 정확히 예측하지 못할 수도 있지만, 실행 시 총 바이트 수를 줄이려고 시도합니다.\n다음 예와 같이 여러 열을 사용하여 테이블을 클러스터링할 경우 열 순서는 BigQuery가 데이터를 정렬하여 스토리지 블록으로 그룹화할 때 우선 적용되는 열을 결정합니다. 테이블 1은 클러스터링되지 않은 테이블의 논리적 스토리지 블록 레이아웃을 보여줍니다. 반면 테이블 2는 Country 열로만 클러스터링되고 테이블 3은 Country 및 Status의 여러 열로 클러스터링됩니다.\n클러스터링된 테이블을 쿼리하는 경우 쿼리 실행 전에 스캔할 스토리지 블록 수를 알 수 없으므로 쿼리 실행 전에 정확한 쿼리 비용 예상치가 제공되지 않습니다. 최종 비용은 쿼리 실행이 완료된 후 결정되며 스캔된 특정 스토리지 블록을 기반으로 합니다.\n클러스터링을 사용해야 하는 경우\n클러스터링은 테이블이 저장되는 방식을 결정하므로 일반적으로 쿼리 성능 향상을 위해 가장 먼저 고려할 만한 옵션입니다. 따라서 다음과 같은 이점을 제공하는 경우 클러스터링을 사용하는 것이 좋습니다.\n파티션을 나누지 않은 테이블이 64MB보다 클 경우 클러스터링하면 이점이 있을 수 있습니다. 마찬가지로 64MB보다 큰 테이블 파티션도 클러스터링 시 이점을 누릴 수 있습니다. 더 작은 테이블 또는 파티션도 클러스터링할 수 있지만 일반적으로 성능 개선이 미미합니다.\n쿼리에서 특정 열을 기준으로 필터링하는 경우가 많다면 쿼리에서 필터와 일치하는 블록만 스캔하므로 클러스터링이 쿼리 속도를 높입니다.\n쿼리의 필터링 기준 열에 고유 값이 많다면(카디널리티가 높음) 클러스터링은 입력 데이터를 가져올 위치에 대한 상세 메타데이터를 BigQuery에 제공하여 쿼리 속도를 높입니다.\n클러스터링을 사용하면 테이블의 기본 스토리지 블록의 크기를 테이블 크기에 따라 적응적으로 조절할 수 있습니다.'
 '| Methods |\n| --- |\n| get | Gets the metadata and configuration for a Field. |\n| list | Lists the field configuration and metadata for this database. |\n| patch | Updates a field configuration. |\n\nSend feedback'
 '| Fields |\n| --- |\n| explainOptions | object (ExplainOptions) Optional. Explain options for the query. If set, additional query statistics will be returned. If not, only query results will be returned. |\n| Union field query_type. The query to run. query_type can be only one of the following: |\n| structuredQuery | object (StructuredQuery) A structured query. |\n| Union field consistency_selector. The consistency mode for this transaction. If not set, defaults to strong consistency. consistency_selector can be only one of the following: |\n| transaction | string (bytes format) Run the query within an already active transaction. The value here is the opaque transaction ID to execute the query in. A base64-encoded string. |\n| newTransaction | object (TransactionOptions) Starts a new transaction and reads the documents. Defaults to a read-only transaction. The new transaction ID will be returned as the first response in the stream. |'
 '다음 표에서는 `recommendations` 응답의 중요한 필드를 설명합니다.\n\n\n    \n    \n        속성\n        하위유형 관련성\n        설명\n    \n    \n    \n    \n        recommenderSubtype\n        CREATE_MATERIALIZED_VIEW\n        권장사항 유형\n    \n    \n        content.overview.sql\n        CREATE_MATERIALIZED_VIEW\n        구체화된 뷰를 만드는 추천 DDL 문\n    \n    \n        content.overview.slotMsSavedMonthly\n        CREATE_MATERIALIZED_VIEW\n        추천 뷰로 매월 절약되는 예상 슬롯(밀리초)\n    \n    \n        content.overview.bytesSavedMonthly\n        CREATE_MATERIALIZED_VIEW\n        추천 뷰로 매월 절약되는 예상 스캔 바이트\n    \n    \n      content.overview.baseTables\n      CREATE_MATERIALIZED_VIEW\n      나중에 사용하기 위해 예약되어 있습니다.\n  \n    \n\n\n\n     recommendations 응답의 다른 필드에 대한 자세한 내용은 REST 리소스: projects.locations.recommenders.recommendation [https://cloud.google.com/recommender/docs/reference/rest/v1/projects.locations.recommenders.recommendations?hl=ko#resource:-recommendation]을 참조하세요.\n    \n     Recommender API 사용 방법에 대한 자세한 내용은 API 사용 - 권장사항 [https://cloud.google.com/recommender/docs/using-api?hl=ko]을 참조하세요.\n    \n\n\ngcloud CLI를 사용하여 구체화된 뷰 추천을 표시한 통계를 보려면 gcloud recommender insights list 명령어 [https://cloud.google.com/sdk/gcloud/reference/recommender/insights/list?hl=ko]를 사용합니다.'
 '커스텀 역할 [https://cloud.google.com/iam/docs/creating-custom-roles?hl=ko]이나 다른 사전 정의된 역할 [https://cloud.google.com/iam/docs/roles-overview?hl=ko#predefined]을 통해 필요한 권한을 얻을 수도 있습니다.\n전송 업데이트\n전송 구성을 만든 후 다음 필드를 수정할 수 있습니다.\n대상 데이터세트\n표시 이름\n특정 전송 유형으로 지정된 매개변수\n실행 알림 설정\n서비스 계정\n전송이 생성되면 전송 소스를 수정할 수 없습니다.\n전송을 업데이트하려면 다음 안내를 따르세요.\n--- 탭: 콘솔 [https://cloud.google.com/bigquery/docs/working-with-transfers?hl=ko#%EC%BD%98%EC%86%94] ---\nGoogle Cloud 콘솔에서 데이터 전송 페이지로 이동합니다.'
 '커스텀 역할 [https://cloud.google.com/iam/docs/creating-custom-roles?hl=ko]이나 다른 사전 정의된 역할 [https://cloud.google.com/iam/docs/roles-overview?hl=ko#predefined]을 통해 필요한 권한을 얻을 수도 있습니다.\n테넌트에 대한 다음 Azure IAM 권한이 있는지 확인합니다.\nApplication.ReadWrite.All\nAppRoleAssignment.ReadWrite.All\n할당량\n할당량에 대한 자세한 내용은 BigQuery Connection API [https://cloud.google.com/bigquery/quotas?hl=ko#connection_api]를 참조하세요.\nAzure 연결 만들기\nAzure 연결을 만들려면 다음 단계를 수행하세요.\nAzure 테넌트에서 애플리케이션을 만듭니다 [https://cloud.google.com/bigquery/docs/omni-azure-create-connection?hl=ko#create-azure-tenant].\nBigQuery Azure 연결 만들기 [https://cloud.google.com/bigquery/docs/omni-azure-create-connection?hl=ko#create-azure-connection].\n제휴 사용자 인증 정보를 추가 [https://cloud.google.com/bigquery/docs/omni-azure-create-connection?hl=ko#add-a-federated-credential]합니다.\nBigQuery Azure AD 애플리케이션에 역할을 할당 [https://cloud.google.com/bigquery/docs/omni-azure-create-connection?hl=ko#assigning-a-role]합니다.\n제휴 ID 사용자 인증 정보를 사용하여 Azure의 데이터에 액세스하는 방법에 대한 자세한 내용은 워크로드 아이덴티티 제휴 [https://docs.microsoft.com/en-us/azure/active-directory/develop/workload-identity-federation]를 참조하세요.\nAzure 테넌트에서 애플리케이션 만들기\nAzure 테넌트에서 애플리케이션을 만들려면 다음 단계를 따르세요.'
 '테이블 스냅샷 복원 [https://cloud.google.com/bigquery/docs/table-snapshots-restore?hl=ko]\n시간 이동 기간은 2~7일입니다. 시간 이동 기간이 지나면 BigQuery에서 삭제된 데이터가 추가로 7일간 자동으로 보관되는 장애 안전 기간 [https://cloud.google.com/bigquery/docs/time-travel?hl=ko#fail-safe]을 제공합니다. 장애 안전 기간이 지나면 지원 티켓 열기를 비롯한 그 어떤 방법으로도 테이블을 복원할 수 없습니다.\n시작하기 전에\n삭제된 테이블을 복원하는 데 필요한 Identity and Access Management(IAM) 권한이 있는지 확인합니다.\n필요한 역할\n삭제된 테이블을 복원하는 데 필요한 권한을 얻으려면 관리자에게 프로젝트에 대한 BigQuery 사용자 [https://cloud.google.com/iam/docs/roles-permissions/bigquery?hl=ko#bigquery.user](roles/bigquery.user) IAM 역할을 부여해 달라고 요청하세요. 역할 부여에 대한 자세한 내용은 프로젝트, 폴더, 조직에 대한 액세스 관리 [https://cloud.google.com/iam/docs/granting-changing-revoking-access?hl=ko]를 참조하세요.\n커스텀 역할 [https://cloud.google.com/iam/docs/creating-custom-roles?hl=ko]이나 다른 사전 정의된 역할 [https://cloud.google.com/iam/docs/roles-overview?hl=ko#predefined]을 통해 필요한 권한을 얻을 수도 있습니다.\n테이블 복원하기\n이전 데이터에서 테이블을 복원하면 소스 테이블의 태그 [https://cloud.google.com/bigquery/docs/tags?hl=ko]가 대상 테이블에 복사되지 않습니다.\n@<time> 시간 데코레이터를 사용하여 테이블을 새 테이블에 복사하여 삭제되었지만 아직 시간 이동 기간 내의 테이블을 복원할 수 있습니다. 시간 데코레이터를 사용하더라도 삭제된 테이블을 쿼리할 수는 없습니다. 먼저 복원해야 합니다.\n테이블을 복원하려면 다음 옵션 중 하나를 선택합니다.'
 'Dataplex에서 데이터 캔버스 메타데이터를 관리하려면 Google Cloud 프로젝트에서 Dataplex API [https://cloud.google.com/dataplex/docs/enable-api?hl=ko]가 사용 설정되어 있는지 확인합니다.\n필요한 역할\nBigQuery 데이터 캔버스를 사용하는 데 필요한 권한을 얻으려면 관리자에게 프로젝트에 대한 다음 IAM 역할을 부여해 달라고 요청하세요.\nBigQuery Studio 사용자 [https://cloud.google.com/iam/docs/understanding-roles?hl=ko#bigquery.studioUser](roles/bigquery.studioUser)\nGoogle Cloud를 위한 Gemini 사용자 [https://cloud.google.com/iam/docs/understanding-roles?hl=ko#cloudaicompanion.user](roles/cloudaicompanion.user)\n역할 부여에 대한 자세한 내용은 프로젝트, 폴더, 조직에 대한 액세스 관리 [https://cloud.google.com/iam/docs/granting-changing-revoking-access?hl=ko]를 참조하세요.\n커스텀 역할 [https://cloud.google.com/iam/docs/creating-custom-roles?hl=ko]이나 다른 사전 정의된 역할 [https://cloud.google.com/iam/docs/understanding-roles?hl=ko]을 통해 필요한 권한을 얻을 수도 있습니다.\nBigQuery에서 IAM 역할 및 권한에 대한 자세한 내용은 IAM 소개 [https://cloud.google.com/bigquery/docs/access-control?hl=ko]를 참조하세요.\nDataplex에서 데이터 캔버스 메타데이터를 관리하려면 필요한 Dataplex 역할 [https://cloud.google.com/dataplex/docs/iam-roles?hl=ko]과 dataform.repository.get [https://cloud.google.com/dataform/docs/access-control?hl=ko] 권한이 있는지 확인합니다.\nBigQuery 데이터 캔버스 사용\nGoogle Cloud 콘솔, 쿼리 또는 테이블에서 BigQuery 데이터 캔버스를 사용할 수 있습니다.'
 '다음은 리소스 수준의 몇 가지 예시입니다.\n예시 효과\ntitle 요청된 리소스의 title 필드를 반환합니다.\nauthor/uri 요청된 리소스에서 author 객체의 uri 하위 필드를 반환합니다.\nlinks/*/href\nlinks의 하위 요소인 모든 객체의 href 필드를 반환합니다.\n하위 선택을 사용하여 특정 필드의 일부만 요청\n기본적으로 요청에서 특정 필드를 지정하면 서버에서는 해당하는 객체 또는 배열 요소 전체를 반환합니다. 하지만 특정 하위 필드만 포함하는 응답을 지정할 수도 있습니다. 아래 예시와 같이 \'( )\' 하위 선택 문법을 사용하면 됩니다.\n예 효과\nitems(title,author/uri) items 배열에 포함된 각 요소에 대해 title 및 author의 uri 값만 반환합니다.\n부분 응답 처리\n서버는 fields 쿼리 매개변수가 포함된 유효한 요청을 처리한 후 요청된 데이터와 함께 HTTP 200 OK 상태 코드를 반환합니다. fields 쿼리 매개변수에 오류가 있거나 매개변수가 유효하지 않은 경우 서버에서는 HTTP 400 Bad Request 상태 코드와 함께 필드 선택에 어떤 문제가 있는지 알려 주는 오류 메시지(예: ""Invalid field selection a/b"")를 반환합니다.\n다음은 위 소개 섹션 [https://cloud.google.com/bigquery/docs/api-performance?hl=ko#partial-response]에 나와 있는 부분 응답의 예입니다. 요청에서는 fields 파라미터를 사용하여 반환할 필드를 지정합니다.\nhttps://www.googleapis.com/demo/v1?fields=kind,items(title,characteristics/length)\n부분 응답은 다음과 같습니다.\n200 OK\n{\n  ""kind"": ""demo"",\n  ""items"": [{\n    ""title"": ""First title"",\n    ""characteristics"": {\n      ""length"": ""short""\n    }\n  }, {\n    ""title"": ""Second title"",\n    ""characteristics"": {\n      ""length"": ""long""\n    }\n  },\n  ...\n  ]\n}'
 '--- 탭: API [https://cloud.google.com/bigquery/docs/query-queues?hl=ko#api] ---\nBigQuery Reservation API [https://cloud.google.com/bigquery/docs/reference/reservations/rpc?hl=ko]에서 최대 동시 실행 목표를 업데이트하려면 예약 리소스 [https://cloud.google.com/bigquery/docs/reference/reservations/rpc/google.cloud.bigquery.reservation.v1?hl=ko#reservation]에서 concurrency 필드를 설정하고 UpdateReservationRequest 메서드 [https://cloud.google.com/bigquery/docs/reference/reservations/rpc/google.cloud.bigquery.reservation.v1?hl=ko#updatereservationrequest]를 호출합니다.\n모니터링\n실행 중인 쿼리와 큐에 추가된 쿼리를 확인하려면 INFORMATION_SCHEMA.JOBS_BY_* [https://cloud.google.com/bigquery/docs/information-schema-jobs?hl=ko] 및 INFORMATION_SCHEMA.JOBS_TIMELINE_BY_* [https://cloud.google.com/bigquery/docs/information-schema-jobs-timeline?hl=ko] 뷰를 살펴보세요. state 필드는 활발하게 실행 중인 쿼리의 경우 RUNNING, 큐에 추가된 쿼리의 경우 PENDING으로 설정됩니다.\n마지막 날 초 단위로 동적 동시 실행 기준에 도달했을 때 실행된 동시 쿼리 수를 보려면 다음 쿼리를 실행합니다.\nSELECT\n  t1.period_start,\n  t1.job_count AS dynamic_concurrency_threshold\nFROM (\n  SELECT\n    period_start,\n    state,\n    COUNT(DISTINCT job_id) AS job_count\n  FROM\n    `\nPROJECT_ID.\nREGION_ID`.INFORMATION_SCHEMA.JOBS_TIMELINE\n  WHERE'
 'BigQuery [https://cloud.google.com/bigquery?hl=ko]\nDocumentation [https://cloud.google.com/bigquery/docs?hl=ko]\n가이드 [https://cloud.google.com/bigquery/docs/introduction?hl=ko]\n도움이 되었나요?\n의견 보내기\n쿼리 계획 및 타임라인\nbookmark_border\n이 페이지의 내용\n배경 [https://cloud.google.com/bigquery/docs/query-plan-explanation?hl=ko#background]\nGoogle Cloud 콘솔에서 정보 보기 [https://cloud.google.com/bigquery/docs/query-plan-explanation?hl=ko#viewing_information_cloud_console]\n쿼리 계획 정보 [https://cloud.google.com/bigquery/docs/query-plan-explanation?hl=ko#query_plan_information]\n스테이지 개요 [https://cloud.google.com/bigquery/docs/query-plan-explanation?hl=ko#stage_overview]\n스테이지별 타이밍 분류 [https://cloud.google.com/bigquery/docs/query-plan-explanation?hl=ko#per-stage_timing_classification]\n쿼리 작업 내에 삽입된 BigQuery에는 진단 쿼리 계획과 타이밍 정보가 포함되어 있습니다. 이는 다른 데이터베이스 및 분석 시스템에서 EXPLAIN과 같은 문으로 제공되는 정보와 유사합니다. 이 정보는 jobs.get [https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get?hl=ko]과 같은 메서드의 API 응답에서 가져올 수 있습니다.\n장기간 실행 중인 쿼리의 경우 BigQuery는 통계를 주기적으로 업데이트합니다. 이러한 업데이트는 작업 상태가 폴링되는 비율과 상관없이 진행되지만 일반적으로 최소 주기는 30초입니다. 또한 실행 리소스를 사용하지 않는 쿼리 작업(예: 테스트 실행 요청 또는 캐시된 결과에서 제공할 수 있는 결과)에는 추가 진단 정보가 포함되지 않지만 다른 통계가 포함될 수 있습니다.\n배경'
 '쿼리 계획 및 타임라인\nBigQuery는 쿼리를 실행할 때마다 쿼리 계획 [https://cloud.google.com/bigquery/query-plan-explanation?hl=ko]을 생성합니다. 효과적인 쿼리 최적화를 위해서는 이 계획을 이해하는 것이 매우 중요합니다. 쿼리 계획에는 읽은 바이트 및 사용된 슬롯 시간과 같은 실행 통계가 포함됩니다. 쿼리 계획에는 쿼리 성능을 진단하고 개선하는 데 도움이 되는 여러 실행 단계에 대한 세부정보도 포함되어 있습니다. 쿼리 실행 그래프 [https://cloud.google.com/bigquery/docs/query-insights?hl=ko]는 쿼리 계획을 보고 쿼리 성능 문제를 진단하기 위한 그래픽 인터페이스를 제공합니다.\njobs.get API 메서드 [https://cloud.google.com/bigquery/docs/reference/rest/v2/jobs/get?hl=ko] 또는 INFORMATION_SCHEMA.JOBS 뷰 [https://cloud.google.com/bigquery/docs/information-schema-jobs?hl=ko]를 사용하여 쿼리 계획 및 타임라인 정보를 검색할 수도 있습니다. 이 정보는 BigQuery 작업의 실행 단계 흐름을 시각적으로 나타내는 오픈소스 도구인 BigQuery Visualiser [https://github.com/GoogleCloudPlatform/professional-services/tree/master/tools/bq-visualizer]에서 사용됩니다.\nBigQuery는 쿼리 작업을 실행할 때 선언적 SQL 문을 실행 그래프로 변환합니다. 그리고 이 그래프를 일련의 쿼리 스테이지로 세분화합니다. 각 쿼리 스테이지에는 더 세분화된 실행 단계 조합이 있습니다. BigQuery는 크게 분산된 병렬 아키텍처를 사용하여 이러한 쿼리를 실행합니다. BigQuery 스테이지는 많은 잠재적 작업자들이 동시에 실행할 수 있는 작업 단위를 모델링합니다. 스테이지는 빠른 분산 셔플 아키텍처 [https://cloud.google.com/blog/products/gcp/in-memory-query-execution-in-google-bigquery?hl=ko]를 통해 서로 통신합니다.'
 'Update dependency com.google.cloud:sdk-platform-java-config to v3.47.0 (#3779 [https://github.com/googleapis/java-bigquery/issues/3779]) (b27434b [https://github.com/googleapis/java-bigquery/commit/b27434b8a75e74184458e920142f5575fed9ba52])\nBigQuery resource utilization charts [https://cloud.google.com/bigquery/docs/admin-resource-charts#view-resource-utilization] have the following changes:\nThe default timeline shown in the event timeline chart has changed from one to six hours.\nSeveral improvements have been made to the views, including a new reservation slot usage view. This view helps monitor idle, baseline, and autoscaled slot usage.\nThis feature is in Preview [https://cloud.google.com/products/#product-launch-stages].\nYou can now view the Query text section [https://cloud.google.com/bigquery/docs/query-plan-explanation#understand_steps_with_query_text] in a BigQuery execution graph to understand how the stage steps are related to the query text. This feature is in preview [https://cloud.google.com/products#product-launch-stages].'
 'Return type\nGEOGRAPHY\nST_MAKEPOLYGONORIENTED\nST_MAKEPOLYGONORIENTED(array_of_geography)\nDescription\nLike ST_MAKEPOLYGON, but the vertex ordering of each input linestring determines the orientation of each polygon ring. The orientation of a polygon ring defines the interior of the polygon as follows: if someone walks along the boundary of the polygon in the order of the input vertices, the interior of the polygon is on the left. This applies for each polygon ring provided.\nThis variant of the polygon constructor is more flexible since ST_MAKEPOLYGONORIENTED can construct a polygon such that the interior is on either side of the polygon ring. However, proper orientation of polygon rings is critical in order to construct the desired polygon.\nIf the input ARRAY or any element in the ARRAY is NULL, ST_MAKEPOLYGONORIENTED returns NULL.\nNOTE: The input argument for ST_MAKEPOLYGONORIENTED may contain an empty GEOGRAPHY. ST_MAKEPOLYGONORIENTED interprets an empty GEOGRAPHY as having an empty linestring, which will create a full loop: that is, a polygon that covers the entire Earth.\nConstraints\nTogether, the input rings must form a valid polygon:'
 'January 06, 2022\nBigQuery standard SQL now supports the JSON [https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#json_type] data type for storing JSON data. The JSON data type is in Preview [https://cloud.google.com/products/#product-launch-stages]. For more information, see Working with JSON data in Standard SQL [https://cloud.google.com/bigquery/docs/reference/standard-sql/json-data].\nDecember 23, 2021\nDocumentation now includes a series of introductory topics to orient you to BigQuery including:\nWhat is BigQuery? [https://cloud.google.com/bigquery/docs/introduction] - Product overview, available tools, and learning resources\nStorage [https://cloud.google.com/bigquery/docs/storage_overview] - Infrastructure, ingestion, and optimization\nAnalytics [https://cloud.google.com/bigquery/docs/query-overview] - Strategies, SQL queries, and BI tools\nAdministration [https://cloud.google.com/bigquery/docs/admin-intro] - Resources, workload management, security, and monitoring'
 ')\nDescription\nConverts a STRING WKT [https://en.wikipedia.org/wiki/Well-known_text] geometry value into a GEOGRAPHY value.\nTo format GEOGRAPHY value as WKT, use ST_ASTEXT [https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_astext].\nDefinitions\nwkt_string: A STRING value that contains the WKT [https://en.wikipedia.org/wiki/Well-known_text] format.\noriented: A named argument with a BOOL literal.\nIf the value is TRUE, any polygons in the input are assumed to be oriented as follows: when traveling along the boundary of the polygon in the order of the input vertices, the interior of the polygon is on the left. This allows WKT to represent polygons larger than a hemisphere. See also ST_MAKEPOLYGONORIENTED [https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_makepolygonoriented], which is similar to ST_GEOGFROMTEXT with oriented=TRUE.\nIf the value is FALSE or omitted, this function returns the polygon with the smaller area.'
 'Definitions\nwkb_bytes_expression: A BYTES value that contains the WKB [https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary] format.\nwkb_hex_string_expression: A STRING value that contains the hexadecimal-encoded WKB [https://en.wikipedia.org/wiki/Well-known_text#Well-known_binary] format.\noriented: A named argument with a BOOL literal.\nIf the value is TRUE, any polygons in the input are assumed to be oriented as follows: when traveling along the boundary of the polygon in the order of the input vertices, the interior of the polygon is on the left. This allows WKB to represent polygons larger than a hemisphere. See also ST_MAKEPOLYGONORIENTED [https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_makepolygonoriented], which is similar to ST_GEOGFROMWKB with oriented=TRUE.\nIf the value is FALSE or omitted, this function returns the polygon with the smaller area.'
 'bigquery.datasets.getIamPolicy\nbigquery.models.getMetadata\nbigquery.models.list\nbigquery.routines.get\nbigquery.routines.list\nbigquery.tables.get\nbigquery.tables.getIamPolicy\nbigquery.tables.list\ndataplex.projects.search\nresourcemanager.projects.get\nresourcemanager.projects.list\nBigQuery ObjectRef Admin\n(roles/bigquery.objectRefAdmin)\nAdminister ObjectRef resources that includes read and write permissions\nLowest-level resources where you can grant this role:\nConnection\nThis role can also be granted on Resource Manager resources (projects, folders, and organizations).\nbigquery.objectRefs.*\nBigQuery ObjectRef Reader\n(roles/bigquery.objectRefReader)\nRole for reading referenced objects via ObjectRefs in BigQuery\nLowest-level resources where you can grant this role:\nConnection\nThis role can also be granted on Resource Manager resources (projects, folders, and organizations).\nbigquery.objectRefs.read\nBigQuery Read Session User\n(roles/bigquery.readSessionUser)\nProvides the ability to create and use read sessions.\nThis role can only be granted on Resource Manager resources (projects, folders, and organizations).\nbigquery.readsessions.*\nresourcemanager.projects.get'
 ""July 16, 2024\nWhen you run a migration assessment for Amazon Redshift, Teradata, or Snowflake, the service also creates a dataset containing only highly aggregated assessment results [https://cloud.google.com/bigquery/docs/migration-assessment.md#shareable_aggregated_assessment_result]. This aggregated dataset doesn't contain any query logs; therefore, no personally identifiable information (PII) or business-sensitive information is visible. You can share this dataset [https://cloud.google.com/bigquery/docs/migration-assessment.md#share_your_dataset_with_users_in_other_projects] with users that are not in your project. This feature is in preview [https://cloud.google.com/products#product-launch-stages].\nJuly 11, 2024\nYou can now use EXPORT DATA [https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements] statements to reverse ETL BigQuery data to Spanner [https://cloud.google.com/bigquery/docs/export-to-spanner]. This feature is in preview [https://cloud.google.com/products/#product-launch-stages].\nJuly 01, 2024\nA weekly digest of client library updates from across the Cloud SDK [https://cloud.google.com/sdk].""
 'June 23, 2025\nYou can now use the Apache Iceberg REST catalog in BigLake metastore [https://cloud.google.com/bigquery/docs/blms-rest-catalog] to create interoperability between your query engines by allowing your open source engines to access Iceberg data in Cloud Storage. This feature is in Preview [https://cloud.google.com/products#product-launch-stages].\nColab Enterprise notebooks in BigQuery let you do the following in Preview [https://cloud.google.com/products/#product-launch-stages]:\nExplain code with Gemini assistance [https://cloud.google.com/bigquery/docs/write-sql-gemini#explain_python_code]\nFix and explain errors with Gemini assistance [https://cloud.google.com/bigquery/docs/write-sql-gemini#fix_and_explain_python_errors]\nJune 18, 2025'
 'bigquery.rowAccessPolicies.setIamPolicy\nbigquery.rowAccessPolicies.update\nbigquery.savedqueries.*\nbigquery.tables.*\nbigquery.transfers.*\nbigquerymigration.translation.translate\ncloudkms.keyHandles.*\ncloudkms.operations.get\ncloudkms.projects.showEffectiveAutokeyConfig\ndataform.*\ndataplex.datascans.*\ndataplex.operations.get\ndataplex.operations.list\ndataplex.projects.search\nresourcemanager.projects.get\nresourcemanager.projects.list\nBigQuery Connection Admin\n(roles/bigquery.connectionAdmin)\nLowest-level resources where you can grant this role:\nConnection\nThis role can also be granted on Resource Manager resources (projects, folders, and organizations).\nbigquery.connections.*\nBigQuery Connection User\n(roles/bigquery.connectionUser)\nLowest-level resources where you can grant this role:\nConnection\nThis role can also be granted on Resource Manager resources (projects, folders, and organizations).\nbigquery.connections.get\nbigquery.connections.getIamPolicy\nbigquery.connections.list\nbigquery.connections.use\nBigQuery Data Editor\n(roles/bigquery.dataEditor)\nWhen granted on a dataset, this role grants these permissions:\nGet metadata and permissions for the dataset.\nFor tables and views:'
 'bigquery/reservation: Mention that some fields are deprecated (597ea0f [https://github.com/googleapis/google-cloud-go/commit/597ea0fe09bcea04e884dffe78add850edb2120d])\nThe results for queries against table snapshots [https://cloud.google.com/bigquery/docs/table-snapshots-intro] can now be returned from cache [https://cloud.google.com/bigquery/docs/cached-results].\nApril 06, 2023\nThe add data demo guide [https://cloud.google.com/bigquery/docs/bigquery-web-ui#run_add_data_demo_guide] walks you through the process of adding data to BigQuery through popular sources and is now in preview [https://cloud.google.com/products/#product-launch-stages].\nApril 05, 2023\nNon-incremental materialized views [https://cloud.google.com/bigquery/docs/materialized-views-create#non-incremental] support most SQL queries, including OUTER JOIN, UNION, and HAVING clauses, as well as analytic functions. This feature is in preview [https://cloud.google.com/products/#product-launch-stages].\nApril 04, 2023\nBigQuery is now available in the Israel (me-west1) [https://cloud.google.com/bigquery/docs/locations] region.\nApril 03, 2023'
 ""Q: BigQuery에서 쿼리 실행 단계의 병렬 입력 세그먼트 수를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 병렬 입력 세그먼트 수는 'parallelInputs' 필드를 사용하여 확인할 수 있습니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 완료된 병렬 입력 세그먼트 수를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 완료된 병렬 입력 세그먼트 수는 'completedParallelInputs' 필드를 사용하여 확인할 수 있습니다.""
 'Q: BigQuery에서 쿼리 단계의 입력 데이터 변경 통찰력을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 단계의 입력 데이터 변경 통찰력을 확인하려면 StagePerformanceChangeInsight 필드를 사용해야 합니다. 이 필드는 이전 실행과 비교한 입력 데이터 변경 통찰력을 제공합니다.'
 ""Q: BigQuery에서 쿼리 실행 단계의 현재 상태를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 현재 상태를 확인하려면 'status' 필드를 사용해야 합니다.""
 ""Q: BigQuery에서 LOAD 쿼리의 입력 파일 수를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 'inputFiles' 필드를 사용하여 LOAD 쿼리의 입력 파일 수를 확인할 수 있습니다.""
 'Q: jobs.query 메서드를 호출한 후, 쿼리 결과를 확인하기 위해 어떤 필드를 확인해야 하나요?\nA: 쿼리 결과를 확인하기 위해 jobComplete 필드를 확인해야 합니다. 이 필드가 true이면 쿼리가 완료된 것입니다.'
 ""Q: BigQuery에서 쿼리 실행 단계의 고유 ID를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 고유 ID는 'id' 필드에서 확인할 수 있습니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 고유 ID를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 고유 ID를 확인하려면 'id' 필드를 사용해야 합니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 시작 시간을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 시작 시간을 확인하려면 'startMs' 필드를 사용해야 합니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 시작 시간을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 'startMs' 필드를 사용하여 쿼리 실행 단계의 시작 시간을 확인할 수 있습니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 현재 상태를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 'status' 필드를 사용하여 쿼리 실행 단계의 현재 상태를 확인할 수 있습니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 현재 상태를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 현재 상태는 'status' 필드를 사용하여 확인할 수 있습니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 총 읽기 비율을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 총 읽기 비율을 확인하려면 'readRatioAvg' 필드를 사용해야 합니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 평균 대기 시간을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 평균 대기 시간을 확인하려면 'waitMsAvg' 필드를 사용해야 합니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 슬롯 밀리초(slot-milliseconds) 사용량을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 실행 단계의 슬롯 밀리초 사용량은 'slotMs' 필드를 사용하여 확인할 수 있습니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 평균 대기 시간을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 'waitMsAvg' 필드를 사용하여 쿼리 실행 단계의 평균 대기 시간을 확인할 수 있습니다.""
 ""Q: BigQuery에서 쿼리 실행 단계의 총 읽기 비율을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 'readRatioAvg' 필드를 사용하여 쿼리 실행 단계의 총 읽기 비율을 확인할 수 있습니다.""
 'Q: BigQuery에서 LOAD 쿼리의 입력 파일 수를 확인하려면 어떤 필드를 사용해야 하나요?\nA: LOAD 쿼리의 입력 파일 수를 확인하려면 inputFiles 필드를 사용해야 합니다.'
 ""Q: BigQuery에서 쿼리 작업의 실행 계획을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 쿼리 작업의 실행 계획을 확인하려면 'queryPlan' 필드를 사용해야 합니다. 이 필드는 쿼리의 실행 계획을 설명합니다.""
 ""Q: BigQuery에서 쿼리 작업을 구성할 때 필수로 설정해야 하는 필드는 무엇인가요?\nA: 'query' 필드(string)를 필수로 설정해야 합니다. 이 필드는 실행할 SQL 쿼리 텍스트를 포함합니다.""
 'Q: GMSFetchPlaceRequest 객체를 사용하여 요청할 수 있는 필드 목록에는 어떤 것들이 있나요?\nA: 다음 필드 중 하나 이상을 지정해야 합니다: GMSPlacePropertyPlaceID, GMSPlacePropertyPhotos, GMSPlacePropertyAddressComponents, GMSPlacePropertyFormattedAddress, GMSPlacePropertyCoordinate, GMSPlacePropertyPlusCode, GMSPlacePropertyTypes, GMSPlacePropertyViewport, GMSPlacePropertyBusinessStatus, GMSPlacePropertyIconBackgroundColor, GMSPlacePropertyIconImageURL, GMSPlacePropertyName, GMSPlacePropertyUTCOffsetMinutes, GMSPlacePropertyWheelchairAccessibleEntrance, GMSPlacePropertyCurrentOpeningHours, GMSPlacePropertySecondaryOpeningHours, GMSPlacePropertyPhoneNumber, GMSPlacePropertyPriceLevel, GMSPlacePropertyRating, GMSPlacePropertyOpeningHours, GMSPlacePropertyUserRatingsTotal, GMSPlacePropertyWebsite, GMSPlacePropertyCurbsidePickup, GMSPlacePropertyDelivery, GMSPlacePropertyDineIn, GMSPlacePropertyEditorialSummary, GMSPlacePropertyReservable, GMSPlacePropertyReviews, GMSPlacePropertyServesBeer, GMSPlacePropertyServesBreakfast, GMSPlacePropertyServesBrunch, GMSPlacePropertyServesDinner, GMSPlacePropertyServesLunch, GMSPlacePropertyServesVegetarianFood, GMSPlacePropertyServesWine, GMSPlacePropertyTakeout.'
 'Q: 장소 세부정보 요청에서 사용할 수 있는 Place.Field의 필드는 어떤 것들이 있나요?\nA: 장소 세부정보 요청에서 사용할 수 있는 Place.Field의 필드는 다음과 같습니다:\n- Place.Field.ACCESSIBILITY_OPTIONS\n- Place.Field.BUSINESS_STATUS\n- Place.Field.DISPLAY_NAME\n- Place.Field.GOOGLE_MAPS_URI\n- Place.Field.ICON_BACKGROUND_COLOR\n- Place.Field.PRIMARY_TYPE\n- Place.Field.PRIMARY_TYPE_DISPLAY_NAME\n- Place.Field.UTC_OFFSET\n- Place.Field.CURRENT_OPENING_HOURS\n- Place.Field.NATIONAL_PHONE_NUMBER\n- Place.Field.OPENING_HOURS\n- Place.Field.PRICE_LEVEL\n- Place.Field.RATING\n- Place.Field.WEBSITE_URI'
 'Q: 이벤트의 설명을 추가할 때 어떤 필드를 사용해야 하나요?\nA: 이벤트에 대한 설명은 description 필드를 사용하여 추가할 수 있습니다. 이 필드는 HTML을 포함할 수 있으며 선택사항입니다.'
 'Q: AI 기반 장소 요약을 요청할 때 어떤 필드를 포함해야 하나요?\nA: 응답에 장소 요약을 반환하려면 요청의 필드 마스크 (field mask)에 다음 필드를 포함하세요. 장소 세부정보 (new): generativeSummary, 텍스트 검색 (new) 및 주변 검색 (new): places.generativeSummary.'
 'Q: Progress 객체의 필드에 대한 설명은 어디에서 확인할 수 있나요?\nA: Progress 객체의 필드는 다음과 같이 설명됩니다:\n\n| Fields |\n| --- |\n| estimatedWork | string (int64 format) The amount of work estimated. |\n| completedWork | string (int64 format) The amount of work completed. |'
 'Q: rowAccessPolicies.testIamPermissions 메서드를 사용하여 어떤 정보를 얻을 수 있나요?\nA: rowAccessPolicies.testIamPermissions 메서드는 호출자가 지정된 리소스에 대해 가지고 있는 권한을 반환합니다. 리소스가 존재하지 않는 경우, NOT_FOUND 오류 대신 빈 권한 집합이 반환됩니다.'
 'Q: BigQuery에서 저장된 열이 사용되지 않은 이유를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 저장된 열이 사용되지 않은 이유는 `storedColumnsUnusedReasons` 필드를 통해 확인할 수 있습니다.'
 ""Q: BigQuery에서 테이블 복사 작업의 생성 조건을 설정하려면 어떤 필드를 사용해야 하나요?\nA: 테이블 복사 작업의 생성 조건을 설정하려면 `createDisposition` 필드를 사용해야 합니다. 이 필드는 새 테이블을 생성할 수 있는지 여부를 지정합니다. 지원되는 값은 다음과 같습니다: `CREATE_IF_NEEDED` (테이블이 존재하지 않으면 BigQuery가 테이블을 생성함), `CREATE_NEVER` (테이블이 이미 존재해야 하며, 존재하지 않을 경우 'notFound' 오류가 반환됨)입니다. 기본값은 `CREATE_IF_NEEDED`입니다.""
 'Q: BigQuery 테이블의 기본 키와 외래 키 정보를 어떻게 확인하나요?\nA: BigQuery 테이블의 기본 키와 외래 키 정보는 tableConstraints 필드를 통해 확인할 수 있습니다. 이 필드는 선택적이며, 테이블의 제약 조건을 정의합니다.'
 'Q: BigQuery에서 벡터 검색 쿼리에서 인덱스가 사용되지 않은 이유를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 벡터 검색 쿼리에서 인덱스가 사용되지 않은 이유는 `indexUnusedReasons` 필드를 통해 확인할 수 있습니다.'
 'Q: BigQuery 데이터셋의 ID는 어떻게 구성되나요?\nA: 데이터셋의 ID는 `id` 필드를 통해 확인할 수 있으며, 형식은 `projectId:datasetId`입니다. 이 필드는 데이터셋의 고유한 이름을 나타내며, 데이터셋을 생성할 때는 이 필드를 비워두고 대신 `datasetId` 필드를 지정해야 합니다.'
 'Q: BigQuery 데이터셋의 생성 시간을 확인하는 방법은 무엇인가요?\nA: 데이터셋의 생성 시간은 `creationTime` 필드를 통해 확인할 수 있습니다. 이 필드는 데이터셋이 생성된 시간을 나타내며, 출력 전용 필드입니다.'
 'Q: BigQuery에서 파티션된 테이블의 파티션 열 정보를 어떻게 확인할 수 있나요?\nA: 파티션된 테이블의 파티션 열 정보는 `partitionedColumn` 필드를 통해 확인할 수 있습니다. 이 필드는 각 파티션 열에 대한 세부 정보를 포함하며, BigQuery 네이티브 테이블은 최대 1개의 파티션 열만 지원합니다. 예를 들어, JSON 표현은 다음과 같습니다:\n\n```json\n{\n  ""partitionedColumn"": [\n    {\n      ""field"": ""city""\n    }\n  ]\n}\n```'
 'Q: BigQuery 테이블의 필드에 기본값을 설정하는 방법은 무엇인가요?\nA: BigQuery 테이블의 필드에 기본값을 설정하려면 defaultValueExpression 필드를 사용해야 합니다. 이 필드는 SQL 표현식을 통해 필드의 기본값을 지정할 수 있습니다.'
 'Q: BigQuery에서 물리적 뷰의 마지막 새로 고침 시간을 확인하는 방법은 무엇인가요?\nA: 물리적 뷰의 마지막 새로 고침 시간은 `MaterializedViewDefinition`의 `lastRefreshTime` 필드를 통해 확인할 수 있습니다. 이 필드는 밀리초 단위로 표현됩니다.'
 'Q: BigQuery에서 높은 카디널리티 조인의 세부 정보를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 높은 카디널리티 조인의 세부 정보를 확인하려면 HighCardinalityJoin 필드를 사용해야 합니다. 이 필드는 특정 단계에서 높은 카디널리티 조인에 대한 정보를 제공합니다.'
 'Q: BigQuery 테이블의 파티션 수를 확인하는 방법은 무엇인가요?\nA: 테이블 또는 물리적 뷰에 존재하는 파티션 수는 numPartitions 필드를 통해 확인할 수 있습니다. 이 데이터는 실시간으로 유지되지 않으며, 몇 초에서 몇 분 정도 지연될 수 있습니다.'
 ""Q: BigQuery에서 파티션 스큐(PartitionSkew)의 소스 단계 정보를 확인하려면 어떤 필드를 사용해야 하나요?\nA: 소스 단계 정보는 'skewSources' 필드를 사용하여 확인할 수 있습니다.""
 'Q: BigQuery 테이블의 물리적 크기를 확인하는 방법은 무엇인가요?\nA: 테이블의 물리적 크기는 numTotalPhysicalBytes 필드를 통해 확인할 수 있습니다. 이 필드는 테이블의 물리적 크기를 바이트 단위로 나타내며, 시간 여행에 사용되는 저장소도 포함됩니다. 이 데이터는 실시간으로 유지되지 않으며, 몇 초에서 몇 분 정도 지연될 수 있습니다.'
 'Q: BigQuery 테이블의 파티션 수를 확인하는 방법은 무엇인가요?\nA: BigQuery 테이블의 파티션 수는 numPartitions 필드를 통해 확인할 수 있습니다. 이 필드는 테이블 또는 물리적 뷰에 존재하는 파티션의 수를 나타내며, 실시간으로 유지되지 않으므로 몇 초에서 몇 분 정도 지연될 수 있습니다.'
 'Q: BigQuery에서 HivePartitioningOptions의 requirePartitionFilter 필드는 어떤 역할을 하나요?\nA: requirePartitionFilter 필드는 true로 설정되면 이 테이블에 대한 쿼리는 파티션 필터를 지정해야 하며, 이를 통해 파티션 제거가 가능해집니다. 이 필드는 영구 외부 테이블을 생성할 때만 true로 설정해야 합니다.'
 'Q: BigQuery에서 물리적 뷰의 마지막 새로 고침 시간을 어떻게 확인하나요?\nA: 물리적 뷰의 마지막 새로 고침 시간은 `lastRefreshTime` 필드를 통해 확인할 수 있습니다. 이 필드는 밀리초 단위로 표시됩니다. 예를 들어, JSON 표현은 다음과 같습니다:\n\n```json\n{\n  ""lastRefreshTime"": ""1633036800000""\n}\n```'
 'Q: IAM 정책에서 etag 필드를 사용하는 이유는 무엇인가요?\nA: etag 필드는 정책의 낙관적 동시성 제어(optimistic concurrency control)를 위해 사용됩니다. 이를 통해 정책의 동시 업데이트로 인한 덮어쓰기를 방지할 수 있습니다. getIamPolicy의 응답에서 etag가 반환되며, 시스템은 setIamPolicy 요청 시 이 etag를 포함시켜야 합니다.'
 'Q: BigQuery의 projects 리소스에 대한 설명은 무엇인가요?\nA: BigQuery의 projects 리소스는 지속적인 데이터와 관련이 없습니다. 이 리소스는 프로젝트와 관련된 메서드를 통해 다양한 작업을 수행할 수 있도록 합니다.'
 ""Q: BigQuery에서 HivePartitioningOptions의 'requirePartitionFilter' 필드는 어떤 역할을 하나요?\nA: 'requirePartitionFilter' 필드는 true로 설정되면 이 테이블에 대한 쿼리에서 파티션 필터를 지정해야 하며, 이를 통해 파티션 제거가 가능해집니다. 이 필드는 영구 외부 테이블을 생성하거나 임시 외부 테이블을 쿼리할 때만 true로 설정해야 합니다.""
 'Q: BigQuery에서 특정 단계의 성능 통찰력을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 특정 단계의 성능 통찰력을 확인하려면 StagePerformanceStandaloneInsight 필드를 사용해야 합니다. 이 필드는 특정 단계에 대한 독립적인 성능 통찰력을 제공합니다.'
 'Q: TargetType에서 사용할 수 있는 enum 값은 무엇이 있나요?\nA: TargetType에서 사용할 수 있는 enum 값은 다음과 같습니다: \n\n```plaintext\nTARGET_TYPE_UNSPECIFIED Do not use. You must set a target type explicitly.\nVIEWS This entry applies to views in the dataset.\n```'
 'Q: Common Expression Language (CEL)에서 표현식의 예시는 무엇인가요?\nA: Common Expression Language (CEL)에서 표현식의 예시는 다음과 같습니다:\n\n예시 (비교):\n```\ntitle: ""Summary size limit""\ndescription: ""Determines if a summary is less than 100 chars""\nexpression: ""document.summary.size() < 100""\n```\n\n예시 (동등성):\n```\ntitle: ""Requestor is owner""\ndescription: ""Determines if requestor is the document owner""\nexpression: ""document.owner == request.auth.claims.email""\n```\n\n예시 (논리):\n```\ntitle: ""Public documents""\ndescription: ""Determine whether the document should be publicly visible""\nexpression: ""document.type != \'private\' && document.type != \'internal\'""\n```\n\n예시 (데이터 조작):\n```\ntitle: ""Notification string""\ndescription: ""Create a notification string with a timestamp.""\nexpression: ""\'New message received at \' + string(document.create_time)""\n```'
 'Q: IAM 정책의 condition 필드에서 사용할 수 있는 표현식의 예시는 무엇인가요?\nA: 다음은 IAM 정책의 condition 필드에서 사용할 수 있는 표현식의 예시입니다:\n\n```\ntitle: ""Summary size limit""\ndescription: ""Determines if a summary is less than 100 chars""\nexpression: ""document.summary.size() < 100""\n```\n\n또 다른 예시는:\n```\ntitle: ""Requestor is owner""\ndescription: ""Determines if requestor is the document owner""\nexpression: ""document.owner == request.auth.claims.email""\n```'
 ""Q: BigQuery에서 BigtableColumn의 'qualifierEncoded' 필드는 무엇을 나타내나요?\nA: BigtableColumn의 'qualifierEncoded' 필드는 열의 식별자를 나타내며, 부모 열 패밀리에서 이 정확한 식별자를 가진 열이 <family field name>.<column field name> 필드로 노출됩니다. 유효한 UTF-8 문자열일 경우 'qualifierString' 필드에 지정할 수 있습니다.""
 ""Q: BigQuery에서 BigtableColumn의 'qualifierEncoded' 필드는 어떤 역할을 하나요?\nA: 'qualifierEncoded' 필드는 열의 자격을 나타내며, 부모 열 패밀리에서 이 정확한 자격을 가진 열이 <family field name>.<column field name> 필드로 노출됩니다. 자격이 유효한 UTF-8 문자열인 경우 'qualifierString' 필드에 지정할 수 있으며, 그렇지 않은 경우 base-64로 인코딩된 값을 'qualifierEncoded'에 설정해야 합니다.""
 'Q: Explanation 객체의 attribution 필드는 어떤 정보를 제공하나요?\nA: Explanation 객체의 attribution 필드는 특정 피처의 기여도를 나타냅니다. 이 필드는 다음과 같은 JSON 표현을 가집니다:\n\n```json\n{\n  ""attribution"": number\n}\n```'
 'Q: TestIamPermissionsResponse의 JSON 구조는 어떻게 되나요?\nA: TestIamPermissionsResponse의 JSON 구조는 다음과 같습니다:\n\n```\n{\n  ""permissions"": [\n    string\n  ]\n}\n```'
 'Q: TargetType의 VIEWS는 어떤 리소스에 적용되나요?\nA: VIEWS는 데이터셋(dataset) 내의 뷰(views)에 적용되는 항목입니다.'
 'Q: TargetType을 설정할 때 주의해야 할 점은 무엇인가요?\nA: TargetType을 설정할 때는 반드시 target type을 명시적으로 설정해야 하며, TARGET_TYPE_UNSPECIFIED는 사용하지 않아야 합니다.'
 'Q: TARGET_TYPE_UNSPECIFIED의 의미는 무엇인가요?\nA: TARGET_TYPE_UNSPECIFIED는 사용하지 말아야 하며, 반드시 명시적으로 target type을 설정해야 합니다.'
 'Q: BigQuery에서 TargetType의 사용 목적은 무엇인가요?\nA: TargetType은 데이터셋(dataset) 내에서 항목이 적용되는 리소스의 유형을 나타냅니다.'
 'Q: tables.update 메서드를 사용하기 위해 필요한 인증 범위는 무엇인가요?\nA: tables.update 메서드를 사용하기 위해 필요한 인증 범위는 다음 중 하나입니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform'
 'Q: tables.update 메서드에서 사용할 수 있는 선택적 쿼리 파라미터는 무엇인가요?\nA: tables.update 메서드에서 사용할 수 있는 선택적 쿼리 파라미터는 autodetectSchema입니다. 이 파라미터가 true로 설정되면 스키마를 자동으로 감지하고, 그렇지 않으면 원래 스키마를 유지합니다.'
 'Q: tables.update 메서드의 요청 본문에는 어떤 정보가 포함되어야 하나요?\nA: tables.update 메서드의 요청 본문에는 Table 인스턴스가 포함되어야 합니다.'
 'Q: tables.update 메서드를 호출할 때 필요한 HTTP 요청 형식은 어떻게 되나요?\nA: tables.update 메서드를 호출할 때 필요한 HTTP 요청 형식은 다음과 같습니다:\n```\nPUT https://bigquery.googleapis.com/bigquery/v2/projects/{projectId}/datasets/{datasetId}/tables/{tableId}\n```'
 'Q: BigQuery에서 테이블 정보를 업데이트할 때 사용하는 메서드는 무엇인가요?\nA: 테이블 정보를 업데이트할 때 사용하는 메서드는 tables.update입니다. 이 메서드는 기존 테이블 리소스를 전체적으로 교체합니다.'
 ""Q: tables.testIamPermissions 메서드의 사용 시 주의사항은 무엇인가요?\nA: tables.testIamPermissions 메서드는 권한 확인을 위한 것이 아니라 권한 인식 UI 및 명령줄 도구를 구축하기 위해 설계되었습니다. 이 작업은 경고 없이 'fail open'할 수 있습니다. 따라서 이 메서드를 사용할 때는 이러한 특성을 고려해야 합니다.""
 'Q: datasets.get 메서드에서 사용할 수 있는 쿼리 파라미터는 무엇이 있나요?\nA: datasets.get 메서드에서 사용할 수 있는 쿼리 파라미터는 `accessPolicyVersion`입니다. 이 파라미터는 선택 사항이며, 접근 정책 스키마의 버전을 가져오는 데 사용됩니다. 유효한 값은 0, 1, 3입니다.'
 'Q: tables.get 메서드의 요청 본문은 어떻게 구성되나요?\nA: tables.get 메서드의 요청 본문은 비어 있어야 합니다. 즉, 요청 본문은 다음과 같이 설정해야 합니다:\n\n```\n{ }\n```'
 'Q: DataFormatOptions에서 사용할 수 있는 필드는 무엇이 있나요?\nA: DataFormatOptions에서 사용할 수 있는 필드는 `useInt64Timestamp` 하나입니다.'
 ""Q: 주소 유효성 검사 API의 'possibleNextAction' 필드는 어떤 정보를 제공하나요?\nA: 'possibleNextAction' 필드는 API 응답의 해석 요약을 제공하여 취할 수 있는 잠재적인 후속 조치를 결정하는 데 도움을 줍니다. 이 필드는 API 응답의 다른 필드에서 파생됩니다.""
 'Q: FieldOperationMetadata에서 어떤 정보를 확인할 수 있나요?\nA: | Fields |\n| --- |\n| start_time | Timestamp The time this operation started. |\n| end_time | Timestamp The time this operation completed. Will be unset if operation still in progress. |\n| field | string The field resource that this operation is acting on. For example: projects/{project_id}/databases/{database_id}/collectionGroups/{collection_id}/fields/{field_path} |\n| index_config_deltas[] | IndexConfigDelta A list of IndexConfigDelta, which describe the intent of this operation. |\n| state | OperationState The state of the operation. |\n| document_progress | Progress The progress, in documents, of this operation. |\n| bytes_progress | Progress The progress, in bytes, of this operation.'
 'Q: 동네 요약을 요청할 때 응답의 neighborhoodSummary 필드에는 어떤 정보가 포함되나요?\nA: 응답의 neighborhoodSummary 필드에는 두 개의 하위 필드: overview 및 description이 포함됩니다. overview 하위 필드에는 장소와 관련된 인근 관심 장소가 포함되고, description 하위 필드에는 주변 지역에 관한 일반적인 정보가 제공됩니다.'
 'Q: BigQuery 데이터셋의 설명을 추가하는 방법은 무엇인가요?\nA: 데이터셋의 설명은 `description` 필드를 사용하여 추가할 수 있습니다. 이 필드는 사용자 친화적인 설명을 제공하는 선택적 필드입니다. 데이터셋을 생성하거나 업데이트할 때 이 필드를 포함하여 설명을 설정할 수 있습니다.'
 'Q: tables.testIamPermissions 메서드의 응답 본문은 어떤 형식을 가지나요?\nA: 성공적으로 호출된 경우, 응답 본문은 TestIamPermissionsResponse 인스턴스를 포함합니다. 이 응답은 호출자가 요청한 권한의 상태를 나타냅니다.'
 'Q: tables.testIamPermissions 메서드를 호출할 때 필요한 OAuth 스코프는 무엇인가요?\nA: tables.testIamPermissions 메서드를 호출하기 위해서는 다음 중 하나의 OAuth 스코프가 필요합니다:\n- https://www.googleapis.com/auth/bigquery\n- https://www.googleapis.com/auth/cloud-platform\n- https://www.googleapis.com/auth/bigquery.readonly\n- https://www.googleapis.com/auth/cloud-platform.read-only\n자세한 내용은 인증 개요(Authentication Overview)를 참조하세요.'
 'Q: tables.testIamPermissions 메서드의 요청 본문 구조는 어떻게 되나요?\nA: 요청 본문은 다음과 같은 구조를 가져야 합니다:\n\n```\n{\n  ""permissions"": [\n    string\n  ]\n}\n```\n여기서 permissions 필드는 리소스에 대해 확인할 권한의 집합을 포함합니다. 와일드카드(예: *, storage.*)는 허용되지 않습니다.']",BigQuery에서 쿼리 실행 단계의 병렬 입력 세그먼트 수를 확인하려면 'parallelInputs' 필드를 사용해야 합니다. 이 필드는 쿼리 실행 단계에서 병렬로 처리되는 입력 세그먼트의 수를 나타냅니다. 이를 통해 사용자는 쿼리의 특정 단계에서 얼마나 많은 입력이 동시에 처리되고 있는지를 파악할 수 있습니다. 이는 쿼리의 병렬 처리 성능을 이해하고 최적화하는 데 유용한 정보를 제공합니다.,"BigQuery에서 쿼리 실행 단계의 병렬 입력 세그먼트 수를 확인하려면 'parallelInputs' 필드를 사용해야 합니다. 이 필드는 쿼리 실행 단계에서 병렬로 처리되는 입력 세그먼트의 수를 나타내며, 사용자는 이를 통해 쿼리 실행의 병렬 처리 수준을 파악할 수 있습니다."
itemDownlodRestrction 뭐에요?,"['inheritedPermissionsDisabled\nboolean\n이 파일에 상속된 권한이 사용 중지되었는지 여부입니다. 상속된 권한은 기본적으로 사용 설정되어 있습니다.\ndownloadRestrictions\nobject (DownloadRestrictionsMetadata [https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File.DownloadRestrictionsMetadata])\n파일에 적용된 다운로드 제한사항입니다.\nContentRestriction\n파일 콘텐츠 액세스 제한입니다.\nJSON 표현\n{\n  ""readOnly"": boolean,\n  ""reason"": string,\n  ""type"": string,\n  ""restrictingUser"": {\n    object (User [https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko])\n  },\n  ""restrictionTime"": string,\n  ""ownerRestricted"": boolean,\n  ""systemRestricted"": boolean\n}\n필드\nreadOnly\nboolean\n파일의 콘텐츠가 읽기 전용인지 여부입니다. 파일이 읽기 전용인 경우 파일의 새 버전이 추가되지 않고, 댓글이 추가되거나 수정되지 않으며, 파일의 제목이 수정되지 않을 수 있습니다.\nreason\nstring\n파일의 콘텐츠가 제한된 이유입니다. 이는 readOnly=true도 설정하는 요청에서만 변경할 수 있습니다.\ntype\nstring\n출력 전용입니다. 콘텐츠 제한의 유형입니다. 현재 가능한 유일한 값은 globalContentRestriction입니다.\nrestrictingUser\nobject (User [https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko])\n출력 전용입니다. 콘텐츠 제한을 설정한 사용자입니다. readOnly가 true인 경우에만 채워집니다.\nrestrictionTime\nstring\n출력 전용입니다. 콘텐츠 제한이 설정된 시간입니다 (형식화된 RFC 3339 타임스탬프). readOnly가 true인 경우에만 채워집니다.\nownerRestricted\nboolean'
 'object (DownloadRestriction [https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File.DownloadRestriction])\n출력 전용입니다. 이 파일에 적용된 유효한 다운로드 제한입니다. 모든 제한 설정과 DLP 규칙이 고려됩니다.\nDownloadRestriction\n파일의 복사 및 다운로드에 대한 제한입니다.\nJSON 표현\n{\n  ""restrictedForReaders"": boolean,\n  ""restrictedForWriters"": boolean\n}\n필드\nrestrictedForReaders\nboolean\n독자의 다운로드 및 복사가 제한되는지 여부입니다.\nrestrictedForWriters\nboolean\n작성자의 다운로드 및 복사가 제한되는지 여부입니다. true인 경우 독자의 다운로드도 제한됩니다.\n메서드\ncopy [https://developers.google.com/workspace/drive/api/reference/rest/v3/files/copy?hl=ko]\n파일의 사본을 만들고 패치 의미 체계를 사용하여 요청된 업데이트를 적용합니다.\ncreate [https://developers.google.com/workspace/drive/api/reference/rest/v3/files/create?hl=ko]\n새 파일을 만듭니다.\ndelete [https://developers.google.com/workspace/drive/api/reference/rest/v3/files/delete?hl=ko]\n사용자가 소유한 파일을 휴지통으로 이동하지 않고 영구적으로 삭제합니다.\ndownload [https://developers.google.com/workspace/drive/api/reference/rest/v3/files/download?hl=ko]\n파일의 콘텐츠를 다운로드합니다.\nemptyTrash [https://developers.google.com/workspace/drive/api/reference/rest/v3/files/emptyTrash?hl=ko]\n사용자의 휴지통에 있는 모든 파일을 영구적으로 삭제합니다.'
 'restrictionTime\nstring\n출력 전용입니다. 콘텐츠 제한이 설정된 시간입니다 (형식화된 RFC 3339 타임스탬프). readOnly가 true인 경우에만 채워집니다.\nownerRestricted\nboolean\n콘텐츠 제한을 파일 소유자만 수정하거나 삭제할 수 있는지 여부입니다. 공유 드라이브의 경우 organizer 기능이 있는 모든 사용자가 이 콘텐츠 제한을 수정하거나 삭제할 수 있습니다.\nsystemRestricted\nboolean\n출력 전용입니다. 콘텐츠 제한이 시스템에 의해 적용되었는지 여부입니다(예: 전자 서명으로 인해). 사용자는 시스템 제한 콘텐츠 제한을 수정하거나 삭제할 수 없습니다.\nDownloadRestrictionsMetadata\n파일에 적용된 다운로드 제한사항입니다.\nJSON 표현\n{\n  ""itemDownloadRestriction"": {\n    object (DownloadRestriction [https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File.DownloadRestriction])\n  },\n  ""effectiveDownloadRestrictionWithContext"": {\n    object (DownloadRestriction [https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File.DownloadRestriction])\n  }\n}\n필드\nitemDownloadRestriction\nobject (DownloadRestriction [https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File.DownloadRestriction])\n소유자 또는 주최자가 직접 적용한 파일의 다운로드 제한입니다. 공유 드라이브 설정 또는 DLP 규칙은 고려하지 않습니다.\neffectiveDownloadRestrictionWithContext\nobject (DownloadRestriction [https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File.DownloadRestriction])'
 'restrictions.adminManagedRestrictions\nboolean\n이 공유 드라이브의 제한을 수정하는 데 관리 권한이 필요한지 여부입니다.\nrestrictions.sharingFoldersRequiresOrganizerPermission\nboolean\ntrue인 경우 폴더를 공유할 수 있는 사용자는 관리자 역할이 있는 사용자뿐입니다. false인 경우, 호스트 역할 또는 파일 정리 도구 역할이 있는 사용자가 폴더를 공유할 수 있습니다.\nrestrictions.downloadRestriction\nobject (DownloadRestriction [https://developers.google.com/workspace/drive/api/reference/rest/v3/files?hl=ko#File.DownloadRestriction])\n공유 드라이브 관리자가 적용한 다운로드 제한사항\norgUnitId\nstring\n출력 전용입니다. 이 공유 드라이브의 조직 단위입니다. 이 필드는 useDomainAdminAccess 매개변수가 true로 설정된 경우 drives.list 응답에서만 채워집니다.\n메서드\ncreate [https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/create?hl=ko]\n공유 드라이브를 만듭니다.\ndelete [https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/delete?hl=ko]\n사용자가 organizer인 공유 드라이브를 완전히 삭제합니다.\nget [https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/get?hl=ko]\nID로 공유 드라이브의 메타데이터를 가져옵니다.\nhide [https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/hide?hl=ko]\n기본 보기에서 공유 드라이브를 숨깁니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v3/drives/list?hl=ko]\n사용자의 공유 드라이브를 나열합니다.'
 'itemRevenue 구매에서 발생한 총수익에서 상품에서만 발생한 환불된 거래 수익을 뺀 값입니다. 상품 수익은 가격과 수량의 곱입니다. 상품 수익에는 세금 및 배송비가 포함되지 않습니다. 세금 및 배송비는 상품 수준이 아닌 이벤트 수준에서 지정됩니다.\nitemsClickedInPromotion 단일 상품의 프로모션에서 클릭된 단위 수입니다. 이 측정항목은 select_promotion 이벤트의 상품 수량을 집계합니다.\nitemsPurchased 구매 이벤트에 포함된 단일 상품의 단위 수입니다. 이 측정항목은 구매 이벤트의 상품 수량을 집계합니다.\nitemsViewedInPromotion 단일 상품의 프로모션에서 조회된 단위 수입니다. 이 측정항목은 view_promotion 이벤트의 상품 수량을 집계합니다.\n표 이름: TechDetails\n필드 이름 설명\nappVersion 앱의 버전 이름 (Android) 또는 약식 번들 버전 (iOS)입니다.\nbrowser 웹사이트를 볼 때 사용한 브라우저입니다.\ndeviceCategory 기기의 유형(데스크톱, 태블릿, 모바일)입니다.\noperatingSystem 앱 또는 웹사이트 방문자가 사용한 운영체제입니다. Windows, Android와 같은 데스크톱 및 모바일 운영체제가 포함됩니다.\noperatingSystemVersion 웹사이트 또는 앱 방문자가 사용한 운영체제 버전입니다. 예를 들어 Android 10의 버전은 10이고 iOS 13.5.1의 버전은 13.5.1입니다.\noperatingSystemWithVersion 운영체제 및 버전입니다. 예: Android 10 또는 Windows 7\n플랫폼 앱이나 웹사이트가 실행된 플랫폼(예: 웹, iOS, Android)입니다. 보고서에서 스트림의 유형을 확인하려면 플랫폼과 streamId를 모두 사용하세요.\nplatformDeviceCategory 내 웹사이트 또는 모바일 앱이 실행된 플랫폼 및 기기 유형입니다. (예: Android / 모바일)\nscreenResolution 사용자 모니터의 화면 해상도입니다. 예: 1920x1080\nactiveUsers 웹사이트 또는 애플리케이션을 방문한 개별 사용자의 수입니다.\nengagedSessions 10초 넘게 지속되었거나, 주요 이벤트가 발생했거나, 화면 조회수가 2회 이상인 세션의 수입니다.'
 'Source URL: https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGoogle Drive [https://developers.google.com/workspace/drive?hl=ko]\n참조 [https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko]\n의견 보내기\nUser\nbookmark_border\nDrive 사용자에 관한 정보입니다.\nJSON 표현\n{\n  ""displayName"": string,\n  ""kind"": string,\n  ""me"": boolean,\n  ""permissionId"": string,\n  ""emailAddress"": string,\n  ""photoLink"": string\n}\n필드\ndisplayName\nstring\n출력 전용입니다. 이 사용자의 표시 가능한 일반 텍스트 이름입니다.\nkind\nstring\n출력 전용입니다. 리소스 종류를 식별합니다. 값: 고정 문자열 drive#user.\nme\nboolean\n출력 전용입니다. 이 사용자가 요청하는 사용자인지 여부입니다.\npermissionId\nstring\n출력 전용입니다. 권한 리소스에 표시되는 사용자의 ID입니다.\nemailAddress\nstring\n출력 전용입니다. 사용자의 이메일 주소입니다. 사용자가 요청자에게 이메일 주소를 표시하지 않은 경우 특정 컨텍스트에 표시되지 않을 수 있습니다.\nphotoLink\nstring\n출력 전용입니다. 사용자의 프로필 사진 링크입니다(사용 가능한 경우).\n의견 보내기'
 'list [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/list?hl=ko] GET /drive/v2/files/{fileId}/revisions\n파일의 버전을 나열합니다.\npatch [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/patch?hl=ko] PATCH /drive/v2/files/{fileId}/revisions/{revisionId}\n버전을 업데이트합니다.\nupdate [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/update?hl=ko] PUT /drive/v2/files/{fileId}/revisions/{revisionId}\n버전을 업데이트합니다.\n도움이 되었나요?\n의견 보내기'
 '지정된 댓글에 대한 새 답글을 만듭니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/list?hl=ko] GET /drive/v2/files/{fileId}/comments/{commentId}/replies\n댓글에 대한 모든 답글을 나열합니다.\npatch [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/patch?hl=ko] PATCH /drive/v2/files/{fileId}/comments/{commentId}/replies/{replyId}\n기존 답장을 업데이트합니다.\nupdate [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/update?hl=ko] PUT /drive/v2/files/{fileId}/comments/{commentId}/replies/{replyId}\n기존 답장을 업데이트합니다.\nREST 리소스: v2.revisions [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions?hl=ko]\n메서드\ndelete [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/delete?hl=ko] DELETE /drive/v2/files/{fileId}/revisions/{revisionId}\n파일 버전을 영구적으로 삭제합니다.\nget [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/get?hl=ko] GET /drive/v2/files/{fileId}/revisions/{revisionId}\n특정 버전을 가져옵니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/list?hl=ko] GET /drive/v2/files/{fileId}/revisions\n파일의 버전을 나열합니다.'
 '파일에 속성을 추가하거나 이미 있는 경우 업데이트합니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/list?hl=ko] GET /drive/v2/files/{fileId}/properties\n파일의 속성을 나열합니다.\npatch [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/patch?hl=ko] PATCH /drive/v2/files/{fileId}/properties/{propertyKey}\n속성을 업데이트합니다.\nupdate [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/update?hl=ko] PUT /drive/v2/files/{fileId}/properties/{propertyKey}\n속성을 업데이트합니다.\nREST 리소스: v2.replies [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies?hl=ko]\n메서드\ndelete [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/delete?hl=ko] DELETE /drive/v2/files/{fileId}/comments/{commentId}/replies/{replyId}\n답글을 삭제합니다.\nget [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/get?hl=ko] GET /drive/v2/files/{fileId}/comments/{commentId}/replies/{replyId}\n답장을 가져옵니다.\ninsert [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/insert?hl=ko] POST /drive/v2/files/{fileId}/comments/{commentId}/replies\n지정된 댓글에 대한 새 답글을 만듭니다.'
 '파일 또는 공유 드라이브의 권한을 삽입합니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v2/permissions/list?hl=ko] GET /drive/v2/files/{fileId}/permissions\n파일 또는 공유 드라이브의 권한을 표시합니다.\npatch [https://developers.google.com/workspace/drive/api/reference/rest/v2/permissions/patch?hl=ko] PATCH /drive/v2/files/{fileId}/permissions/{permissionId}\n패치 시맨틱스를 사용하여 권한을 업데이트합니다.\nupdate [https://developers.google.com/workspace/drive/api/reference/rest/v2/permissions/update?hl=ko] PUT /drive/v2/files/{fileId}/permissions/{permissionId}\n권한을 업데이트합니다.\nREST 리소스: v2.properties [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties?hl=ko]\n메서드\ndelete [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/delete?hl=ko] DELETE /drive/v2/files/{fileId}/properties/{propertyKey}\n속성을 삭제합니다.\nget [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/get?hl=ko] GET /drive/v2/files/{fileId}/properties/{propertyKey}\n키를 기준으로 속성을 가져옵니다.\ninsert [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/insert?hl=ko] POST /drive/v2/files/{fileId}/properties\n파일에 속성을 추가하거나 이미 있는 경우 업데이트합니다.'
 'boolean\n출력 전용입니다. 현재 사용자가 삭제할 수 있는 파일에 콘텐츠 제한이 있는지 여부입니다.\ncapabilities.canDisableInheritedPermissions\nboolean\n사용자가 상속된 권한을 사용 중지할 수 있는지 여부입니다.\ncapabilities.canEnableInheritedPermissions\nboolean\n사용자가 상속된 권한을 다시 사용 설정할 수 있는지 여부입니다.\ncapabilities.canChangeItemDownloadRestriction\nboolean\n출력 전용입니다. 현재 사용자가 파일의 소유자 또는 주최자가 적용한 다운로드 제한을 변경할 수 있는지 여부입니다.\nhasAugmentedPermissions\nboolean\n출력 전용입니다. 이 파일에 직접 권한이 있는지 여부입니다. 이 필드는 공유 드라이브의 항목에 대해서만 채워집니다.\ntrashingUser\nobject (User [https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko])\n출력 전용입니다. 파일이 명시적으로 휴지통으로 이동된 경우 휴지통으로 이동한 사용자입니다. 공유 드라이브의 항목에 대해서만 채워집니다.\nthumbnailVersion\nstring (int64 [https://developers.google.com/discovery/v1/type-format?hl=ko] format)\n출력 전용입니다. 썸네일 캐시 무효화에 사용할 썸네일 버전입니다.\ntrashedTime\nstring\n출력 전용입니다. 항목이 휴지통으로 이동된 시간입니다 (RFC 3339 날짜/시간). 공유 드라이브의 항목에 대해서만 채워집니다.\nmodifiedByMe\nboolean\n출력 전용입니다. 이 사용자가 파일을 수정했는지 여부입니다.\nimageMediaMetadata\nobject\n출력 전용입니다. 이미지 미디어에 관한 추가 메타데이터(사용 가능한 경우)입니다.\nimageMediaMetadata.flashUsed\nboolean\n출력 전용입니다. 사진을 만드는 데 플래시가 사용되었는지 여부입니다.\nimageMediaMetadata.meteringMode\nstring\n출력 전용입니다. 사진을 만드는 데 사용된 측광 모드입니다.\nimageMediaMetadata.sensor\nstring'
 ""Q: 파일의 다운로드 제한사항을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 파일의 다운로드 제한사항을 확인하려면 'itemDownloadRestriction' 필드를 사용해야 합니다.""
 ""Q: 파일의 다운로드 제한이 소유자 또는 주최자가 직접 적용한 것인지 확인하려면 어떤 필드를 사용해야 하나요?\nA: 파일의 다운로드 제한이 소유자 또는 주최자가 직접 적용한 것인지 확인하려면 'itemDownloadRestriction' 필드를 사용해야 합니다. 이 필드는 소유자 또는 주최자가 직접 적용한 파일의 다운로드 제한을 포함합니다.""
 ""Q: 파일의 복사 및 다운로드에 대한 제한을 확인하려면 어떤 객체를 참조해야 하나요?\nA: 파일의 복사 및 다운로드에 대한 제한을 확인하려면 'DownloadRestriction' 객체를 참조해야 합니다.""
 ""Q: 파일에 적용된 다운로드 제한사항을 확인하려면 어떤 필드를 사용해야 하나요?\nA: 파일에 적용된 다운로드 제한사항을 확인하려면 'downloadRestrictions' 필드를 사용해야 합니다. 이 필드는 파일에 적용된 다운로드 제한사항을 포함하는 객체입니다.""
 'Q: 공유 드라이브의 다운로드 제한을 설정하려면 어떤 필드를 사용해야 하나요?\nA: 공유 드라이브의 다운로드 제한은 `restrictions.downloadRestriction` 필드를 사용하여 설정할 수 있습니다. 이 필드는 공유 드라이브 관리자가 적용한 다운로드 제한사항을 포함합니다.'
 'Q: Visibility 열거형에서 PRIVATE의 의미는 무엇인가요?\nA: PRIVATE은 새 파일이 소유자에게만 표시된다는 것을 의미합니다.'
 'Q: Projection 열거형에서 지원 중단된 값은 무엇인가요?\nA: Projection 열거형(Projection enum)에서 지원 중단된 값은 BASIC과 FULL입니다.'
 'Q: changes.watch 메서드의 요청 본문에 포함해야 하는 내용은 무엇인가요?\nA: 요청 본문에는 Channel의 인스턴스가 포함되어야 합니다.'
 'Q: permissions.update 메서드의 쿼리 매개변수 중 removeExpiration의 역할은 무엇인가요?\nA: removeExpiration은 만료일을 삭제할지 여부를 나타내는 boolean 값입니다.'
 'Q: Google Drive API에서 공유 드라이브를 생성하는 방법은 무엇인가요?\nA: 공유 드라이브를 생성하려면 POST 메서드인 /drive/v3/drives를 사용해야 합니다.'
 'Q: Google Drive API에서 파일의 콘텐츠를 다운로드하는 방법은 무엇인가요?\nA: 파일의 콘텐츠를 다운로드하려면 POST 메서드인 /drive/v3/files/{fileId}/download를 사용해야 합니다.'
 'Q: permissions.update 메서드를 호출할 때 요청 본문에 포함해야 하는 내용은 무엇인가요?\nA: 요청 본문에는 Permission의 인스턴스가 포함되어야 합니다.'
 'Q: permissions.update 메서드에서 사용되는 경로 매개변수는 무엇인가요?\nA: 경로 매개변수로는 fileId(파일 또는 공유 드라이브의 ID)와 permissionId(권한의 ID)가 필요합니다.'
 'Q: 댓글의 ID를 가져오는 방법은 무엇인가요?\nA: 댓글의 ID는 comments.list 메서드를 사용하여 파일의 댓글 목록을 나열함으로써 가져올 수 있습니다.'
 'Q: permissions.update 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?\nA: 다음 OAuth 범위 중 하나가 필요합니다: https://www.googleapis.com/auth/drive 또는 https://www.googleapis.com/auth/drive.file.'
 'Q: 댓글을 삭제하는 메서드(delete)의 사용법은 무엇인가요?\nA: 댓글을 삭제하기 위해서는 comments.delete 메서드를 사용합니다. 이 메서드는 특정 댓글을 삭제하는 기능을 제공합니다.'
 ""Q: files.create 메서드에서 'uploadType' 파라미터의 사용 가능한 값은 무엇인가요?\nA: files.create 메서드에서 'uploadType' 파라미터의 사용 가능한 값은 media, multipart, resumable입니다.""
 'Q: replies.update 메서드의 요청 본문에 포함해야 하는 내용은 무엇인가요?\nA: 요청 본문에는 Reply의 인스턴스가 포함되어야 합니다. Reply는 답글의 내용을 정의하는 객체입니다.'
 'Q: drives.unhide 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?\nA: drives.unhide 메서드를 사용하기 위해서는 다음 OAuth 범위가 필요합니다.\n\n```\nhttps://www.googleapis.com/auth/drive\n```'
 ""Q: 'fromBodyIfNeeded' 옵션은 어떤 상황에서 사용되며, 그 기능은 무엇인가요?\nA: 'fromBodyIfNeeded'는 업데이트의 다른 콘텐츠에 따라 modifiedDate를 요청 본문에 제공된 값으로 설정합니다.""
 'Q: comments.update 메서드의 요청 본문에 포함해야 하는 내용은 무엇인가요?\nA: 요청 본문에는 Comment의 인스턴스가 포함되어야 합니다. Comment는 주석의 내용을 정의하는 객체입니다.'
 'Q: replies.delete 메서드를 사용하여 답글을 삭제할 때 필요한 정보는 무엇인가요?\nA: replies.delete 메서드를 사용하여 답글을 삭제할 때는 삭제할 답글의 ID가 필요합니다.'
 'Q: Visibility 열거형에서 DEFAULT의 의미는 무엇인가요?\nA: DEFAULT는 새 파일의 공개 상태가 사용자의 기본 공개 상태/공유 정책에 따라 결정된다는 것을 의미합니다.'
 'Q: 댓글을 삭제하는 방법은 무엇인가요?\nA: 댓글을 삭제하려면 `delete` 메서드(메서드: delete)를 사용해야 합니다. 이 메서드는 다음과 같이 호출됩니다:\n\n```\nDELETE /drive/v3/files/{fileId}/comments/{commentId}\n```'
 'Q: apps.list 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?\nA: apps.list 메서드를 사용하기 위해 필요한 OAuth 범위는 다음과 같습니다:\n```\nhttps://www.googleapis.com/auth/drive.apps.readonly\n```'
 'Q: Google Drive API에서 현재 사용자에 대한 정보를 가져오는 방법은 무엇인가요?\nA: 현재 사용자에 대한 정보를 가져오려면 다음의 GET 메서드를 사용합니다: GET /drive/v2/about. 이 메서드는 Drive API 설정과 함께 현재 사용자에 대한 정보를 반환합니다.'
 ""Q: 사용자의 이메일 주소는 어떤 필드에서 확인할 수 있으며, 이 필드의 특성은 무엇인가요?\nA: 사용자의 이메일 주소는 'emailAddress' 필드에서 확인할 수 있습니다. 이 필드는 출력 전용이며, 사용자가 요청자에게 이메일 주소를 표시하지 않은 경우 특정 컨텍스트에 표시되지 않을 수 있습니다.""
 ""Q: 'me' 필드는 어떤 정보를 나타내며, 그 데이터 타입은 무엇인가요?\nA: 'me' 필드는 이 사용자가 요청하는 사용자인지 여부를 나타내며, 데이터 타입은 boolean입니다. 이 필드는 출력 전용입니다.""
 ""Q: User 리소스의 'kind' 필드는 어떤 값을 가지며, 그 의미는 무엇인가요?\nA: 'kind' 필드는 리소스 종류를 식별하며, 고정 문자열 'drive#user' 값을 가집니다. 이 필드는 출력 전용입니다.""
 ""Q: User 리소스에서 'displayName' 필드는 어떤 정보를 담고 있나요?\nA: 'displayName' 필드는 사용자의 표시 가능한 일반 텍스트 이름을 담고 있습니다. 이 필드는 출력 전용입니다.""
 'Q: Drive API에서 사용자 정보를 요청할 때 반환되는 JSON 객체의 구조는 어떻게 되나요?\nA: 사용자 정보를 요청할 때 반환되는 JSON 객체의 구조는 다음과 같습니다:\n```json\n{\n  ""displayName"": string,\n  ""kind"": string,\n  ""me"": boolean,\n  ""permissionId"": string,\n  ""emailAddress"": string,\n  ""photoLink"": string\n}\n```'
 'Q: revisions.update 메서드의 경로 매개변수로 사용되는 fileId와 revisionId는 무엇을 의미하나요?\nA: revisions.update 메서드의 경로 매개변수로 사용되는 `fileId`는 파일의 ID를 의미하며, `revisionId`는 업데이트할 버전의 ID를 의미합니다.'
 'Q: revisions.update 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?\nA: revisions.update 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.'
 'Q: revisions.update 메서드를 호출한 후 성공적인 응답 본문에는 어떤 정보가 포함되나요?\nA: revisions.update 메서드를 호출한 후 성공적인 경우 응답 본문에는 Revision (https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko#Revision)의 인스턴스가 포함됩니다.'
 'Q: revisions.update 메서드의 요청 본문에는 어떤 내용이 포함되어야 하나요?\nA: revisions.update 메서드의 요청 본문에는 Revision (https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko#Revision)의 인스턴스가 포함되어야 합니다.'
 'Q: revisions.update 메서드를 사용하여 파일의 특정 버전을 업데이트하려면 어떤 HTTP 요청을 사용해야 하나요?\nA: revisions.update 메서드를 사용하여 파일의 특정 버전을 업데이트하려면 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nPATCH https://www.googleapis.com/drive/v3/files/{fileId}/revisions/{revisionId}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{revisionId}`는 업데이트할 버전의 ID입니다.'
 'Q: revisions.list 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?\nA: revisions.list 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly'
 'Q: revisions.list 메서드에서 nextPageToken의 역할은 무엇인가요?\nA: nextPageToken은 다음 버전의 페이지 토큰으로, 버전 목록의 끝에 도달한 경우 이 값이 없습니다. 이 값이 채워져 있으면 결과의 추가 페이지를 가져와야 합니다.'
 'Q: revisions.list 메서드의 응답 본문 구조는 어떻게 되나요?\nA: revisions.list 메서드의 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```json\n{\n  ""revisions"": [\n    {\n      object (Revision)\n    }\n  ],\n  ""nextPageToken"": string,\n  ""kind"": string\n}\n```'
 'Q: Google Drive에서 사용자가 인증된 앱을 설치했는지 여부는 어떻게 확인하나요?\nA: 사용자가 인증된 앱이 인증된 사용자에 의해 설치되었는지 여부는 isCurrentAppInstalled 필드를 통해 확인할 수 있습니다.'
 'Q: Google Drive에서 사용자의 언어 코드는 어떻게 확인하나요?\nA: 사용자의 언어 또는 언어 코드는 languageCode 필드를 통해 확인할 수 있습니다.'
 'Q: Google Drive에서 사용자가 공유 드라이브를 만들 수 있는지 여부는 어떻게 확인하나요?\nA: 사용자가 공유 드라이브를 만들 수 있는지 여부는 canCreateDrives 필드를 통해 확인할 수 있습니다.'
 'Q: Google Drive에서 사용자의 총 할당량 바이트 수는 어떻게 확인하나요?\nA: 사용자의 총 할당량 바이트 수는 quotaBytesTotal 필드를 통해 확인할 수 있습니다.'
 'Q: Google Drive에서 사용자의 도메인 공유 정책은 어떤 값이 있을까요?\nA: 현재 사용자의 도메인 공유 정책(domainSharingPolicy)은 다음과 같은 값이 있습니다: allowed, allowedWithWarning, incomingOnly, disallowed.'
 'Q: Google Drive에서 사용자의 이름은 어떻게 확인하나요?\nA: 현재 사용자의 이름은 name 필드를 통해 확인할 수 있습니다. 이 필드는 사용자의 이름을 문자열로 포함합니다. 예를 들어, 다음과 같은 JSON 표현을 통해 확인할 수 있습니다.\n\n```json\n{\n  ""name"": ""홍길동""\n}\n```']","'itemDownloadRestriction'은 파일의 다운로드 제한사항을 나타내는 필드입니다. 이 필드는 소유자 또는 주최자가 직접 적용한 파일의 다운로드 제한을 포함하며, 공유 드라이브 설정이나 DLP 규칙은 고려하지 않습니다. 이를 통해 파일의 다운로드 제한이 소유자 또는 주최자에 의해 직접 설정되었는지를 확인할 수 있습니다.",itemDownloadRestriction 필드는 소유자 또는 주최자가 직접 적용한 파일의 다운로드 제한을 확인할 때 사용합니다.
What does the textFormat field represent in TreemapChartSpec's JSON?,"['스코어카드 차트의 숫자 키/기준 값에 대한 맞춤 형식 지정 옵션입니다. 이 필드는 numberFormatSource [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ScorecardChartSpec.FIELDS.number_format_source]가 CUSTOM [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets?hl=ko#ChartNumberFormatSource.ENUM_VALUES.CUSTOM]로 설정된 경우에만 사용됩니다. 이 필드는 선택사항입니다.\nKeyValueFormat\n키 값의 서식 옵션입니다.\nJSON 표현\n{\n  ""textFormat"": {\n    object (TextFormat [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#TextFormat])\n  },\n  ""position"": {\n    object (TextPosition [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#TextPosition])\n  }\n}\n필드\ntextFormat\nobject (TextFormat [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#TextFormat])\n키 값의 텍스트 서식 지정 옵션입니다. 링크 필드는 지원되지 않습니다.\nposition\nobject (TextPosition [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#TextPosition])\n키 값의 가로 텍스트 위치를 지정합니다. 이 필드는 선택사항입니다. 지정하지 않으면 기본 위치 지정이 사용됩니다.\nBaselineValueFormat\n기준 값의 형식 지정 옵션입니다.\nJSON 표현\n{'
 'TreemapChartSpec\n트리맵 차트 [https://developers.google.com/chart/interactive/docs/gallery/treemap?hl=ko]\nJSON 표현\n{\n  ""labels"": {\n    object (ChartData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartData])\n  },\n  ""parentLabels"": {\n    object (ChartData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartData])\n  },\n  ""sizeData"": {\n    object (ChartData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartData])\n  },\n  ""colorData"": {\n    object (ChartData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartData])\n  },\n  ""textFormat"": {\n    object (TextFormat [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#TextFormat])\n  },\n  ""levels"": integer,\n  ""hintedLevels"": integer,\n  ""minValue"": number,\n  ""maxValue"": number,\n  ""headerColor"": {\n    object (Color [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#Color])\n  },\n  ""headerColorStyle"": {'
 'hideTooltips\nboolean\n도움말을 숨기려면 true로 설정합니다.\nTreemapChartColorScale\n트리맵 차트의 색상 스케일입니다.\nJSON 표현\n{\n  ""minValueColor"": {\n    object (Color [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#Color])\n  },\n  ""minValueColorStyle"": {\n    object (ColorStyle [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#ColorStyle])\n  },\n  ""midValueColor"": {\n    object (Color [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#Color])\n  },\n  ""midValueColorStyle"": {\n    object (ColorStyle [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#ColorStyle])\n  },\n  ""maxValueColor"": {\n    object (Color [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#Color])\n  },\n  ""maxValueColorStyle"": {\n    object (ColorStyle [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#ColorStyle])\n  },\n  ""noDataColor"": {\n    object (Color [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#Color])\n  },\n  ""noDataColorStyle"": {'
 '의견 보내기\n\nLabel\nbookmark_border\n\n이 페이지의 내용\n필드\n\n라벨 및 라벨 필드의 표현입니다.\nJSON 표현\n{\n  ""fields"": {\n    string: {\n      object (Field)\n    },\n    ...\n  },\n  ""id"": string,\n  ""revisionId"": string,\n  ""kind"": string\n}\n필드\nfields\nmap (key: string, value: object (Field))\n라벨의 필드 맵으로, 필드의 ID를 키로 사용합니다.\n""key"": value 쌍 목록을 포함하는 객체입니다. 예: { ""name"": ""wrench"", ""mass"": ""1.3kg"", ""count"": ""3"" }\nid\nstring\n라벨의 ID입니다.\nrevisionId\nstring\n라벨의 버전 ID입니다.\nkind\nstring\n항상 drive#label입니다.\n필드\n필드의 표현으로, 유형이 지정된 키-값 쌍입니다.\nJSON 표현\n{\n  ""dateString"": [\n    string\n  ],\n  ""integer"": [\n    string\n  ],\n  ""selection"": [\n    string\n  ],\n  ""text"": [\n    string\n  ],\n  ""user"": [\n    {\n      object (User)\n    }\n  ],\n  ""kind"": string,\n  ""id"": string,\n  ""valueType"": string\n}\n필드\ndateString[]\nstring\nvalueType이 dateString인 경우에만 표시됩니다. RFC 3339 형식의 날짜: YYYY-MM-DD\ninteger[]\nstring (int64 format)\nvalueType이 integer인 경우에만 표시됩니다.\nselection[]\nstring\nvalueType이 selection인 경우에만 값이 있습니다.\ntext[]\nstring\nvalueType이 text인 경우에만 표시됩니다.\nuser[]\nobject (User)\nvalueType이 user인 경우에만 표시됩니다.\nkind\nstring\n항상 drive#labelField입니다.\nid\nstring\n이 라벨 필드의 식별자입니다.\nvalueType\nstring\n필드 유형입니다. 향후 새로운 값이 지원될 수 있지만 현재는 다음 값만 허용됩니다.\ndateString\ninteger\nselection\ntext\nuser\n\n의견 보내기'
 '출력 전용입니다. 설정된 경우 데이터 소스 시트의 열입니다.\nConditionalFormatRule\n조건부 서식을 설명하는 규칙입니다.\nJSON 표현\n{\n  ""ranges"": [\n    {\n      object (GridRange [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#GridRange])\n    }\n  ],'
 '},\n  ""negativeColorStyle"": {\n    object (ColorStyle [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#ColorStyle])\n  }\n}\n필드\ncomparisonType\nenum (ComparisonType [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ComparisonType])\n키 값과 기준 값의 비교 유형입니다.\ntextFormat\nobject (TextFormat [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#TextFormat])\n기준 값의 텍스트 서식 지정 옵션입니다. 링크 필드는 지원되지 않습니다.\nposition\nobject (TextPosition [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#TextPosition])\n기준값의 가로 텍스트 위치를 지정합니다. 이 필드는 선택사항입니다. 지정하지 않으면 기본 위치 지정이 사용됩니다.\ndescription\nstring\n기준 값 뒤에 추가되는 설명입니다. 이 필드는 선택사항입니다.\npositiveColor\n(deprecated)\nobject (Color [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#Color])\n이 항목은 지원 중단되었습니다.\n기준 값이 키 값의 양수 변화를 나타내는 경우 사용되는 색상입니다. 이 필드는 선택사항입니다. 지원 중단됨: positiveColorStyle [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#BaselineValueFormat.FIELDS.positive_color_style]를 사용하세요.\npositiveColorStyle'
 'sizeData\nobject (ChartData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartData])\n각 트리맵 데이터 셀의 크기를 결정하는 데이터입니다. 이 데이터는 숫자여야 합니다. 숫자가 아니거나 누락된 데이터에 해당하는 셀은 렌더링되지 않습니다. colorData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#TreemapChartSpec.FIELDS.color_data]이 지정되지 않으면 이 데이터는 데이터 셀 배경 색상을 결정하는 데도 사용됩니다.\ncolorData\nobject (ChartData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartData])\n각 트리맵 데이터 셀의 배경 색상을 결정하는 데이터입니다. 이 필드는 선택사항입니다. 지정하지 않으면 sizeData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#TreemapChartSpec.FIELDS.size_data]이 배경 색상을 결정하는 데 사용됩니다. 지정된 경우 데이터는 숫자여야 합니다. colorScale [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#TreemapChartSpec.FIELDS.color_scale]는 이 데이터의 값이 데이터 셀 배경 색상에 매핑되는 방식을 결정합니다.\ntextFormat\nobject (TextFormat [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#TextFormat])\n차트의 모든 라벨에 사용할 텍스트 형식입니다. 링크 필드는 지원되지 않습니다.\nlevels\ninteger'
 '}\n필드\ndataRange\nobject (GridRange [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#GridRange])\n슬라이서의 데이터 범위입니다.\nfilterCriteria\nobject (FilterCriteria [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#FilterCriteria])\n슬라이서의 필터링 기준입니다.\ncolumnIndex\ninteger\n필터가 적용되는 데이터 테이블의 0부터 시작하는 열 색인입니다.\napplyToPivotTables\nboolean\n필터를 피벗 테이블에 적용해야 하는 경우 true입니다. 설정하지 않으면 기본값은 True입니다.\ntitle\nstring\n슬라이서의 제목입니다.\ntextFormat\nobject (TextFormat [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#TextFormat])\n슬라이서에 표시되는 제목의 텍스트 형식입니다. 링크 필드는 지원되지 않습니다.\nbackgroundColor\n(deprecated)\nobject (Color [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#Color])\n이 항목은 지원 중단되었습니다.\n슬라이서의 배경 색상입니다. 지원 중단됨: backgroundColorStyle [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/sheets?hl=ko#SlicerSpec.FIELDS.background_color_style]를 사용하세요.\nbackgroundColorStyle\nobject (ColorStyle [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#ColorStyle])'
 'DataLabel\n데이터 라벨 한 세트의 설정입니다. 데이터 라벨은 선 차트의 점과 같은 데이터 세트 옆에 표시되는 주석으로, 그래프의 해당 지점 뒤에 있는 값의 텍스트 표현과 같이 데이터가 나타내는 항목에 관한 추가 정보를 제공합니다.\nJSON 표현\n{\n  ""type"": enum (DataLabelType [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#DataLabelType]),\n  ""textFormat"": {\n    object (TextFormat [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#TextFormat])\n  },\n  ""placement"": enum (DataLabelPlacement [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#DataLabelPlacement]),\n  ""customLabelData"": {\n    object (ChartData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartData])\n  }\n}\n필드\ntype\nenum (DataLabelType [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#DataLabelType])\n데이터 라벨의 유형입니다.\ntextFormat\nobject (TextFormat [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#TextFormat])\n데이터 라벨에 사용되는 텍스트 형식입니다. 링크 필드는 지원되지 않습니다.\nplacement'
 'DocumentTransform\n\nA transformation of a document.\n\n| JSON representation |\n| --- |\n| {   ""document"": string,   ""fieldTransforms"": [     {       object (FieldTransform)     }   ] } |\n\n| Fields |\n| --- |\n| document | string The name of the document to transform. |\n| fieldTransforms[] | object (FieldTransform) The list of transformations to apply to the fields of the document, in order. This must not be empty. |\n\nFieldTransform\n\nA transformation of a field of the document.\n\n| JSON representation |\n| --- |\n| {   ""fieldPath"": string,    // Union field transform_type can be only one of the following:   ""setToServerValue"": enum (ServerValue),   ""increment"": {     object (Value)   },   ""maximum"": {     object (Value)   },   ""minimum"": {     object (Value)   },   ""appendMissingElements"": {     object (ArrayValue)   },   ""removeAllFromArray"": {     object (ArrayValue)   }   // End of list of possible types for union field transform_type. } |'
 '// Union field identifier can be only one of the following:\n  ""name"": string\n  // End of list of possible types for union field identifier.'
 '// Union field rule can be only one of the following:\n  ""dateTimeRule"": {\n    object (ChartDateTimeRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartDateTimeRule])\n  },\n  ""histogramRule"": {\n    object (ChartHistogramRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartHistogramRule])\n  }\n  // End of list of possible types for union field rule.\n}\n필드\n공용체 필드 rule입니다. ChartData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartData]에 적용할 규칙입니다. rule는 다음 중 하나여야 합니다.\ndateTimeRule\nobject (ChartDateTimeRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartDateTimeRule])\nChartDateTimeRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartDateTimeRule]입니다.\nhistogramRule\nobject (ChartHistogramRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/charts?hl=ko#ChartHistogramRule])'
 '// Union field value can be only one of the following:\n  ""sourceColumnOffset"": integer,\n  ""formula"": string,\n  ""dataSourceColumnReference"": {\n    object (DataSourceColumnReference [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#DataSourceColumnReference])\n  }\n  // End of list of possible types for union field value.\n}\n필드\nsummarizeFunction\nenum (PivotValueSummarizeFunction [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#PivotValueSummarizeFunction])\n값을 요약하는 함수입니다. formula [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#PivotValue.FIELDS.formula]가 설정된 경우 지원되는 유일한 값은 SUM [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#PivotValueSummarizeFunction] 및 CUSTOM [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#PivotValueSummarizeFunction]입니다. sourceColumnOffset [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#PivotValue.FIELDS.source_column_offset]이 설정된 경우 CUSTOM는 지원되지 않습니다.'
 '// Union field rule can be only one of the following:\n  ""manualRule"": {\n    object (ManualRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#ManualRule])\n  },\n  ""histogramRule"": {\n    object (HistogramRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#HistogramRule])\n  },\n  ""dateTimeRule"": {\n    object (DateTimeRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#DateTimeRule])\n  }\n  // End of list of possible types for union field rule.\n}\n필드\n공용체 필드 rule입니다. PivotGroup [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#PivotGroup]에 적용할 규칙입니다. rule는 다음 중 하나여야 합니다.\nmanualRule\nobject (ManualRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#ManualRule])\nManualRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/pivot-tables?hl=ko#ManualRule]입니다.\nhistogramRule'
 '// Union field schedule_config can be only one of the following:\n  ""dailySchedule"": {\n    object (DataSourceRefreshDailySchedule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets?hl=ko#DataSourceRefreshDailySchedule])\n  },\n  ""weeklySchedule"": {\n    object (DataSourceRefreshWeeklySchedule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets?hl=ko#DataSourceRefreshWeeklySchedule])\n  },\n  ""monthlySchedule"": {\n    object (DataSourceRefreshMonthlySchedule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets?hl=ko#DataSourceRefreshMonthlySchedule])\n  }\n  // End of list of possible types for union field schedule_config.\n}\n필드\nenabled\nboolean\n새로고침 일정이 사용 설정되어 있으면 true이고, 그렇지 않으면 false입니다.\nrefreshScope\nenum (DataSourceRefreshScope [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets?hl=ko#DataSourceRefreshScope])\n새로고침 범위입니다. ALL_DATA_SOURCES [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets?hl=ko#DataSourceRefreshScope]이어야 합니다.\nnextRun'
 'Q: TreemapChartSpec의 JSON 표현에서 textFormat 필드는 어떤 정보를 포함하나요?\nA: textFormat 필드는 차트의 모든 라벨에 사용할 텍스트 형식입니다. 링크 필드는 지원되지 않습니다.'
 'Q: SlicerSpec 객체의 textFormat 필드는 어떤 역할을 하나요?\nA: textFormat 필드는 슬라이서에 표시되는 제목의 텍스트 형식을 정의하는 객체입니다. 링크 필드는 지원되지 않습니다.'
 'Q: ChartSpec의 JSON 표현에서 titleTextFormat 필드는 어떤 역할을 하나요?\nA: titleTextFormat 필드는 제목 텍스트 형식을 정의합니다. 취소선, 밑줄, 링크는 지원되지 않습니다.'
 'Q: TreemapChartSpec의 JSON 표현에서 levels 필드는 어떤 역할을 하나요?\nA: levels 필드는 트리맵 차트에 표시할 데이터 수준의 수를 정의합니다. 이러한 수준은 대화형이며 라벨과 함께 표시됩니다. 지정하지 않을 경우 기본값은 2입니다.'
 'Q: TreemapChartSpec의 JSON 표현에서 labels 필드는 어떤 정보를 포함하나요?\nA: labels 필드는 트리맵 셀 라벨이 포함된 데이터입니다. 이 데이터는 ChartData 객체로 표현됩니다.'
 'Q: KeyValueFormat의 textFormat 필드는 어떤 정보를 포함하나요?\nA: textFormat 필드는 키 값의 텍스트 서식 지정 옵션입니다. 링크 필드는 지원되지 않습니다.'
 'Q: ProtectedRange 객체의 protectedRangeId 필드는 어떤 정보를 나타내나요?\nA: protectedRangeId 필드는 보호된 범위의 ID입니다. 이 필드는 읽기 전용입니다.'
 'Q: DataSourceSheetProperties의 dataSourceId는 무엇을 나타내나요?\nA: dataSourceId는 시트가 연결된 DataSource의 ID를 나타냅니다.'
 'Q: DeveloperMetadataLocationType 열거형에서 ROW는 무엇을 나타내나요?\nA: ROW는 전체 행 측정기준에 연결된 개발자 메타데이터를 나타냅니다.'
 'Q: totalUpdatedColumns 필드는 무엇을 나타내나요?\nA: totalUpdatedColumns 필드는 열의 셀이 하나 이상 업데이트된 총 열 개수를 나타냅니다.'
 'Q: EmbeddedChart의 JSON 표현에서 position 필드는 무엇을 나타내나요?\nA: position 필드는 차트의 위치를 나타내며, EmbeddedObjectPosition 객체를 포함합니다.'
 ""Q: 피벗 테이블의 'valueBucket' 필드는 무엇을 나타내나요?\nA: valueBucket 필드는 정렬할 반대 피벗 그룹의 버킷입니다. 지정하지 않으면 이 그룹의 값을 기준으로 알파벳순으로 정렬됩니다.""
 'Q: BaselineValueFormat의 textFormat 필드는 어떤 역할을 하나요?\nA: textFormat 필드는 기준 값의 텍스트 서식 지정 옵션을 정의합니다. 이 필드는 object (TextFormat) 형식으로, 링크 필드는 지원되지 않습니다.'
 ""Q: PivotGroupSortValueBucket의 'buckets' 필드는 무엇을 나타내나요?\nA: 'buckets' 필드는 정렬할 값을 선택할 버킷을 결정합니다. 예를 들어 행 그룹이 1개이고 열 그룹이 2개인 피벗 테이블에서 행 그룹은 최대 2개의 값을 표시할 수 있습니다.""
 'Q: TreemapChartSpec의 hideTooltips 필드는 어떤 역할을 하나요?\nA: hideTooltips 필드는 도움말을 숨기려면 true로 설정합니다.'
 'Q: FilterView 객체의 filterViewId 필드는 어떤 정보를 나타내나요?\nA: filterViewId 필드는 필터 뷰의 ID입니다.'
 'Q: UpdateValuesResponse에서 spreadsheetId 필드는 어떤 정보를 나타내나요?\nA: spreadsheetId 필드(string)는 업데이트가 적용된 스프레드시트의 ID를 나타냅니다.'
 'Q: DataExecutionErrorCode 열거형에서 TIMED_OUT 오류는 어떤 상황을 나타내나요?\nA: TIMED_OUT 오류는 데이터 실행 시간이 초과되었음을 나타냅니다.'
 'Q: spreadsheets.values.batchUpdate 메서드의 응답 본문에서 spreadsheetId 필드는 어떤 정보를 나타내나요?\nA: spreadsheetId 필드는 업데이트가 적용된 스프레드시트의 ID를 나타냅니다.'
 'Q: TreemapChartSpec의 JSON 표현에서 hideTooltips 필드는 어떤 역할을 하나요?\nA: hideTooltips 필드는 도움말을 숨기려면 true로 설정합니다. 이 필드는 boolean 타입입니다.'
 'Q: FilterView 객체의 JSON 표현에서 filterViewId 필드는 어떤 정보를 나타내나요?\nA: FilterView 객체의 filterViewId 필드는 필터 뷰의 ID를 나타냅니다.'
 'Q: ChartSpec의 JSON 표현에서 subtitleTextFormat 필드는 어떤 역할을 하나요?\nA: subtitleTextFormat 필드는 자막 텍스트 형식을 정의하며, 취소선, 밑줄, 링크는 지원되지 않습니다.'
 'Q: RefreshDataSourceRequest를 사용하여 데이터 소스를 새로고침할 때, 어떤 JSON 표현이 필요한가요?\nA: {\n  ""force"": boolean,\n\n  // Union field target can be only one of the following:\n  ""references"": {\n    object (DataSourceObjectReferences [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/request?hl=ko#DataSourceObjectReferences])\n  },\n  ""dataSourceId"": string,\n  ""isAll"": boolean\n  // End of list of possible types for union field target.\n}'
 'Q: CancelDataSourceRefreshRequest를 사용하여 데이터 소스 객체의 새로고침을 취소할 때, 어떤 JSON 표현이 필요한가요?\nA: {\n  // Union field target can be only one of the following:\n  ""references"": {\n    object (DataSourceObjectReferences [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/request?hl=ko#DataSourceObjectReferences])\n  },\n  ""dataSourceId"": string,\n  ""isAll"": boolean\n  // End of list of possible types for union field target.\n}'
 'Q: 데이터 소스 쿼리의 매개변수(DataSourceParameter)를 어떻게 정의하나요?\nA: 데이터 소스 쿼리의 매개변수는 다음과 같이 정의할 수 있습니다. JSON 표현은 다음과 같습니다:\n```json\n{\n  // Union field identifier can be only one of the following:\n  ""name"": string\n  // End of list of possible types for union field identifier.\n\n  // Union field value can be only one of the following:\n  ""namedRangeId"": string,\n  ""range"": {\n    object (GridRange [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#GridRange])\n  }\n  // End of list of possible types for union field value.\n}\n```'
 'Q: FilterSpec의 JSON 표현에서 어떤 필드가 포함되나요?\nA: {\n  ""filterCriteria"": {\n    object (FilterCriteria [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#FilterCriteria])\n  },\n\n  // Union field reference can be only one of the following:\n  ""columnIndex"": integer,\n  ""dataSourceColumnReference"": {\n    object (DataSourceColumnReference [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#DataSourceColumnReference])\n  }\n  // End of list of possible types for union field reference.\n}'
 'Q: ConditionValue의 JSON 표현에서 어떤 필드가 포함되나요?\nA: ConditionValue는 조건의 값을 나타내며, JSON 표현은 다음과 같습니다. \n```json\n{\n  // Union field value can be only one of the following:\n  ""relativeDate"": enum (RelativeDate),\n  ""userEnteredValue"": string\n  // End of list of possible types for union field value.\n}\n```'
 'Q: UpdateConditionalFormatRuleRequest를 사용하여 조건부 서식 규칙을 업데이트할 때, 어떤 JSON 표현이 필요한가요?\nA: {\n  ""index"": integer,\n  ""sheetId"": integer,\n\n  // Union field instruction can be only one of the following:\n  ""rule"": {\n    object (ConditionalFormatRule [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/sheets?hl=ko#ConditionalFormatRule])\n  },\n  ""newIndex"": integer\n  // End of list of possible types for union field instruction.\n}'
 'Q: PasteDataRequest를 사용하여 스프레드시트에 데이터를 삽입할 때, 어떤 JSON 표현이 필요한가요?\nA: {\n  ""coordinate"": {\n    object (GridCoordinate [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#GridCoordinate])\n  },\n  ""data"": string,\n  ""type"": enum (PasteType [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/request?hl=ko#PasteType]),\n\n  // Union field kind can be only one of the following:\n  ""delimiter"": string,\n  ""html"": boolean\n  // End of list of possible types for union field kind.\n}'
 'Q: FilterSpec의 JSON 표현에서 어떤 필드가 포함되나요?\nA: FilterSpec의 JSON 표현은 다음과 같습니다: \n```json\n{\n  ""filterCriteria"": {\n    object (FilterCriteria [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#FilterCriteria])\n  },\n\n  // Union field reference can be only one of the following:\n  ""columnIndex"": integer,\n  ""dataSourceColumnReference"": {\n    object (DataSourceColumnReference [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#DataSourceColumnReference])\n  }\n  // End of list of possible types for union field reference.\n}\n```'
 'Q: ConditionalFormatRule 객체의 JSON 표현은 어떻게 구성되나요?\nA: ConditionalFormatRule 객체의 JSON 표현은 다음과 같이 구성됩니다.\n```json\n{\n  ""ranges"": [\n    {\n      object (GridRange)\n    }\n  ],\n\n  // Union field rule can be only one of the following:\n  ""booleanRule"": {\n    object (BooleanRule)\n  },\n  ""gradientRule"": {\n    object (GradientRule)\n  }\n  // End of list of possible types for union field rule.\n}\n```'
 'Q: ExtendedValue의 JSON 표현에서 어떤 값 유형을 사용할 수 있나요?\nA: ExtendedValue의 JSON 표현에서 사용할 수 있는 값 유형은 다음과 같습니다: \n{\n  // Union field value can be only one of the following:\n  ""numberValue"": number,\n  ""stringValue"": string,\n  ""boolValue"": boolean,\n  ""formulaValue"": string,\n  ""errorValue"": {\n    object (ErrorValue [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/other?hl=ko#ErrorValue])\n  }\n  // End of list of possible types for union field value.\n}'
 'Q: AddNamedRangeResponse의 구조는 어떻게 되나요?\nA: AddNamedRangeResponse는 다음과 같은 JSON 표현을 가집니다:\n\n```json\n{\n  // Union field kind can be only one of the following:\n  ""addNamedRange"": {\n    object (AddNamedRangeResponse [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/response?hl=ko#AddNamedRangeResponse])\n  },\n  // ... 다른 필드들 ...\n}\n```'
 'Q: BigQuery 데이터 소스의 사양(BigQueryDataSourceSpec)을 어떻게 정의하나요?\nA: BigQuery 데이터 소스의 사양은 다음과 같이 정의할 수 있습니다. JSON 표현은 다음과 같습니다:\n```json\n{\n  ""projectId"": string,\n\n  // Union field spec can be only one of the following:\n  ""querySpec"": {\n    object (BigQueryQuerySpec [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets?hl=ko#BigQueryQuerySpec])\n  },\n  ""tableSpec"": {\n    object (BigQueryTableSpec [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets?hl=ko#BigQueryTableSpec])\n  }\n  // End of list of possible types for union field spec.\n}\n```'
 'Q: FindReplaceRequest를 사용하여 특정 셀에서 데이터를 찾고 바꾸려면 어떤 필드가 필요한가요?\nA: FindReplaceRequest를 사용하여 데이터를 찾고 바꾸기 위해서는 다음과 같은 필드가 필요합니다:\n```json\n{\n  ""find"": string,\n  ""replacement"": string,\n  ""matchCase"": boolean,\n  ""matchEntireCell"": boolean,\n  ""searchByRegex"": boolean,\n  ""includeFormulas"": boolean,\n\n  // Union field scope can be only one of the following:\n  ""range"": {\n    object (GridRange)\n  },\n  ""sheetId"": integer,\n  ""allSheets"": boolean\n  // End of list of possible types for union field scope.\n}\n```']","The textFormat field in TreemapChartSpec's JSON represents the text format used for all labels in the chart. It specifies the text formatting options, and link fields are not supported.",The textFormat field specifies the text format to be used for all labels in the chart. Link fields are not supported.
fileId는 무엇을 의미하나요?,"['리소스: 변경\n파일 또는 공유 드라이브의 변경사항을 나타냅니다.\nJSON 표현\n{\n  ""id"": string,\n  ""deleted"": boolean,\n  ""file"": {\n    object (File)\n  },\n  ""fileId"": string,\n  ""modificationDate"": string,\n  ""kind"": string,\n  ""type"": string,\n  ""teamDriveId"": string,\n  ""teamDrive"": {\n    object (TeamDrive)\n  },\n  ""changeType"": string,\n  ""selfLink"": string,\n  ""driveId"": string,\n  ""drive"": {\n    object (Drive)\n  }\n}\n필드\nid\nstring (int64 format)\n변경의 ID입니다.\ndeleted\nboolean\n삭제 또는 액세스 권한 상실 등으로 인해 파일 또는 공유 드라이브가 이 변경사항 목록에서 삭제되었는지 여부입니다.\nfile\nobject (File)\n업데이트된 파일 상태입니다. 유형이 파일이고 이 변경사항 목록에서 파일이 삭제되지 않은 경우 표시됩니다.\nfileId\nstring\n이 변경사항과 연결된 파일의 ID입니다.\nmodificationDate\nstring\n이 수정사항이 적용된 시간입니다.\nkind\nstring\n항상 drive#change입니다.\ntype\n(deprecated)\nstring\n이 항목은 지원 중단되었습니다.\n지원 중단됨: 대신 changeType를 사용하세요.\nteamDriveId\n(deprecated)\nstring\n이 항목은 지원 중단되었습니다.\n지원 중단됨: 대신 driveId를 사용하세요.\nteamDrive\n(deprecated)\nobject (TeamDrive)\n이 항목은 지원 중단되었습니다.\n지원 중단됨: 대신 drive를 사용하세요.\nchangeType\nstring\n변경 유형입니다. 가능한 값은 file 및 drive입니다.\nselfLink\nstring\n이 변경사항으로 연결되는 링크입니다.\ndriveId\nstring\n이 변경사항과 연결된 공유 드라이브의 ID입니다.\ndrive\nobject (Drive)\n업데이트된 공유 드라이브 상태입니다. changeType이 drive인 경우, 사용자가 여전히 공유 드라이브의 멤버이고 공유 드라이브가 삭제되지 않은 경우 표시됩니다.\n메서드\nget'
 '경로 매개변수\n매개변수\nspreadsheetId\nstring\n메타데이터를 가져올 스프레드시트의 ID입니다.\n요청 본문\n요청 본문에는 다음과 같은 구조의 데이터가 포함됩니다.\nJSON 표현\n{\n  ""dataFilters"": [\n    {\n      object (DataFilter [https://developers.google.com/workspace/sheets/api/reference/rest/v4/DataFilter?hl=ko])\n    }\n  ]\n}\n필드\ndataFilters[]\nobject (DataFilter [https://developers.google.com/workspace/sheets/api/reference/rest/v4/DataFilter?hl=ko])\n반환할 DeveloperMetadata 항목을 결정하는 데 사용되는 기준을 설명하는 데이터 필터입니다. 지정된 필터와 일치하는 DeveloperMetadata가 응답에 포함됩니다.\n응답 본문\n개발자 메타데이터 검색 요청에 대한 답장입니다.\n성공한 경우 응답 본문은 다음과 같은 구조의 데이터를 포함합니다.\nJSON 표현\n{\n  ""matchedDeveloperMetadata"": [\n    {\n      object (MatchedDeveloperMetadata [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets.developerMetadata/search?hl=ko#MatchedDeveloperMetadata])\n    }\n  ]\n}\n필드\nmatchedDeveloperMetadata[]\nobject (MatchedDeveloperMetadata [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets.developerMetadata/search?hl=ko#MatchedDeveloperMetadata])\n검색 요청의 기준과 일치하는 메타데이터입니다.\n승인 범위\n다음 OAuth 범위 중 하나가 필요합니다.\nhttps://www.googleapis.com/auth/drive\nhttps://www.googleapis.com/auth/drive.file\nhttps://www.googleapis.com/auth/spreadsheets'
 'shortcutDetails.targetId\nstring\n이 바로가기가 가리키는 파일의 ID입니다. files.create 요청에서만 설정할 수 있습니다.\nshortcutDetails.targetMimeType\nstring\n출력 전용입니다. 이 바로가기가 가리키는 파일의 MIME 유형입니다. 이 필드의 값은 바로가기가 생성될 때 캡처된 타겟의 MIME 유형 스냅샷입니다.\nshortcutDetails.targetResourceKey\nstring\n출력 전용입니다. 타겟 파일의 ResourceKey입니다.\nresourceKey\nstring\n출력 전용입니다. 공유 링크를 통해 항목에 액세스하는 데 필요한 키입니다.\nlinkShareMetadata\nobject\n출력 전용입니다. LinkShare 관련 세부정보입니다. 클라이언트가 이 항목을 참조하는 데 사용하는 링크 URL에 관한 세부정보가 포함되어 있습니다.\nlinkShareMetadata.securityUpdateEligible\nboolean\n출력 전용입니다. 파일에 보안 업데이트가 적용될 수 있는지 여부입니다.\nlinkShareMetadata.securityUpdateEnabled\nboolean\n출력 전용입니다. 이 파일에 보안 업데이트가 사용 설정되어 있는지 여부입니다.\nlabelInfo\nobject\n출력 전용입니다. 파일의 라벨 개요입니다.\nlabelInfo.labels[]\nobject (Label [https://developers.google.com/workspace/drive/api/reference/rest/v3/Label?hl=ko])\n출력 전용입니다. includeLabels 매개변수의 라벨 ID에 의해 요청된 파일의 라벨 집합입니다. 기본적으로 라벨이 반환되지 않습니다.\nsha1Checksum\nstring\n출력 전용입니다. 이 파일과 연결된 SHA1 체크섬입니다(사용 가능한 경우). 이 필드는 Google Drive에 콘텐츠가 저장된 파일에만 채워지며, Docs 편집기 또는 바로가기 파일에는 채워지지 않습니다.\nsha256Checksum\nstring\n출력 전용입니다. 이 파일과 연결된 SHA256 체크섬입니다(사용 가능한 경우). 이 필드는 Google Drive에 콘텐츠가 저장된 파일에만 채워지며, Docs 편집기 또는 바로가기 파일에는 채워지지 않습니다.\ninheritedPermissionsDisabled\nboolean'
 '경로 매개변수\n매개변수\nspreadsheetId\nstring\n업데이트할 스프레드시트의 ID입니다.\n요청 본문\n요청 본문에는 다음과 같은 구조의 데이터가 포함됩니다.\nJSON 표현\n{\n  ""valueInputOption"": enum (ValueInputOption [https://developers.google.com/workspace/sheets/api/reference/rest/v4/ValueInputOption?hl=ko]),\n  ""data"": [\n    {\n      object (DataFilterValueRange [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets.values/batchUpdateByDataFilter?hl=ko#DataFilterValueRange])\n    }\n  ],\n  ""includeValuesInResponse"": boolean,\n  ""responseValueRenderOption"": enum (ValueRenderOption [https://developers.google.com/workspace/sheets/api/reference/rest/v4/ValueRenderOption?hl=ko]),\n  ""responseDateTimeRenderOption"": enum (DateTimeRenderOption [https://developers.google.com/workspace/sheets/api/reference/rest/v4/DateTimeRenderOption?hl=ko])\n}\n필드\nvalueInputOption\nenum (ValueInputOption [https://developers.google.com/workspace/sheets/api/reference/rest/v4/ValueInputOption?hl=ko])\n입력 데이터가 해석되어야 하는 방식입니다.\ndata[]\nobject (DataFilterValueRange [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets.values/batchUpdateByDataFilter?hl=ko#DataFilterValueRange])'
 '문서 ID 매핑에 대한 간단한 설명\n\n더 많은 유형을 매핑하기 전에 잠시 문서 ID를 매핑하는 방법을 알아보겠습니다.\n\n이전 예시의 @DocumentID 속성 래퍼를 사용하여 Cloud Firestore 문서의 문서 ID를 Swift 유형의 id 속성에 매핑했습니다. 이것이 중요한 이유는 다음과 같습니다.\n\n이렇게 하면 사용자가 로컬에서 변경한 경우 어떤 문서를 업데이트할지 알 수 있습니다.\nSwiftUI의 List는 요소가 삽입될 때 이동하지 못하도록 요소가 Identifiable이어야 합니다.\n\n@DocumentID로 표시된 속성은 문서를 다시 작성할 때 Cloud Firestore의 인코더에서 인코딩되지 않는다는 점에 주목해야 합니다. 그 이유는 문서 ID가 문서 자체의 속성이 아니기 때문에 문서에 쓰면 안 됩니다.\n\n중첩된 유형(예: 이 가이드의 앞선 예시에 있는 Book의 태그 배열)을 사용하는 경우 @DocumentID 속성을 추가하지 않아도 됩니다. 중첩 속성은 Cloud Firestore 문서의 일부이며 별도의 문서를 구성하지 않습니다. 따라서 문서 ID가 필요하지 않습니다.\n\n날짜 및 시간\n\nCloud Firestore에는 날짜 및 시간 처리를 위한 기본 제공 데이터 유형이 있으며 Cloud Firestore의 Codable 지원을 통해 이를 사용하는 방법은 간단합니다.\n\n1843년에 발명된 모든 프로그래밍 언어의 어머니인 에이다를 보여주는 문서를 살펴보겠습니다.\n\n이 문서를 매핑하는 Swift 유형은 다음과 같습니다.\nstruct ProgrammingLanguage: Codable {\n@DocumentID var id: String?\nvar name: String\nvar year: Date\n}\n\n날짜와 시간에 관한 이 섹션은 @ServerTimestamp에 대한 이야기를 빼놓고는 다룰 수 없습니다. 이 속성 래퍼는 앱에서 타임스탬프를 처리하는 데 중요한 역할을 합니다.\n\n모든 분산 시스템에서 개별 시스템의 시계가 항상 완전히 동기화되지 않을 수 있습니다. 이는 별 문제가 아니라고 생각할 수 있지만 증권 거래 시스템에서 시계가 조금이라도 동기화되지 않는 경우에 미치게 될 영향을 상상해 보세요. 밀리초 단위의 편차만으로도 거래 시 수백만 달러의 차이가 발생할 수 있습니다.'
 'Source URL: https://developers.google.com/workspace/drive/api/reference/rest/v3/User?hl=ko\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGoogle Drive [https://developers.google.com/workspace/drive?hl=ko]\n참조 [https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko]\n의견 보내기\nUser\nbookmark_border\nDrive 사용자에 관한 정보입니다.\nJSON 표현\n{\n  ""displayName"": string,\n  ""kind"": string,\n  ""me"": boolean,\n  ""permissionId"": string,\n  ""emailAddress"": string,\n  ""photoLink"": string\n}\n필드\ndisplayName\nstring\n출력 전용입니다. 이 사용자의 표시 가능한 일반 텍스트 이름입니다.\nkind\nstring\n출력 전용입니다. 리소스 종류를 식별합니다. 값: 고정 문자열 drive#user.\nme\nboolean\n출력 전용입니다. 이 사용자가 요청하는 사용자인지 여부입니다.\npermissionId\nstring\n출력 전용입니다. 권한 리소스에 표시되는 사용자의 ID입니다.\nemailAddress\nstring\n출력 전용입니다. 사용자의 이메일 주소입니다. 사용자가 요청자에게 이메일 주소를 표시하지 않은 경우 특정 컨텍스트에 표시되지 않을 수 있습니다.\nphotoLink\nstring\n출력 전용입니다. 사용자의 프로필 사진 링크입니다(사용 가능한 경우).\n의견 보내기'
 'list [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/list?hl=ko] GET /drive/v2/files/{fileId}/revisions\n파일의 버전을 나열합니다.\npatch [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/patch?hl=ko] PATCH /drive/v2/files/{fileId}/revisions/{revisionId}\n버전을 업데이트합니다.\nupdate [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/update?hl=ko] PUT /drive/v2/files/{fileId}/revisions/{revisionId}\n버전을 업데이트합니다.\n도움이 되었나요?\n의견 보내기'
 '지정된 댓글에 대한 새 답글을 만듭니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/list?hl=ko] GET /drive/v2/files/{fileId}/comments/{commentId}/replies\n댓글에 대한 모든 답글을 나열합니다.\npatch [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/patch?hl=ko] PATCH /drive/v2/files/{fileId}/comments/{commentId}/replies/{replyId}\n기존 답장을 업데이트합니다.\nupdate [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/update?hl=ko] PUT /drive/v2/files/{fileId}/comments/{commentId}/replies/{replyId}\n기존 답장을 업데이트합니다.\nREST 리소스: v2.revisions [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions?hl=ko]\n메서드\ndelete [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/delete?hl=ko] DELETE /drive/v2/files/{fileId}/revisions/{revisionId}\n파일 버전을 영구적으로 삭제합니다.\nget [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/get?hl=ko] GET /drive/v2/files/{fileId}/revisions/{revisionId}\n특정 버전을 가져옵니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v2/revisions/list?hl=ko] GET /drive/v2/files/{fileId}/revisions\n파일의 버전을 나열합니다.'
 '파일에 속성을 추가하거나 이미 있는 경우 업데이트합니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/list?hl=ko] GET /drive/v2/files/{fileId}/properties\n파일의 속성을 나열합니다.\npatch [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/patch?hl=ko] PATCH /drive/v2/files/{fileId}/properties/{propertyKey}\n속성을 업데이트합니다.\nupdate [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/update?hl=ko] PUT /drive/v2/files/{fileId}/properties/{propertyKey}\n속성을 업데이트합니다.\nREST 리소스: v2.replies [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies?hl=ko]\n메서드\ndelete [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/delete?hl=ko] DELETE /drive/v2/files/{fileId}/comments/{commentId}/replies/{replyId}\n답글을 삭제합니다.\nget [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/get?hl=ko] GET /drive/v2/files/{fileId}/comments/{commentId}/replies/{replyId}\n답장을 가져옵니다.\ninsert [https://developers.google.com/workspace/drive/api/reference/rest/v2/replies/insert?hl=ko] POST /drive/v2/files/{fileId}/comments/{commentId}/replies\n지정된 댓글에 대한 새 답글을 만듭니다.'
 '파일 또는 공유 드라이브의 권한을 삽입합니다.\nlist [https://developers.google.com/workspace/drive/api/reference/rest/v2/permissions/list?hl=ko] GET /drive/v2/files/{fileId}/permissions\n파일 또는 공유 드라이브의 권한을 표시합니다.\npatch [https://developers.google.com/workspace/drive/api/reference/rest/v2/permissions/patch?hl=ko] PATCH /drive/v2/files/{fileId}/permissions/{permissionId}\n패치 시맨틱스를 사용하여 권한을 업데이트합니다.\nupdate [https://developers.google.com/workspace/drive/api/reference/rest/v2/permissions/update?hl=ko] PUT /drive/v2/files/{fileId}/permissions/{permissionId}\n권한을 업데이트합니다.\nREST 리소스: v2.properties [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties?hl=ko]\n메서드\ndelete [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/delete?hl=ko] DELETE /drive/v2/files/{fileId}/properties/{propertyKey}\n속성을 삭제합니다.\nget [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/get?hl=ko] GET /drive/v2/files/{fileId}/properties/{propertyKey}\n키를 기준으로 속성을 가져옵니다.\ninsert [https://developers.google.com/workspace/drive/api/reference/rest/v2/properties/insert?hl=ko] POST /drive/v2/files/{fileId}/properties\n파일에 속성을 추가하거나 이미 있는 경우 업데이트합니다.'
 '// Union field area can be only one of the following:\n  ""tableId"": string\n  // End of list of possible types for union field area.\n}\n필드\nsheetId\ninteger\n데이터를 추가할 시트 ID입니다.\nrows[]\nobject (RowData [https://developers.google.com/workspace/sheets/api/reference/rest/v4/spreadsheets/sheets?hl=ko#RowData])\n추가할 데이터입니다.\nfields\nstring (FieldMask [https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask] format)\n업데이트해야 하는 CellData의 필드입니다. 하나 이상의 필드를 지정해야 합니다. 루트는 CellData입니다. \'row.values\'는 지정해서는 안 됩니다. 단일 ""*""는 모든 필드를 나열하는 방법으로 사용할 수 있습니다.\n공용체 필드 area입니다. 위치 데이터를 작성해야 합니다. area는 다음 중 하나여야 합니다.\ntableId\nstring\n데이터를 추가할 테이블의 ID입니다. 데이터는 테이블 본문에만 추가됩니다.\n이 필드는 sheetId 필드보다 우선 적용됩니다.\nClearBasicFilterRequest\n시트에 기본 필터가 있는 경우 삭제합니다.\nJSON 표현\n{\n  ""sheetId"": integer\n}\n필드\nsheetId\ninteger\n기본 필터를 삭제할 시트 ID입니다.\nDeleteDimensionRequest\n시트에서 측정기준을 삭제합니다.\nJSON 표현\n{\n  ""range"": {\n    object (DimensionRange [https://developers.google.com/workspace/sheets/api/reference/rest/v4/DimensionRange?hl=ko])\n  }\n}\n필드\nrange\nobject (DimensionRange [https://developers.google.com/workspace/sheets/api/reference/rest/v4/DimensionRange?hl=ko])\n시트에서 삭제할 측정기준입니다.\nDeleteEmbeddedObjectRequest\n지정된 ID가 있는 삽입된 객체를 삭제합니다.'
 '| Fields |\n| --- |\n| target_id | int32 The target ID that identifies the target on the stream. Must be a positive number and non-zero. If target_id is 0 (or unspecified), the server will assign an ID for this target and return that in a TargetChange::ADD event. Once a target with target_id=0 is added, all subsequent targets must also have target_id=0. If an AddTarget request with target_id != 0 is sent to the server after a target with target_id=0 is added, the server will immediately send a response with a TargetChange::Remove event. Note that if the client sends multiple AddTarget requests without an ID, the order of IDs returned in TargetChange.target_ids are undefined. Therefore, clients should provide a target ID instead of relying on the server to assign one. If target_id is non-zero, there must not be an existing active target on this stream with the same ID. |\n| once | bool If the target should be removed once it is current and consistent. |'
 'URL은 gRPC 트랜스코딩 [https://google.aip.dev/127] 문법을 사용합니다.\n경로 매개변수\n매개변수\nfileId\nstring\n파일의 ID입니다.\nrevisionId\nstring\n버전의 ID입니다.\n요청 본문\n요청 본문에 Revision [https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko#Revision]의 인스턴스가 포함됩니다.\n응답 본문\n성공한 경우 응답 본문에 Revision [https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko#Revision]의 인스턴스가 포함됩니다.\n승인 범위\n다음 OAuth 범위 중 하나가 필요합니다.\nhttps://www.googleapis.com/auth/drive\nhttps://www.googleapis.com/auth/drive.appdata\nhttps://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다. 자세한 내용은 승인 가이드 [https://developers.google.com/workspace/guides/configure-oauth-consent?hl=ko]를 참고하세요.\n의견 보내기'
 '이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGoogle Drive [https://developers.google.com/workspace/drive?hl=ko]\n참조 [https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko]\n의견 보내기\nMethod: revisions.update\nbookmark_border\n이 페이지의 내용\nHTTP 요청 [https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko#http-request]\n경로 매개변수 [https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko#path-parameters]\n요청 본문 [https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko#request-body]\n응답 본문 [https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko#response-body]\n승인 범위 [https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions/update?hl=ko#authorization-scopes]\n패치 시맨틱스로 버전을 업데이트합니다.\nHTTP 요청\nPATCH https://www.googleapis.com/drive/v3/files/{fileId}/revisions/{revisionId}\nURL은 gRPC 트랜스코딩 [https://google.aip.dev/127] 문법을 사용합니다.\n경로 매개변수\n매개변수\nfileId\nstring\n파일의 ID입니다.'
 'URL은 gRPC 트랜스코딩 [https://google.aip.dev/127] 문법을 사용합니다.\n경로 매개변수\n매개변수\nfileId\nstring\n필수 항목입니다. 요청이 있는 항목의 ID입니다.\nproposalId\nstring\n필수 항목입니다. 해결할 액세스 제안의 ID입니다.\n요청 본문\n요청 본문은 비어 있어야 합니다.\n응답 본문\n성공한 경우 응답 본문에 AccessProposal [https://developers.google.com/workspace/drive/api/reference/rest/v3/accessproposals?hl=ko#AccessProposal]의 인스턴스가 포함됩니다.\n승인 범위\n다음 OAuth 범위 중 하나가 필요합니다.\nhttps://www.googleapis.com/auth/docs\nhttps://www.googleapis.com/auth/drive\nhttps://www.googleapis.com/auth/drive.file\nhttps://www.googleapis.com/auth/drive.metadata\nhttps://www.googleapis.com/auth/drive.metadata.readonly\nhttps://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다. 자세한 내용은 승인 가이드 [https://developers.google.com/workspace/guides/configure-oauth-consent?hl=ko]를 참고하세요.\n의견 보내기'
 '이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGoogle Drive [https://developers.google.com/workspace/drive?hl=ko]\n참조 [https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko]\n의견 보내기\nMethod: replies.update\nbookmark_border\n이 페이지의 내용\nHTTP 요청\n경로 매개변수\n요청 본문\n응답 본문\n승인 범위\n패치 시맨틱스로 답글을 업데이트합니다.\nHTTP 요청\nPATCH https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}/replies/{replyId}\nURL은 gRPC 트랜스코딩 [https://google.aip.dev/127] 문법을 사용합니다.\n경로 매개변수\n매개변수\nfileId\nstring\n파일의 ID입니다.\ncommentId\nstring\n댓글의 ID입니다.\nreplyId\nstring\n답장의 ID입니다.\n요청 본문\n요청 본문에 Reply [https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko#Reply]의 인스턴스가 포함됩니다.\n응답 본문\n성공한 경우 응답 본문에 Reply [https://developers.google.com/workspace/drive/api/reference/rest/v3/replies?hl=ko#Reply]의 인스턴스가 포함됩니다.\n승인 범위\n다음 OAuth 범위 중 하나가 필요합니다.\nhttps://www.googleapis.com/auth/drive\nhttps://www.googleapis.com/auth/drive.file'
 '이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGoogle Drive [https://developers.google.com/workspace/drive?hl=ko]\n참조 [https://developers.google.com/workspace/drive/api/reference/rest/v3?hl=ko]\n의견 보내기\nMethod: comments.update\nbookmark_border\n이 페이지의 내용\nHTTP 요청\n경로 매개변수\n요청 본문\n응답 본문\n승인 범위\n패치 시맨틱스로 주석을 업데이트합니다. 자세한 내용은 댓글 및 답글 관리 [https://developers.google.com/workspace/drive/api/guides/manage-comments?hl=ko]를 참고하세요.\n필수: fields 매개변수를 설정해야 합니다. 필요한 필드를 정확하게 반환하려면 특정 필드 반환 [https://developers.google.com/workspace/drive/api/guides/fields-parameter?hl=ko]을 참고하세요.\nHTTP 요청\nPATCH https://www.googleapis.com/drive/v3/files/{fileId}/comments/{commentId}\nURL은 gRPC 트랜스코딩 [https://google.aip.dev/127] 문법을 사용합니다.\n경로 매개변수\n매개변수\nfileId\nstring\n파일의 ID입니다.\ncommentId\nstring\n댓글의 ID입니다.\n요청 본문\n요청 본문에 Comment [https://developers.google.com/workspace/drive/api/reference/rest/v3/comments?hl=ko#Comment]의 인스턴스가 포함됩니다.\n응답 본문\n성공한 경우 응답 본문에 Comment [https://developers.google.com/workspace/drive/api/reference/rest/v3/comments?hl=ko#Comment]의 인스턴스가 포함됩니다.\n승인 범위'
 ""Q: AccessProposal 리소스의 'fileId' 필드는 무엇을 나타내나요?\nA: 'fileId' 필드는 액세스 제안이 있는 파일의 ID를 나타냅니다.""
 'Q: revisions.update 메서드의 경로 매개변수로 사용되는 fileId와 revisionId는 무엇을 의미하나요?\nA: revisions.update 메서드의 경로 매개변수로 사용되는 `fileId`는 파일의 ID를 의미하며, `revisionId`는 업데이트할 버전의 ID를 의미합니다.'
 'Q: replies.update 메서드의 경로 매개변수로 사용되는 fileId, commentId, replyId의 역할은 무엇인가요?\nA: 경로 매개변수는 다음과 같은 역할을 합니다:\n- `fileId`: 파일의 ID입니다.\n- `commentId`: 댓글의 ID입니다.\n- `replyId`: 답장의 ID입니다.\n이 매개변수들은 특정 파일의 특정 댓글에 대한 특정 답글을 식별하는 데 사용됩니다.'
 ""Q: 변경사항 리소스에서 'fileId' 필드는 어떤 정보를 담고 있나요?\nA: 'fileId' 필드는 변경된 파일의 ID를 담고 있습니다.""
 'Q: replies.list 메서드에서 사용할 수 있는 경로 매개변수는 무엇이며, 각각의 역할은 무엇인가요?\nA: replies.list 메서드에서 사용할 수 있는 경로 매개변수는 다음과 같습니다:\n- `fileId`: 파일의 ID입니다.\n- `commentId`: 댓글의 ID입니다.'
 ""Q: 앱 리소스의 JSON 표현에서 'primaryMimeTypes' 필드는 무엇을 의미하나요?\nA: 'primaryMimeTypes' 필드는 앱이 지원하는 기본 MIME 유형의 목록을 포함합니다. 이 목록은 문자열 배열로 표현됩니다.""
 'Q: changes.list 메서드의 응답 본문에서 \'largestChangeId\' 필드는 무엇을 의미하나요?\nA: \'largestChangeId\' 필드(필드명: largestChangeId)는 현재 가장 큰 변경 ID를 나타내며, 응답 본문 구조에서 다음과 같이 포함됩니다: \n```json\n{\n  ""items"": [\n    {\n      object (Change)\n    }\n  ],\n  ""largestChangeId"": string,\n  ""nextPageToken"": string,\n  ""kind"": string,\n  ""etag"": string,\n  ""newStartPageToken"": string,\n  ""selfLink"": string,\n  ""nextLink"": string\n}\n```'
 ""Q: 채널 리소스의 'expiration' 필드는 무엇을 나타내나요?\nA: 'expiration' 필드는 알림 채널 만료 날짜 및 시간(밀리초 단위의 Unix 타임스탬프로 표현)을 나타냅니다. 이 필드는 선택사항입니다.""
 'Q: permissionDetails 배열의 id 필드는 무엇을 나타내나요?\nA: permissionDetails[].id 필드는 이 권한의 ID를 나타냅니다. 이는 수혜자의 고유 식별자이며, 사용자 리소스에 permissionId로 게시됩니다. ID는 불투명 값으로 취급해야 합니다.'
 'Q: revisions.update 메서드를 호출한 후 성공적인 응답 본문에는 어떤 정보가 포함되나요?\nA: revisions.update 메서드를 호출한 후 성공적인 경우 응답 본문에는 Revision (https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko#Revision)의 인스턴스가 포함됩니다.'
 'Q: revisions.update 메서드의 요청 본문에는 어떤 내용이 포함되어야 하나요?\nA: revisions.update 메서드의 요청 본문에는 Revision (https://developers.google.com/workspace/drive/api/reference/rest/v3/revisions?hl=ko#Revision)의 인스턴스가 포함되어야 합니다.'
 'Q: revisions.update 메서드를 사용하여 파일의 특정 버전을 업데이트하려면 어떤 HTTP 요청을 사용해야 하나요?\nA: revisions.update 메서드를 사용하여 파일의 특정 버전을 업데이트하려면 다음과 같은 HTTP 요청을 사용해야 합니다:\n\n```\nPATCH https://www.googleapis.com/drive/v3/files/{fileId}/revisions/{revisionId}\n```\n여기서 `{fileId}`는 파일의 ID이고, `{revisionId}`는 업데이트할 버전의 ID입니다.'
 'Q: revisions.list 메서드를 사용하기 위해 필요한 OAuth 범위는 무엇인가요?\nA: revisions.list 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly'
 'Q: revisions.list 메서드에서 nextPageToken의 역할은 무엇인가요?\nA: nextPageToken은 다음 버전의 페이지 토큰으로, 버전 목록의 끝에 도달한 경우 이 값이 없습니다. 이 값이 채워져 있으면 결과의 추가 페이지를 가져와야 합니다.'
 'Q: revisions.list 메서드의 응답 본문 구조는 어떻게 되나요?\nA: revisions.list 메서드의 응답 본문은 다음과 같은 구조의 데이터를 포함합니다:\n\n```json\n{\n  ""revisions"": [\n    {\n      object (Revision)\n    }\n  ],\n  ""nextPageToken"": string,\n  ""kind"": string\n}\n```'
 'Q: revisions.list 메서드의 pageSize 쿼리 매개변수는 어떤 역할을 하나요?\nA: pageSize 쿼리 매개변수는 페이지당 반환할 최대 버전 수를 설정하는 데 사용됩니다. 이 매개변수를 통해 한 번에 가져올 수 있는 버전의 수를 조절할 수 있습니다.'
 'Q: 앱 필터링을 위해 사용할 수 있는 쿼리 매개변수는 무엇이 있나요?\nA: 앱 필터링을 위해 사용할 수 있는 쿼리 매개변수는 다음과 같습니다:\n- `appFilterExtensions`: 열기 필터링을 위한 파일 확장자의 쉼표로 구분된 목록입니다.\n- `appFilterMimeTypes`: 열기 필터링을 위한 MIME 유형의 쉼표로 구분된 목록입니다.\n- `languageCode`: BCP 47에 정의된 언어 또는 언어 코드입니다.'
 'Q: replies.delete 메서드의 경로 매개변수에 대해 설명해 주세요.\nA: replies.delete 메서드의 경로 매개변수는 다음과 같습니다:\n- `fileId`: 파일의 ID입니다.\n- `commentId`: 댓글의 ID입니다.\n- `replyId`: 답장의 ID입니다.'
 'Q: revisions.list 메서드를 사용하여 특정 파일의 버전을 나열하는 방법은 무엇인가요?\nA: revisions.list 메서드를 사용하여 특정 파일의 버전을 나열하려면 다음과 같은 HTTP GET 요청을 사용합니다:\n\n```\nGET https://www.googleapis.com/drive/v3/files/{fileId}/revisions\n```\n여기서 {fileId}는 파일의 ID입니다.'
 'Q: revisions.get 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?\nA: revisions.get 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n- https://www.googleapis.com/auth/drive.meet.readonly\n- https://www.googleapis.com/auth/drive.metadata\n- https://www.googleapis.com/auth/drive.metadata.readonly\n- https://www.googleapis.com/auth/drive.photos.readonly\n- https://www.googleapis.com/auth/drive.readonly\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.'
 'Q: revisions.get 메서드를 호출했을 때 성공적인 응답 본문에는 어떤 정보가 포함되나요?\nA: 성공한 경우 응답 본문에 Revision의 인스턴스가 포함됩니다.'
 'Q: revisions.get 메서드의 요청 본문은 어떻게 구성되나요?\nA: revisions.get 메서드의 요청 본문은 비어 있어야 합니다.'
 'Q: revisions.get 메서드에서 acknowledgeAbuse 쿼리 매개변수의 역할은 무엇인가요?\nA: acknowledgeAbuse 쿼리 매개변수는 사용자가 알려진 멀웨어나 기타 악성 파일을 다운로드할 때 따르는 위험을 인정하는지 여부를 나타냅니다. 이는 alt 매개변수가 media로 설정되어 있고 사용자가 파일의 소유자이거나 파일이 있는 공유 드라이브의 주최자인 경우에만 적용됩니다.'
 'Q: Google Drive API에서 현재 사용자에 대한 정보를 가져오는 방법은 무엇인가요?\nA: 현재 사용자에 대한 정보를 가져오려면 다음의 GET 메서드를 사용합니다: GET /drive/v2/about. 이 메서드는 Drive API 설정과 함께 현재 사용자에 대한 정보를 반환합니다.'
 ""Q: 사용자의 이메일 주소는 어떤 필드에서 확인할 수 있으며, 이 필드의 특성은 무엇인가요?\nA: 사용자의 이메일 주소는 'emailAddress' 필드에서 확인할 수 있습니다. 이 필드는 출력 전용이며, 사용자가 요청자에게 이메일 주소를 표시하지 않은 경우 특정 컨텍스트에 표시되지 않을 수 있습니다.""
 ""Q: 'me' 필드는 어떤 정보를 나타내며, 그 데이터 타입은 무엇인가요?\nA: 'me' 필드는 이 사용자가 요청하는 사용자인지 여부를 나타내며, 데이터 타입은 boolean입니다. 이 필드는 출력 전용입니다.""
 ""Q: User 리소스의 'kind' 필드는 어떤 값을 가지며, 그 의미는 무엇인가요?\nA: 'kind' 필드는 리소스 종류를 식별하며, 고정 문자열 'drive#user' 값을 가집니다. 이 필드는 출력 전용입니다.""
 ""Q: User 리소스에서 'displayName' 필드는 어떤 정보를 담고 있나요?\nA: 'displayName' 필드는 사용자의 표시 가능한 일반 텍스트 이름을 담고 있습니다. 이 필드는 출력 전용입니다.""
 'Q: Drive API에서 사용자 정보를 요청할 때 반환되는 JSON 객체의 구조는 어떻게 되나요?\nA: 사용자 정보를 요청할 때 반환되는 JSON 객체의 구조는 다음과 같습니다:\n```json\n{\n  ""displayName"": string,\n  ""kind"": string,\n  ""me"": boolean,\n  ""permissionId"": string,\n  ""emailAddress"": string,\n  ""photoLink"": string\n}\n```'
 'Q: revisions.update 메서드를 사용하기 위해 필요한 OAuth 승인 범위는 무엇인가요?\nA: revisions.update 메서드를 사용하기 위해서는 다음 OAuth 범위 중 하나가 필요합니다:\n- https://www.googleapis.com/auth/drive\n- https://www.googleapis.com/auth/drive.appdata\n- https://www.googleapis.com/auth/drive.file\n일부 범위는 제한되어 있으며 앱에서 이를 사용하려면 보안 평가가 필요합니다.'
 'Q: Google Drive에서 사용자가 인증된 앱을 설치했는지 여부는 어떻게 확인하나요?\nA: 사용자가 인증된 앱이 인증된 사용자에 의해 설치되었는지 여부는 isCurrentAppInstalled 필드를 통해 확인할 수 있습니다.'
 'Q: Google Drive에서 사용자의 언어 코드는 어떻게 확인하나요?\nA: 사용자의 언어 또는 언어 코드는 languageCode 필드를 통해 확인할 수 있습니다.'
 'Q: Google Drive에서 사용자가 공유 드라이브를 만들 수 있는지 여부는 어떻게 확인하나요?\nA: 사용자가 공유 드라이브를 만들 수 있는지 여부는 canCreateDrives 필드를 통해 확인할 수 있습니다.'
 'Q: Google Drive에서 사용자의 총 할당량 바이트 수는 어떻게 확인하나요?\nA: 사용자의 총 할당량 바이트 수는 quotaBytesTotal 필드를 통해 확인할 수 있습니다.'
 'Q: Google Drive에서 사용자의 도메인 공유 정책은 어떤 값이 있을까요?\nA: 현재 사용자의 도메인 공유 정책(domainSharingPolicy)은 다음과 같은 값이 있습니다: allowed, allowedWithWarning, incomingOnly, disallowed.'
 'Q: Google Drive에서 사용자의 이름은 어떻게 확인하나요?\nA: 현재 사용자의 이름은 name 필드를 통해 확인할 수 있습니다. 이 필드는 사용자의 이름을 문자열로 포함합니다. 예를 들어, 다음과 같은 JSON 표현을 통해 확인할 수 있습니다.\n\n```json\n{\n  ""name"": ""홍길동""\n}\n```']","'fileId'는 Google Drive API에서 파일의 고유 식별자를 의미합니다. 이는 특정 파일을 식별하고 조작하는 데 사용됩니다. 예를 들어, 파일의 메타데이터를 가져오거나, 파일을 업데이트하거나, 삭제하는 등의 작업을 수행할 때 'fileId'가 필요합니다.",fileId는 파일의 ID를 의미합니다.
"Gmail 작업을 선언하는 방법에 대해 자세히 알고 싶은데, Declaring Actions 관련 자료는 어디서 찿을수 있나요?","['Gmail 작업\nGmail은 schema.org 마크업을 사용하여 사용자 작업을 가속화하고 사용자가 이메일에서 필요로 하는 가장 중요한 정보를 강조합니다.\nGmail은 다음과 같은 유형의 작업 및 대화형 카드를 지원합니다.\n클릭 한 번으로 실행할 수 있는 거의 모든 항목에 대한 원클릭 작업 [https://developers.google.com/workspace/gmail/markup/reference/one-click-action?hl=ko]\n더 복잡한 상호작용을 위한 Go-to Action [https://developers.google.com/workspace/gmail/markup/reference/go-to-action?hl=ko]\n항공편 양방향 카드 [https://developers.google.com/workspace/gmail/markup/reference/flight-reservation?hl=ko]\nGmail 하이라이트\nGmail은 동일한 schema.org 마크업을 사용하여 이메일 내에서 가장 중요한 정보를 강조 표시하고 사용자가 이에 따라 조치를 취할 수 있도록 합니다.\n버스 강조 표시 [https://developers.google.com/workspace/gmail/markup/reference/bus-reservation?hl=ko]\n렌터카 하이라이트 [https://developers.google.com/workspace/gmail/markup/reference/rental-car?hl=ko]\n항공편 하이라이트 [https://developers.google.com/workspace/gmail/markup/reference/flight-reservation?hl=ko]\n티켓이 있는 이벤트의 이벤트 하이라이트 [https://developers.google.com/workspace/gmail/markup/reference/event-reservation?hl=ko]\n주문 [https://developers.google.com/workspace/gmail/markup/reference/order?hl=ko] 및 소포 배송 [https://developers.google.com/workspace/gmail/markup/reference/parcel-delivery?hl=ko] 쇼핑 관련 주요 사항'
 'Source URL: https://developers.google.com/workspace/gmail/markup/actions/handling-action-requests\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGmail [https://developers.google.com/workspace/gmail?hl=ko]\n가이드 [https://developers.google.com/workspace/gmail/api/guides?hl=ko]\n의견 보내기\n작업 요청 처리\nbookmark_border\n이 페이지의 내용\n1단계: 요청 확인\n2단계: 작업 처리\n3단계: 응답 코드 반환\n추가 자료\n작업 선언 [https://developers.google.com/workspace/gmail/markup/actions/declaring-actions?hl=ko]에 설명된 대로 사용자가 인앱 작업과 상호작용하면 Google은 작업에 선언된 URL로 HTTP 요청을 보냅니다.\n다음 예에서는 비용 보고서에 관한 이메일에 ConfirmAction 버튼을 추가합니다.\n--- 탭: JSON-LD ---\n<script type=""application/ld+json"">\n{\n  ""@context"": ""http://schema.org"",\n  ""@type"": ""EmailMessage"",\n  ""potentialAction"": {\n    ""@type"": ""ConfirmAction"",\n    ""name"": ""Approve Expense"",\n    ""handler"": {\n      ""@type"": ""HttpActionHandler"",\n      ""url"": ""https://myexpenses.com/approve?expenseId=abc123""\n    }\n  },\n  ""description"": ""Approval request for John\'s $10.13 expense for office supplies""\n}\n</script>'
 'Source URL: https://developers.google.com/workspace/gmail/markup/actions/declaring-actions\n\n이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGmail [https://developers.google.com/workspace/gmail?hl=ko]\n가이드 [https://developers.google.com/workspace/gmail/api/guides?hl=ko]\n의견 보내기\n작업 선언\nbookmark_border\n이 페이지의 내용\n바로가기 작업\n모바일 딥 링크\n인앱 액션 수\n만료되는 작업\n추가 자료\nschema.org의 작업은 구조화된 데이터에서 실행할 수 있는 동사 또는 활동을 나타냅니다. 여러 유형의 작업 [https://developers.google.com/workspace/gmail/markup/actions/actions-overview?hl=ko]이 지원되며 모두 유사한 구조화된 데이터로 정의할 수 있습니다.\n바로가기 작업\nschema.org 항목을 사용하여 콘텐츠에 마크업을 추가하는 경우 해당 항목에 이동 작업을 추가할 수 있습니다. 예를 들어 EmailMessage 항목에 ViewAction 바로가기 링크를 추가하려면 다음 예와 같이 이메일의 potentialAction 속성을 채웁니다.\n--- 탭: JSON-LD ---\n<script type=""application/ld+json"">\n{\n  ""@context"": ""http://schema.org"",\n  ""@type"": ""EmailMessage"",\n  ""potentialAction"": {\n    ""@type"": ""ViewAction"",\n    ""target"": ""https://watch-movies.com/watch?movieId=abc123"",\n    ""name"": ""Watch movie""\n  },\n  ""description"": ""Watch the \'Avengers\' movie online""\n}\n</script>'
 '이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGmail [https://developers.google.com/workspace/gmail?hl=ko]\n가이드 [https://developers.google.com/workspace/gmail/api/guides?hl=ko]\n의견 보내기\n개요\nbookmark_border\n이 페이지의 내용\nschema.org로 이메일의 잠재력 활용\nGmail 작업\nGmail 하이라이트\nGmail 프로모션 탭\nGoogle Calendar\nschema.org로 이메일의 잠재력 활용\n이메일은 업무를 처리하는 데 중요한 역할을 합니다. 친구와 이벤트를 계획하거나 파리 출장을 준비할 때 이메일을 사용하여 작업을 진행할 것입니다. 사용자에게 보내는 이메일에 schema.org [http://schema.org/] 마크업을 추가하면 Google 환경 전반에서 해당 정보를 사용할 수 있으며 사용자가 항공편 체크인과 같은 빠른 작업을 쉽게 실행할 수 있습니다. Gmail, Google Calendar, Google 검색, Google 앱은 이미 이 구조화된 데이터를 사용하고 있습니다.\nSchema.org [http://schema.org/]는 Google 및 기타 회사의 공동작업으로 표준화되고 관리되는 마크업 어휘입니다. schema.org와 협력하여 Google은 삽입된 마크업을 수신하는 모든 이메일 제품에서 사용할 수 있도록 개방형 표준을 만들고 있습니다.\n앱에 이메일 마크업을 고려해야 하는 이유에 관한 동영상에서 동기 부여를 얻고 유사한 예를 확인하세요.\n참고: Google에서 사용하는 일부 스키마는 아직 schema.org [http://schema.org/]의 표준화 절차를 거치고 있으므로 향후 변경될 수 있습니다. 자세히 알아보기 [https://developers.google.com/workspace/gmail/markup/reference/schema-org-proposals?hl=ko]\nGmail 작업'
 'Gmail의 원클릭 작업\n자세한 내용은 원클릭 작업 참조 [https://developers.google.com/workspace/gmail/markup/reference/one-click-action?hl=ko]를 참고하세요.\n바로가기 작업\n더 복잡한 상호작용의 경우 Go-To Actions를 사용하여 작업을 실행할 수 있는 페이지로 바로 연결되는 링크를 제공할 수 있습니다. 버튼을 클릭하면 사용자가 작업 정의에 지정된 페이지로 리디렉션됩니다.\n바로가기 작업은 여러 단계가 필요하거나 받은편지함에서 실행할 수 없는 중요한 데이터 수집이 필요한 작업에 사용해야 합니다. 예를 들어 체크인 알림을 보내는 항공사는 이동 작업을 추가하여 사용자가 항공사 웹사이트로 빠르게 이동하여 좌석을 선택하거나 업그레이드를 요청할 수 있습니다.\n\nGmail의 이동 작업\n자세한 내용은 Go-To 작업 참조 [https://developers.google.com/workspace/gmail/markup/reference/go-to-action?hl=ko]를 참고하세요.\n추가 자료\n작업 선언 [https://developers.google.com/workspace/gmail/markup/actions/declaring-actions?hl=ko]\n참고: Google에서 사용하는 스키마 중 일부는 아직 schema.org [http://schema.org/]의 표준화 절차를 거치고 있으므로 향후 변경될 수 있습니다. 자세히 알아보기 [https://developers.google.com/workspace/gmail/markup/reference/schema-org-proposals?hl=ko]\n의견 보내기'
 '--- 탭: 마이크로데이터 ---\n<div itemscope itemtype=""http://schema.org/EmailMessage"">\n  <meta itemprop=""name"" content=""Watch movie""/>\n  ... information about the movie ...\n  <div itemprop=""potentialAction"" itemscope itemtype=""http://schema.org/ViewAction"">\n    <meta itemprop=""target"" content=""https://watch-movies.com/watch?movieId=abc123""/>\n    <meta itemprop=""target"" content=""android-app://com.watchmovies.android/http/watch-movies.com/watch?movieId=abc123""/>\n    <meta itemprop=""target"" content=""ios://12345/movieapp/watch-movies.com/watch?movieId=abc123""/>\n </div>\n</div>\n사용자에게 앱이 없는 경우 작업은 사용자를 제공된 웹 URL로 안내합니다.\n인앱 액션 수\n인앱 액션은 사용자를 다른 웹사이트로 보내지 않고 Gmail 내에서 바로 처리됩니다. 인앱 작업은 이동 작업 [https://developers.google.com/workspace/gmail/markup/actions/declaring-actions?hl=ko#go-to_actions]과 같이 선언되지만 사용자 에이전트 (예: Gmail)가 인라인으로 작업을 쉽게 처리할 수 있도록 하는 추가 정보가 포함되어 있습니다.\ntarget로 작업을 선언하는 대신 적절한 구성으로 작업에 HttpActionHandler를 선언해야 합니다.\n예를 들어 사용자에게 승인, 확인, 인정을 요구하는 이메일에 확인 버튼을 추가할 수 있습니다. 사용자가 버튼을 클릭하면 Google에서 서비스로 HTTP 요청을 발행하여 확인을 기록합니다. ConfirmAction 유형은 한 번만 상호작용할 수 있습니다.\n다음 예에서는 비용 보고서에 관한 이메일에 ConfirmAction 버튼을 추가합니다.\n--- 탭: JSON-LD ---\n<script type=""application/ld+json"">\n{'
 '3단계: 응답 코드 반환\n서비스가 작업을 처리하고 기록하는 데 성공하면 응답 코드 200 (OK)를 반환해야 합니다. 오류 상황에서는 다음 응답 코드를 사용할 수 있습니다.\n응답 코드 실험군\n400 (Bad Request) Google에서 작업을 실패합니다.\n401 (Unauthorized) Google에서 작업을 실패합니다.\n404(찾을 수 없음) Google에서 작업을 실패합니다.\n408 (요청 시간 초과) Google에서 나중에 다시 시도합니다.\n영구적으로 실패하는 경우 Google은 사용자에게 작업이 실패했으며 이메일 내의 대체 안내를 따라야 한다고 알립니다.\n추가 자료\n작업 보안 [https://developers.google.com/workspace/gmail/markup/actions/securing-actions?hl=ko]\n참고: Google에서 사용하는 스키마 중 일부는 아직 schema.org [http://schema.org/]의 표준화 절차를 거치고 있으므로 향후 변경될 수 있습니다. 자세히 알아보기 [https://developers.google.com/workspace/gmail/markup/reference/schema-org-proposals?hl=ko]\n의견 보내기'
 '이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGmail [https://developers.google.com/workspace/gmail?hl=ko]\n가이드 [https://developers.google.com/workspace/gmail/api/guides?hl=ko]\n의견 보내기\nFAQ\nbookmark_border\n이 페이지의 내용\n이러한 새로운 기능을 사용하는 데 비용이 드나요? [https://developers.google.com/workspace/gmail/promotab/faq?hl=ko#is_there_any_cost_associated_with_these_new_features]\n주석을 추가하면 이메일이 다른 탭으로 이동하나요? [https://developers.google.com/workspace/gmail/promotab/faq?hl=ko#does_adding_the_annotation_cause_my_email_to_go_into_a_different_tab]\n프로모션 탭이 아닌 다른 탭에 도착한 이메일에 주석을 달면 어떻게 되나요? [https://developers.google.com/workspace/gmail/promotab/faq?hl=ko#what_if_i_annotate_an_email_that_lands_in_a_tab_other_than_the_promotions_tab]\n이메일에 이러한 기능이 모두 포함되어야 하나요? [https://developers.google.com/workspace/gmail/promotab/faq?hl=ko#does_an_email_need_to_contain_all_these_features]\n특가 배지의 색상을 변경할 수 있나요? [https://developers.google.com/workspace/gmail/promotab/faq?hl=ko#can_i_change_the_color_of_the_deal_badge]\n다음은 이메일 마케팅 담당자와 개발자가 자주 묻는 질문 목록입니다.'
 '다음은 이메일 마케팅 담당자와 개발자가 자주 묻는 질문 목록입니다.\n이러한 새로운 기능을 사용하는 데 비용이 드나요?\n아니요. 번들의 이메일 메시지와 핵심 내용을 미리보기는 무료 이메일용이므로 무료입니다. 일반 사용자 (무료) 버전의 Gmail에서 표시되는 유일한 유료 방법은 Gmail 광고 [https://support.google.com/google-ads/answer/7019460?hl=ko]입니다. Google Workspace Gmail에는 광고가 게재되지 않습니다.\n주석을 추가하면 이메일이 다른 탭으로 이동하나요?\n주석은 Gmail 탭 분류기에 영향을 미치지 않습니다.\n프로모션 탭이 아닌 다른 탭에 도착한 이메일에 주석을 달면 어떻게 되나요?\n이 기능은 프로모션 탭에만 표시됩니다.\n이메일에 이러한 기능이 모두 포함되어야 하나요?\n아니요. 모든 기능은 선택사항입니다. 이메일의 가시성을 높이려면 로고 및 단일 이미지 기능을 사용하는 것이 좋습니다.\n특가 배지의 색상을 변경할 수 있나요?\n아니요. 혜택 배지는 녹색이며 색상을 변경할 수 없습니다. 모든 사용자를 위해 최상의 사용자 환경을 제공하기 위해 특가 배지의 색상, 크기, 모양은 맞춤설정할 수 없습니다. 기능의 콘텐츠만 맞춤설정할 수 있습니다 (권장사항 [https://developers.google.com/workspace/gmail/promotab/best-practices?hl=ko] 참고).\n내 마케팅 이메일은 할인이나 할인 기반이 아닌데, 이 기능은 할인에만 적용되나요?\n아니요, 모든 마케팅 이메일에 주석을 달 수 있으며 기능을 자유롭게 조합할 수 있습니다. 예를 들어 이메일이 할인이나 할인에 관한 것이 아니라 제품 프로모션에 관한 것이더라도 로고와 이미지를 사용하여 이메일에 주석을 달 수 있습니다.\n이메일이 번들로 표시되는데 내가 주석을 추가하지 않은 이유는 무엇인가요?\n주석이 없어도 이메일이 번들에 표시될 수 있습니다. Gmail에서는 주석이 있는지 여부와 관계없이 이전 사용자 참여를 기반으로 이메일을 추천합니다.\n업무 범위는 무엇인가요? 각 이메일에 수동으로 추가해야 하나요?\n주석은 확장 가능한 방식으로 생성되었습니다. 이메일 템플릿/HTML에 추가하고 CRM 병합을 사용하는 등 이메일 본문과 동일한 방식으로 필드를 채우세요.\n동적 스크립트를 사용하여 기능을 채울 수 있나요?'
 '이 페이지는 Cloud Translation API [https://cloud.google.com/translate/?hl=ko]를 통해 번역되었습니다.\nSwitch to English\n홈 [https://developers.google.com/?hl=ko]\nGoogle Workspace [https://developers.google.com/workspace?hl=ko]\nGmail [https://developers.google.com/workspace/gmail?hl=ko]\n가이드 [https://developers.google.com/workspace/gmail/api/guides?hl=ko]\n의견 보내기\n작업이란 무엇인가요?\nbookmark_border\n이 페이지의 내용\n인앱 액션 수 [https://developers.google.com/workspace/gmail/markup/actions/actions-overview?hl=ko#in-app_actions]\n원클릭 작업 [https://developers.google.com/workspace/gmail/markup/actions/actions-overview?hl=ko#one-click_action]\n바로가기 작업 [https://developers.google.com/workspace/gmail/markup/actions/actions-overview?hl=ko#go-to_actions]\n추가 자료 [https://developers.google.com/workspace/gmail/markup/actions/actions-overview?hl=ko#further_reading]\n작업을 사용하면 사용자가 Gmail 내에서 바로 제품 또는 서비스와 상호작용할 수 있습니다.\n예를 들어 잡지 구독이 만료된다는 알림을 보낼 때 알림에서 바로 갱신 옵션을 표시할 수 있습니다.\n작업은 인앱 액션 또는 이동 작업의 두 가지 방법으로 선언할 수 있습니다. 현재 여러 유형의 작업이 지원됩니다.\n인앱 액션 수\n인앱 액션은 사용자를 다른 웹사이트로 보내지 않고 Gmail 내에서 바로 처리됩니다. 이러한 작업에는 클릭 한 번으로 실행하는 작업이 포함됩니다.\n원클릭 작업'
 'try {\n      // Enable auto reply by restricting domain with start time and end time\n      VacationSettings vacationSettings = new VacationSettings()\n          .setEnableAutoReply(true)\n          .setResponseBodyHtml(\n              ""I am on vacation and will reply when I am back in the office. Thanks!"")\n          .setRestrictToDomain(true)\n          .setStartTime(LocalDateTime.now()\n              .toEpochSecond(ZoneOffset.from(ZonedDateTime.now())) * 1000)\n          .setEndTime(LocalDateTime.now().plusDays(7)\n              .toEpochSecond(ZoneOffset.from(ZonedDateTime.now())) * 1000);'
 '<!--Add buttons to initiate auth sequence and sign out-->\n    <button id=""authorize_button"" onclick=""handleAuthClick()"">Authorize</button>\n    <button id=""signout_button"" onclick=""handleSignoutClick()"">Sign Out</button>\n\n    <pre id=""content"" style=""white-space: pre-wrap;""></pre>\n\n    <script type=""text/javascript"">\n      /* exported gapiLoaded */\n      /* exported gisLoaded */\n      /* exported handleAuthClick */\n      /* exported handleSignoutClick */\n\n      // TODO(developer): Set to client ID and API key from the Developer Console\n      const CLIENT_ID = \'<YOUR_CLIENT_ID>\';\n      const API_KEY = \'<YOUR_API_KEY>\';\n\n      // Discovery doc URL for APIs used by the quickstart\n      const DISCOVERY_DOC = \'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest\';\n\n      // Authorization scopes required by the API; multiple scopes can be\n      // included, separated by spaces.\n      const SCOPES = \'https://www.googleapis.com/auth/gmail.readonly\';\n\n      let tokenClient;\n      let gapiInited = false;\n      let gisInited = false;'
 '// Optionally, include the following PromotionCard properties:\n      <meta itemprop=""headline"" content=""HEADLINE2""/>\n      <meta itemprop=""price"" content=""PRICE2""/>\n      <meta itemprop=""priceCurrency"" content=""PRICE_CURRENCY2""/>\n      <meta itemprop=""discountValue"" content=""DISCOUNT_VALUE2""/>\n      <meta itemprop=""position"" content=""POSITION""/>\n    </div>\n\n    // To include more image previews, add additional PromotionCard objects.\n    // You can include up to 10 image previews in a product carousel.\n  </head>'
 'with open(attachment_filename, ""rb"") as fp:\n      attachment_data = fp.read()\n    mime_message.add_attachment(attachment_data, maintype, subtype)\n\n    encoded_message = base64.urlsafe_b64encode(mime_message.as_bytes()).decode()\n\n    create_draft_request_body = {""message"": {""raw"": encoded_message}}\n    # pylint: disable=E1101\n    draft = (\n        service.users()\n        .drafts()\n        .create(userId=""me"", body=create_draft_request_body)\n        .execute()\n    )\n    print(f\'Draft id: {draft[""id""]}\\nDraft message: {draft[""message""]}\')\n  except HttpError as error:\n    print(f""An error occurred: {error}"")\n    draft = None\n  return draft\n\n\ndef build_file_part(file):\n  """"""Creates a MIME part for a file.\n\n  Args:\n    file: The path to the file to be attached.\n\n  Returns:\n    A MIME part that can be attached to a message.\n  """"""\n  content_type, encoding = mimetypes.guess_type(file)'
 'try:\n    # create gmail api client\n    service = build(""gmail"", ""v1"", credentials=creds)\n\n    epoch = datetime.utcfromtimestamp(0)\n    now = datetime.now()\n    start_time = (now - epoch).total_seconds() * 1000\n    end_time = (now + timedelta(days=7) - epoch).total_seconds() * 1000\n    vacation_settings = {\n        ""enableAutoReply"": True,\n        ""responseBodyHtml"": (\n            ""I am on vacation and will reply when I am ""\n            ""back in the office. Thanks!""\n        ),\n        ""restrictToDomain"": True,\n        ""startTime"": long(start_time),\n        ""endTime"": long(end_time),\n    }\n\n    # pylint: disable=E1101\n    response = (\n        service.users()\n        .settings()\n        .updateVacation(userId=""me"", body=vacation_settings)\n        .execute()\n    )\n    print(f""Enabled AutoReply with message: {response.get(\'responseBodyHtml\')}"")\n\n  except HttpError as error:\n    print(f""An error occurred: {error}"")\n    response = None\n\n  return response\n\n\nif __name__ == ""__main__"":\n  enable_auto_reply()\n자동 답장을 사용 중지하려면 리소스를 업데이트하고 enableAutoReply를 false로 설정합니다. endTime가 구성된 경우 지정된 시간이 지나면 자동 답장이 자동으로 사용 중지됩니다.\n의견 보내기'
 'Q: Gmail의 작업 선언 방법에 대한 자료는 어디에서 찾을 수 있나요?\nA: 작업 선언 방법에 대한 자세한 내용은 작업 선언(Declaring Actions) 문서를 참고하세요.'
 'Q: Gmail에서 원클릭 작업(One-Click Action)을 어떻게 선언하나요?\nA: Gmail의 원클릭 작업을 선언하는 방법에 대한 자세한 내용은 원클릭 작업 참조(One-Click Action Reference)를 확인하세요.'
 'Q: Gmail API를 사용하기 위해 필요한 인증 및 승인 처리에 대한 정보는 어디에서 찾을 수 있나요?\nA: Gmail API를 사용하기 위해 필요한 인증 및 승인 처리를 비롯한 Google Workspace API 개발에 대한 정보는 Google Workspace 개발자 시작하기 가이드를 참고하면 됩니다.'
 'Q: 인앱 액션을 선언할 때 어떤 추가 정보가 필요한가요?\nA: 인앱 작업은 이동 작업과 같이 선언되지만 사용자 에이전트(예: Gmail)가 인라인으로 작업을 쉽게 처리할 수 있도록 하는 추가 정보가 포함되어야 합니다.'
 'Q: Gmail에서 schema.org 마크업을 사용하여 어떤 작업을 지원하나요?\nA: Gmail은 schema.org 마크업을 사용하여 사용자 작업을 가속화하고 사용자가 이메일에서 필요로 하는 가장 중요한 정보를 강조합니다. 지원하는 작업 유형은 다음과 같습니다: 원클릭 작업(One-click Action), Go-to Action, 항공편 양방향 카드(Flight Reservation)입니다.'
 'Q: 작업 요청 처리에 대한 추가 자료는 어디에서 찾을 수 있나요?\nA: 작업 요청 처리에 대한 추가 자료는 다음 링크에서 확인할 수 있습니다: [작업 요청 처리](https://developers.google.com/workspace/gmail/markup/actions/handling-action-requests?hl=ko).'
 'Q: Gmail 메일 가져오기 도구의 Gmail 관련 코드는 어디에서 탐색할 수 있나요?\nA: Gmail 관련 코드는 GitHub 저장소 [https://github.com/google/mail-importer/tree/master/src/main/java/to/lean/tools/gmail/importer/gmail]에서 탐색할 수 있습니다.'
 'Q: Google Workspace 개발자 커뮤니티 포럼은 어디에서 찾을 수 있나요?\nA: Google Workspace 개발자 커뮤니티 포럼은 [여기](https://discuss.google.dev/c/google-workspace/20?hl=ko)에서 찾을 수 있으며, Google Workspace 개발에 관한 대화에 참여할 수 있습니다.'
 'Q: 인앱 액션을 선언하는 방법은 무엇인가요?\nA: 인앱 액션은 이동 작업과 같이 선언되지만, 사용자 에이전트가 인라인으로 작업을 쉽게 처리할 수 있도록 추가 정보가 포함되어야 합니다. 예를 들어, ConfirmAction을 사용하여 사용자가 버튼을 클릭하면 HTTP 요청을 발행하여 확인을 기록할 수 있습니다.'
 'Q: 위임을 생성하는 방법에 대한 정보는 어디에서 찾을 수 있나요?\nA: 위임을 생성하는 방법에 대한 자세한 정보는 위임 참조(https://developers.google.com/workspace/gmail/api/v1/reference/users/settings/delegates/create?hl=ko)에서 확인할 수 있습니다.'
 'Q: Gmail 메일 가져오기 도구의 소스 코드는 어디에서 찾을 수 있나요?\nA: Gmail 메일 가져오기 도구의 소스 코드는 GitHub 저장소 [https://github.com/google/mail-importer]에서 클론하여 가져올 수 있습니다.'
 'Q: 도메인 추가에 대한 정보는 어디에서 찾을 수 있나요?\nA: 도메인 추가에 대한 정보는 Postmaster Tools 고객센터 도움말(Postmaster Tools Help Center)에서 확인할 수 있습니다.'
 'Q: Gmail에서 작업을 사용하면 어떤 이점이 있나요?\nA: 작업을 사용하면 사용자가 Gmail 내에서 바로 제품 또는 서비스와 상호작용할 수 있습니다. 예를 들어 잡지 구독이 만료된다는 알림을 보낼 때 알림에서 바로 갱신 옵션을 표시할 수 있습니다.'
 'Q: Python에서 Gmail IMAP에 OAuth 2.0으로 인증하기 위한 샘플 코드는 어디에서 찾을 수 있나요?\nA: Python 샘플은 다음 링크에서 시작할 수 있습니다: [시작하기](https://github.com/google/gmail-oauth2-tools/wiki/OAuth2DotPyRunThrough). 샘플 코드는 다음 링크에서 다운로드할 수 있습니다: [다운로드](https://raw.githubusercontent.com/google/gmail-oauth2-tools/master/python/oauth2.py).'
 'Q: 부분 리소스 작업을 통해 Gmail API의 성능을 어떻게 개선할 수 있나요?\nA: 부분 리소스 작업을 통해 관심 있는 데이터 부분만 보내고 받음으로써 API 호출의 성능을 개선할 수 있습니다. 이렇게 하면 애플리케이션에서 불필요한 필드를 전송하고 파싱하고 저장하지 않게 되어 리소스를 더 효율적으로 사용할 수 있습니다.'
 'Q: Gmail API에 대한 지원을 받기 위해 어떤 플랫폼을 사용할 수 있나요?\nA: Gmail API에 대한 지원을 받기 위해 사용할 수 있는 플랫폼으로는 Google Workspace 개발자 커뮤니티 포럼, Reddit의 관련 서브레딧, Stack Overflow가 있습니다. 각 플랫폼에서 다양한 질문과 대화를 통해 지원을 받을 수 있습니다.'
 'Q: 인증 도메인 설정 단계에서 참고할 수 있는 자료는 무엇인가요?\nA: 인증 도메인 설정 단계는 Postmaster Tools 고객센터 도움말(Postmaster Tools Help Center)에서 도메인 추가 섹션을 참고할 수 있습니다.'
 'Q: Gmail에서 하이라이트를 사용하여 어떤 정보를 표시할 수 있나요?\nA: Gmail의 하이라이트는 이메일의 주요 정보와 작업을 표시하며, 예를 들어 항공편 예약 확인 이메일에는 여행 요약과 체크인 링크가 포함된 칩이 표시됩니다. 또한 주문 영수증 이메일에는 구매 이미지와 예상 배송일이 포함된 칩이 표시됩니다.'
 'Q: 이벤트 예약 확인 이메일에서 어떤 정보를 표시할 수 있나요?\nA: 이벤트 예약 확인 이메일에서 티켓이 있는 이벤트 예약 마크업을 사용합니다. 티켓이 있는 이벤트 예약의 하이라이트에는 예약의 선택된 세부정보와 지정한 이미지가 표시됩니다. 유료 이벤트 하이라이트에서는 티켓 보기 작업을 비롯한 작업도 지원합니다.'
 'Q: 주문 마크업을 사용하여 이메일에서 어떤 정보를 표시할 수 있나요?\nA: 구매(디지털 또는 실제 상품) 영수증이 포함된 이메일에서 주문 마크업을 사용합니다. 사용자에게는 이메일 메시지 위에 비용, 예상 배송, 구매한 상품의 이미지가 포함된 칩이 표시됩니다. 주문 하이라이트는 주문 보기 작업을 비롯한 작업도 지원합니다.'
 'Q: SASL XOAUTH2 메커니즘을 사용하는 라이브러리와 샘플은 어디에서 찾을 수 있나요?\nA: SASL XOAUTH2 프로토콜 문서 외에도 OAuth 2.0 클라이언트 구현에 관한 자세한 내용은 OAuth 2.0을 사용하여 Google API에 액세스 페이지를 참고하세요. 라이브러리 및 샘플 페이지에서는 IMAP 또는 SMTP와 함께 SASL XOAUTH2 메커니즘을 사용하는 다양한 인기 언어로 된 코드 샘플을 제공합니다.'
 'Q: 작업 요청 처리 후 서비스가 반환해야 하는 응답 코드는 무엇인가요?\nA: 서비스가 작업을 처리하고 기록하는 데 성공하면 응답 코드 200 (OK)를 반환해야 합니다. 오류 상황에서는 다음 응답 코드를 사용할 수 있습니다:\n- 400 (Bad Request): Google에서 작업을 실패합니다.\n- 401 (Unauthorized): Google에서 작업을 실패합니다.\n- 404 (찾을 수 없음): Google에서 작업을 실패합니다.\n- 408 (요청 시간 초과): Google에서 나중에 다시 시도합니다.'
 'Q: Gmail API Go 클라이언트를 실행하기 위해 필요한 작업 디렉터리를 어떻게 설정하나요?\nA: 작업 디렉터리를 설정하기 위해 다음 명령어를 사용합니다:\n\n```bash\nmkdir quickstart\ncd quickstart\ngo mod init quickstart\n```'
 'Q: Gmail API를 사용하여 자동 응답을 설정하는 방법은 무엇인가요?\nA: 자동 응답을 설정하려면 Gmail API의 `updateVacation` 메서드를 사용하여 `VacationSettings` 객체를 구성해야 합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n\n```java\nVacationSettings vacationSettings = new VacationSettings()\n    .setEnableAutoReply(true)\n    .setResponseBodyHtml(\n        ""I am on vacation and will reply when I am back in the office. Thanks!"")\n    .setRestrictToDomain(true)\n    .setStartTime(LocalDateTime.now()\n        .toEpochSecond(ZoneOffset.from(ZonedDateTime.now())) * 1000)\n    .setEndTime(LocalDateTime.now().plusDays(7)\n        .toEpochSecond(ZoneOffset.from(ZonedDateTime.now())) * 1000);\n\nVacationSettings response = service.users().settings()\n    .updateVacation(""me"", vacationSettings).execute();\n```'
 'Q: Python에서 Gmail API를 통해 자동 응답을 활성화하는 코드는 어떻게 되나요?\nA: Python에서 자동 응답을 활성화하려면 다음과 같은 코드를 사용할 수 있습니다:\n\n```python\ndef enable_auto_reply():\n  creds, _ = google.auth.default()\n\n  try:\n    service = build(""gmail"", ""v1"", credentials=creds)\n\n    epoch = datetime.utcfromtimestamp(0)\n    now = datetime.now()\n    start_time = (now - epoch).total_seconds() * 1000\n    end_time = (now + timedelta(days=7) - epoch).total_seconds() * 1000\n    vacation_settings = {\n        ""enableAutoReply"": True,\n        ""responseBodyHtml"": (\n            ""I am on vacation and will reply when I am back in the office. Thanks!""\n        ),\n        ""restrictToDomain"": True,\n        ""startTime"": start_time,\n        ""endTime"": end_time\n    }\n\n    response = service.users().settings().updateVacation(""me"", vacation_settings).execute()\n    return response\n  except HttpError as error:\n    print(f\'An error occurred: {error}\')\n    return None\n```'
 'Q: Gmail API를 사용하기 위한 샘플 HTML 파일을 설정하는 방법은 무엇인가요?\nA: 작업 디렉터리에 index.html이라는 파일을 만들고, 다음 샘플 코드를 붙여넣습니다:\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Gmail API Quickstart</title>\n    <meta charset=""utf-8"" />\n  </head>\n  <body>\n    <p>Gmail API Quickstart</p>\n\n    <!--Add buttons to initiate auth sequence and sign out-->\n    <button id=""authorize_button"" onclick=""handleAuthClick()"">Authorize</button>\n    <button id=""signout_button"" onclick=""handleSignoutClick()"">Sign Out</button>\n\n    <pre id=""content"" style=""white-space: pre-wrap;""></pre>\n\n    <script type=""text/javascript"">\n      /* exported gapiLoaded */\n      /* exported gisLoaded */\n      /* exported handleAuthClick */\n      /* exported handleSignoutClick */\n\n      // TODO(developer): Set to client ID and API key from the Developer Console\n      const CLIENT_ID = \'<YOUR_CLIENT_ID>\';\n      const API_KEY = \'<YOUR_API_KEY>\';\n\n      // Discovery doc URL for APIs used by the quickstart\n      const DISCOVERY_DOC = \'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest\';\n```'
 'Q: Python에서 Gmail API를 사용하여 첨부파일이 있는 이메일 초안을 생성하는 방법은 무엇인가요?\nA: 다음은 Python에서 첨부파일이 있는 이메일 초안을 생성하는 방법입니다.\n\n```python\ndef gmail_create_draft_with_attachment():\n  """"""Create and insert a draft email with attachment.\n   Print the returned draft\'s message and id.\n  Returns: Draft object, including draft id and message meta data.\n\n  Load pre-authorized user credentials from the environment.\n  TODO(developer) - See https://developers.google.com/identity\n  for guides on implementing OAuth\n  """"""\n  # 코드 구현 부분\n```'
 'Q: 이메일에 제품 캐러셀을 추가하는 방법은 무엇인가요?\nA: 제품 캐러셀을 추가하려면 다음 단계를 따르세요. 마케팅 이메일 플랫폼에서 이메일을 만들고 이메일의 HTML 편집기를 엽니다. head 섹션에 script 태그를 추가하고, 각 이미지에 PromotionCard 객체를 추가합니다. 예시는 다음과 같습니다:\n\n```html\n<!DOCTYPE html PUBLIC ""-//W3C//DTD HTML 4.01//EN"">\n<html>\n  <head>\n    <script type=""application/ld+json"">\n      [\n        // Build the first image preview in your product carousel:\n        {\n          ""@context"": ""http://schema.org/"",\n          ""@type"": ""PromotionCard"",\n          ""image"": ""IMAGE_URL1"",\n          ""url"": ""PROMO_URL1"",\n\n          // Optionally, include the following PromotionCard properties:\n          ""headline"": ""HEADLINE1"",\n          ""price"": PRICE1,\n          ""priceCurrency"": ""PRICE_CURRENCY1"",\n          ""discountValue"": DISCOUNT_VALUE1,\n          ""position"": POSITION\n        },\n\n        // Build the second image preview in your product carousel:\n        {\n          ""@context"": ""http://schema.org/"",\n          ""@type"": ""PromotionCard"",\n          ""image"": ""IMAGE_URL2"",\n          ""url"": ""PROMO_URL2"",\n\n          // Optionally, include the following PromotionCard properties:\n          ""headline"": ""HEADLINE2"",\n          ""price"": PRICE2,\n          ""priceCurrency"": ""PRICE_CURRENCY2"",\n          ""discountValue"": DISCOUNT_VALUE2,\n          ""position"": POSITION\n        }\n\n        // To include more image previews, add additional PromotionCard objects.\n        // You can include up to 10 image previews in a product carousel.\n\n      ]\n    </script>\n  </head>\n\n  <body>\n    // The message of your email\n  </body>\n</html>\n```'
 'Q: quickstart.py 파일에 포함해야 할 기본 코드는 무엇인가요?\nA: quickstart.py 파일에 다음 코드를 포함해야 합니다:\n\n```python\nfrom __future__ import print_function\nimport pickle\nimport os.path\nfrom googleapiclient.discovery import build\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom google.auth.transport.requests import Request\nfrom googleapiclient import errors\n\n# If modifying these scopes, delete the file token.pickle.\nSCOPES = [\'https://www.googleapis.com/auth/postmaster.readonly\']\n\ndef main():\n    """"""Shows basic usage of the PostmasterTools v1beta1 API.\n    Prints the visible domains on user\'s domain dashboard in https://postmaster.google.com/managedomains.\n    """"""\n    creds = None\n    # The file token.pickle stores the user\'s access and refresh tokens, and is\n    # created automatically when the authorization flow completes for the first\n    # time.\n    if os.path.exists(\'token.pickle\'):\n        with open(\'token.pickle\', \'rb\') as token:\n            creds = pickle.load(token)\n    # If there are no (valid) credentials available, let the user log in.\n    if not creds or not creds.valid:\n        if creds and creds.expired and creds.refresh_token:\n            creds.refresh(Request())\n        else:\n            flow = InstalledAppFlow.from_client_secrets_file(\n                \'credentials.json\', SCOPES)\n            creds = flow.run_local_server(port=0)\n        # Save the credentials for the next run\n        with open(\'token.pickle\', \'wb\') as token:\n            pickle.dump(creds, token)\n\n    service = build(\'gmailpostmastertools\', \'v1beta1\', credentials=creds)\n\n    domains = service.domains().list().execute()\n    if not domains:\n        print(\'No domains found.\')\n    else:\n        print(\'Domains:\')\n        for domain in domains[\'domains\']:\n            print(domain)\n\nif __name__ == \'__main__\':\n  main()\n```'
 'Q: Python에서 Gmail API를 사용하기 위한 샘플 코드는 어떻게 되나요?\nA: Python에서 Gmail API를 사용하기 위한 샘플 코드는 다음과 같습니다: \n```python\nimport os.path\n\nfrom google.auth.transport.requests import Request\nfrom google.oauth2.credentials import Credentials\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\n# If modifying these scopes, delete the file token.json.\nSCOPES = [""https://www.googleapis.com/auth/gmail.readonly""]\n\ndef main():\n  """"""Shows basic usage of the Gmail API.\n  Lists the user\'s Gmail labels.\n  """"""\n  creds = None\n  # The file token.json stores the user\'s access and refresh tokens, and is\n  # created automatically when the authorization flow completes for the first\n  # time.\n  if os.path.exists(""token.json""):\n    creds = Credentials.from_authorized_user_file(""token.json"", SCOPES)\n  # If there are no (valid) credentials available, let the user log in.\n  if not creds or not creds.valid:\n    if creds and creds.expired and creds.refresh_token:\n      creds.refresh(Request())\n    else:\n      flow = InstalledAppFlow.from_client_secrets_file(\n          ""credentials.json"", SCOPES\n      )\n      creds = flow.run_local_server(port=0)\n    # Save the credentials for the next run\n    with open(""token.json"", ""w"") as token:\n      token.write(creds.to_json())\n\n  try:\n    # Call the Gmail API\n    service = build(""gmail"", ""v1"", credentials=creds)\n    results = service.users().labels().list(userId=""me"").execute()\n    labels = results.get(""labels"", [])\n\n    if not labels:\n      print(""No labels found."")\n      return\n    print(""Labels:"")\n    for label in labels:\n      print(label[""name""])\n\n  except HttpError as error:\n    # TODO(developer) - Handle errors\n```'
 'Q: quickstart.py 파일을 생성할 때 포함해야 할 코드는 무엇인가요?\nA: quickstart.py 파일에 포함해야 할 코드는 다음과 같습니다:\n\n```python\nfrom __future__ import print_function\nimport pickle\nimport os.path\nfrom googleapiclient.discovery import build\nfrom google_auth_oauthlib.flow import InstalledAppFlow\nfrom google.auth.transport.requests import Request\nfrom googleapiclient import errors\n\n# If modifying these scopes, delete the file token.pickle.\nSCOPES = [\'https://www.googleapis.com/auth/postmaster.readonly\']\n\ndef main():\n    """"""Shows basic usage of the PostmasterTools v1beta1 API.\n    Prints the visible domains on user\'s domain dashboard in https://postmaster.google.com/managedomains.\n    """"""\n    creds = None\n    # The file token.pickle stores the user\'s access and refresh tokens, and is\n    # created automatically when the authorization flow completes for the first\n    # time.\n    if os.path.exists(\'token.pickle\'):\n        with open(\'token.pickle\', \'rb\') as token:\n            creds = pickle.load(token)\n    # If there are no (valid) credentials available, let the user log in.\n    if not creds or not creds.valid:\n        if creds and creds.expired and creds.refresh_token:\n            creds.refresh(Request())\n        else:\n            flow = InstalledAppFlow.from_client_secrets_file(\n                \'credentials.json\', SCOPES)\n            creds = flow.run_local_server(port=0)\n        # Save the credentials for the next run\n        with open(\'token.pickle\', \'wb\') as token:\n            pickle.dump(creds, token)\n\n    service = build(\'gmailpostmastertools\', \'v1beta1\', credentials=creds)\n\n    domains = service.domains().list().execute()\n    if not domains:\n        print(\'No domains found.\')\n    else:\n        print(\'Domains:\')\n        for domain in domains[\'domains\']:\n            print(domain)\n\nif __name__ == \'__main__\':\n  main()\n```'
 'Q: Gmail API를 사용하기 위한 샘플 설정 파일을 어떻게 생성하나요?\nA: 작업 디렉터리에 quickstart.go이라는 파일을 만들고 파일에 다음 코드를 붙여넣습니다: \n```\npackage main\n\nimport (\n ""context""\n ""encoding/json""\n ""fmt""\n ""log""\n ""net/http""\n ""os""\n\n ""golang.org/x/oauth2""\n ""golang.org/x/oauth2/google""\n ""google.golang.org/api/gmail/v1""\n ""google.golang.org/api/option""\n)\n\n// Retrieve a token, saves the token, then returns the generated client.\nfunc getClient(config *oauth2.Config) *http.Client {\n // The file token.json stores the user\'s access and refresh tokens, and is\n // created automatically when the authorization flow completes for the first\n // time.\n tokFile := ""token.json""\n tok, err := tokenFromFile(tokFile)\n if err != nil {\n  tok = getTokenFromWeb(config)\n  saveToken(tokFile, tok)\n }\n return config.Client(context.Background(), tok)\n}\n\n// Request a token from the web, then returns the retrieved token.\nfunc getTokenFromWeb(config *oauth2.Config) *oauth2.Token {\n authURL := config.AuthCodeURL(""state-token"", oauth2.AccessTypeOffline)\n fmt.Printf(""Go to the following link in your browser then type the ""+\n  ""authorization code: \\n%v\\n"", authURL)\n\n var authCode string\n if _, err := fmt.Scan(&authCode); err != nil {\n  log.Fatalf(""Unable to read authorization code: %v"", err)\n }\n\n tok, err := config.Exchange(context.TODO(), authCode)\n if err != nil {\n  log.Fatalf(""Unable to retrieve token from web: %v"", err)\n }\n return tok\n}\n\n// Retrieves a token from a local file.\nfunc tokenFromFile(file string) (*oauth2.Token, error) {\n f, err := os.Open(file)\n if err != nil {\n  return nil, err\n }\n defer f.Close()\n tok := &oauth2.Token{}\n err = json.NewDecoder(f).Decode(tok)\n return tok, err\n}\n\n// Saves a token to a file path.\nfunc saveToken(path string, token *oauth2.Token) {\n fmt.Printf(""Saving credential file to: %s\\n"", path)\n f, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)\n if err != nil {\n  log.Fatalf(""Unable to cache oauth token: %v"", err)\n }\n defer f.Close()\n json.NewEncoder(f).Encode(token)\n}\n\nfunc main() {\n ctx := context.Background()\n b, err := os.ReadFile(""credentials.json"")\n if err != nil {\n  log.Fatalf(""Unable to read client secret file: %v"", err)\n }\n\n // If modifying these scopes, delete your previously saved token.json.\n config, err := google.ConfigFromJSON(b, gmail.GmailReadonlyScope)\n if err != nil {\n  log.Fatalf(""Unable to parse client secret\n```'
 'Q: Python에서 초안을 생성하는 코드 예시는 어떻게 되나요?\nA: 다음은 Python에서 초안을 생성하는 코드 예시입니다.\n\n```python\nimport base64\nfrom email.message import EmailMessage\n\nimport google.auth\nfrom googleapiclient.discovery import build\nfrom googleapiclient.errors import HttpError\n\ndef gmail_create_draft():\n  """"""Create and insert a draft email.\n   Print the returned draft\'s message and id.\n   Returns: Draft object, including draft id and message meta data.\n\n  Load pre-authorized user credentials from the environment.\n  TODO(developer) - See https://developers.google.com/identity\n  for guides on implementing OAuth2 for the application.\n  """"""\n  creds, _ = google.auth.default()\n\n  try:\n    # create gmail api client\n    service = build(""gmail"", ""v1"", credentials=creds)\n\n    message = EmailMessage()\n\n    message.set_content(""This is automated draft mail"")\n\n    message[""To""] = ""gduser1@workspacesamples.dev""\n    message[""From""] = ""gduser2@workspacesamples.dev""\n    message[""Subject""] = ""Automated draft""\n\n    # encoded message\n    encoded_message = base64.urlsafe_b64encode(message.as_bytes()).decode()\n\n    create_message = {""message"": {""raw"": encoded_message}}\n    # pylint: disable=E1101\n    draft = (\n        service.users()\n        .drafts()\n        .create(userId=""me"", body=create_message)\n        .execute()\n    )\n\n    print(f\'Draft id: {draft[""id""]}\\nDraft message: {draft[""message""]}\')\n\n  except HttpError as error:\n    print(f""An error occurred: {error}"")\n    draft = None\n\n  return draft\n\nif __name__ == ""__main__"":\n  gmail_create_draft()\n```'
 'Q: Gmail API에서 승인 코드를 액세스 토큰으로 교환하는 방법은 무엇인가요?\nA: 승인 코드를 액세스 토큰으로 교환하기 위해서는 `exchange_code` 메서드를 사용합니다. 이 메서드는 승인 코드를 인자로 받아 OAuth 2.0 자격 증명을 반환합니다. 다음은 코드 예시입니다.\n\n```python\ndef exchange_code(authorization_code):\n  """"""Exchange an authorization code for OAuth 2.0 credentials.\n\n  Args:\n    authorization_code: Authorization code to exchange for OAuth 2.0\n                        credentials.\n\n  Returns:\n    oauth2client.client.OAuth2Credentials instance.\n\n  Raises:\n    CodeExchangeException: an error occurred.\n  """"""\n  flow = flow_from_clientsecrets(CLIENTSECRETS_LOCATION, \' \'.join(SCOPES))\n  flow.redirect_uri = REDIRECT_URI\n  try:\n    credentials = flow.step2_exchange(authorization_code)\n    return credentials\n  except FlowExchangeError as error:\n    logging.error(\'An error occurred: %s\', error)\n    raise CodeExchangeException(None)\n```'
 'Q: Gmail API에서 PATCH 요청을 사용할 때 배열 필드를 처리하는 방법은 무엇인가요?\nA: Gmail API에서 PATCH 요청을 사용할 때 배열이 포함된 경우, 기존 배열을 사용자가 제공하는 배열로 바꿉니다. 배열의 항목을 부분적으로 수정하거나 추가하거나 삭제할 수는 없습니다. 예를 들어, 다음과 같이 요청을 작성할 수 있습니다.\n\n```http\nPATCH https://www.googleapis.com/demo/v1/324?fields=characteristics\nAuthorization: Bearer your_auth_token\nContent-Type: application/json\n\n{\n  ""characteristics"": {\n    ""followers"": [""Jo"", ""Liz""] /* Replace the followers array to delete Will and add Liz. */\n  }\n}\n```'
 'Q: Gmail API에서 ETag를 사용하여 PATCH 요청을 수행하는 방법은 무엇인가요?\nA: PATCH 요청을 수행할 때 ETag를 사용하려면, 요청 헤더에 \'If-Match\'를 포함하여 이전의 ETag 값을 전송해야 합니다. 예를 들어:\n\n```plaintext\nPATCH https://www.googleapis.com/demo/v1/324?fields=etag,title,comment,characteristics\nAuthorization: Bearer your_auth_token\nContent-Type: application/json\nIf-Match: ""ETagString""\n{\n  ""etag"": ""ETagString""\n  ""title"": """",                  /* Clear the value of the title by setting it to the empty string. */\n  ""comment"": null,              /* Delete the comment by replacing its value with null. */\n  ""characteristics"": {\n    ""length"": ""short"",\n    ""level"": ""10"",              /* Modify the level value. */\n    ""followers"": [""Jo"", ""Liz""], /* Replace the followers array to delete Will and add Liz. */\n    ""accuracy"": ""high""          /* Add a new characteristic. */\n  },\n}\n```'
 'Q: Gmail API를 사용하여 필터를 생성하는 방법은 무엇인가요?\nA: 다음은 Gmail API를 사용하여 필터를 생성하는 방법을 보여주는 Java 코드 예제입니다.\n\n```java\nimport com.google.api.client.googleapis.json.GoogleJsonError;\nimport com.google.api.client.googleapis.json.GoogleJsonResponseException;\nimport com.google.api.client.http.HttpRequestInitializer;\nimport com.google.api.client.http.javanet.NetHttpTransport;\nimport com.google.api.client.json.gson.GsonFactory;\nimport com.google.api.services.gmail.Gmail;\nimport com.google.api.services.gmail.GmailScopes;\nimport com.google.api.services.gmail.model.Filter;\nimport com.google.api.services.gmail.model.FilterAction;\nimport com.google.api.services.gmail.model.FilterCriteria;\nimport com.google.auth.http.HttpCredentialsAdapter;\nimport com.google.auth.oauth2.GoogleCredentials;\nimport java.io.IOException;\nimport java.util.Arrays;\n\n/* Class to demonstrate the use of Gmail Create Filter API */\npublic class CreateFilter {\n  /**\n   * Create a new filter.\n   *\n   * @param labelId - ID of the user label to add\n   * @return the created filter id, {@code null} otherwise.\n   * @throws IOException - if service account credentials file not found.\n   */\n  public static String createNewFilter(String labelId) throws IOException {\n        /* Load pre-authorized user credentials from the environment.\n           TODO(developer) - See https://developers.google.com/identity for\n            guides on implementing OAuth2 for your application. */\n    GoogleCredentials credentials = GoogleCredentials.getApplicationDefault()\n        .createScoped(GmailScopes.GMAIL_SETTINGS);\n    // 추가적인 코드...\n  }\n}\n```'
 'Q: Python에서 S/MIME 인증서를 업데이트할 때, 인증서의 만료 시간을 비교하는 방법은 무엇인가요?\nA: Python에서 S/MIME 인증서를 업데이트할 때, 인증서의 만료 시간을 비교하기 위해 `expire_dt` 매개변수를 사용합니다. 만약 `expire_dt`가 None인 경우, 현재 시간을 사용합니다. 다음은 관련 코드입니다:\n\n```python\nif not expire_dt:\n    expire_dt = datetime.datetime.now()\nif results and ""smimeInfo"" in results:\n    for smime_info in results[""smimeInfo""]:\n        exp = datetime.datetime.fromtimestamp(smime_info[""expiration""] / 1000)\n        if exp > expire_dt:\n            # 인증서가 만료되지 않은 경우 처리\n```'
 'Q: Gmail API Go 클라이언트에서 사용자의 라벨을 가져오는 방법은 무엇인가요?\nA: 사용자의 라벨을 가져오기 위해 `srv.Users.Labels.List(user).Do()` 메서드를 사용합니다. 아래는 해당 코드의 예시입니다:\n\n```go\nuser := ""me""\nr, err := srv.Users.Labels.List(user).Do()\nif err != nil {\n log.Fatalf(""Unable to retrieve labels: %v"", err)\n}\nif len(r.Labels) == 0 {\n fmt.Println(""No labels found."")\n return\n}\nfmt.Println(""Labels:"")\nfor _, l := range r.Labels {\n fmt.Printf(""- %s\\n"", l.Name)\n}\n```'
 'Q: 구독 요청을 사용자에게 전송하는 이메일의 기본 구조는 어떻게 되나요?\nA: 구독 요청을 사용자에게 전송하는 이메일의 기본 구조는 다음과 같습니다:\n```html\n<html>\n  <head>\n    <title>Please confirm your subscription to Mailing-List XYZ?</title>\n  </head>\n  <body>\n    <p>\n      Dear John, please confirm that you wish to be subscribed to the mailing list XYZ\n    </p>\n  </body>\n</html>\n```'
 'Q: Gmail API에서 PATCH 요청을 사용할 때 ETag를 사용하는 방법은 무엇인가요?\nA: Gmail API에서 ETag를 사용하는 리소스를 업데이트할 때는 If-Match HTTP 헤더에 현재 ETag를 제공해야 합니다. 예를 들어, 다음과 같이 PATCH 요청을 작성할 수 있습니다.\n\n```http\nPATCH https://www.googleapis.com/demo/v1/324?fields=etag,title,comment,characteristics\nAuthorization: Bearer your_auth_token\nContent-Type: application/json\nIf-Match: ""ETagString""\n{\n  ""etag"": ""ETagString""\n  ""title"": """",                  /* Clear the value of the title by setting it to the empty string. */\n  ""comment"": null,              /* Delete the comment by replacing its value with null. */\n  ""characteristics"": {\n    ""length"": ""short"",\n    ""level"": ""10"",              /* Modify the level value. */\n    ""followers"": [""Jo"", ""Liz""] /* Replace the followers array to delete Will and add Liz. */\n    ""accuracy"": ""high""          /* Add a new characteristic. */\n  },\n}\n```'
 ""Q: 구독 목록을 나열하는 방법은 무엇인가요?\nA: 구독 목록을 나열하기 위해 SubscribeHandler 클래스의 get 메서드를 사용합니다. 이 메서드는 Datastore에서 최대 1000개의 구독을 검색하고, 각 구독의 user_id를 출력합니다. 예시는 다음과 같습니다:\n```python\nclass SubscribeHandler(webapp2.RequestHandler):\n\n  def get(self):\n    # retrieve up to 1000 subscriptions from the Datastore\n    subscriptions = Subscription.all().fetch(1000)\n\n    if not subscriptions:\n      self.response.write('No subscriptions')\n      return\n\n    count = len(subscriptions)\n\n    for s in subscriptions:\n      self.response.write('%s subscribed<br/>' % (s.user_id))\n\n    self.response.write('<br/>')\n    self.response.write('%d subscriptions.' % (count))\n```""
 ""Q: 구독 요청을 전송하기 위한 이메일 템플릿을 어떻게 설정하나요?\nA: 구독 요청을 전송하기 위한 이메일 템플릿은 'mail_template.html' 파일에 설정할 수 있습니다. 이 파일에는 구조화된 데이터와 함께 이메일 본문이 포함되어야 하며, 예시는 다음과 같습니다:\n```html\n<html>\n  <head>\n    <title>Please confirm your subscription to Mailing-List XYZ?</title>\n  </head>\n  <body>\n    <p>\n      Dear John, please confirm that you wish to be subscribed to the mailing list XYZ.\n    </p>\n  </body>\n</html>\n```""]","Gmail 작업을 선언하는 방법에 대한 자세한 내용은 ""작업 선언(Declaring Actions)"" 문서를 참고하시면 됩니다. 해당 문서에서는 Gmail에서 작업을 선언하는 방법과 관련된 정보를 제공합니다.",작업 선언 방법에 대한 자세한 내용은 작업 선언(Declaring Actions) 문서를 참고하세요.
